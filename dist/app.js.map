{"version":3,"file":"app.js","mappings":";;;;;;;;;;AAAA;AACa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;AACA;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wQAAwQ;AAChR,QAAQ,qBAAqB;AAC7B,QAAQ,+WAA+W;AACvX,QAAQ,mCAAmC;AAC3C,QAAQ,gIAAgI;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAuD;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iFAAiF;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,cAAc;AACd,cAAc;AACd,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAqB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,MAAM,kCAAkC,KAAK;AACjG,YAAY,IAAqC;AACjD;AACA;AACA,aAAa,EAIJ;AACT;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA,iDAAiD,MAAM,kCAAkC,KAAK,8CAA8C,eAAe;AAC3J;AACA;AACA;AACA,QAAQ,IAAkF;AAC1F;AACA;AACA;AACA,SAAS,EASJ;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAkF;AAC1F;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mCAAmC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,KAAyC,EAAE,EAK9C;AACD;AACA,sBAAsB,OAAO,KAAK,QAAQ;AAC1C;AACA,iBAAiB,IAAI,IAAI,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAA+B,EAAE,EAIpC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAqC,EAAE,EAG1C;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,6BAA6B,KAAK,KAAK,MAAM;AAC7C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,gBAAgB,uDAAuD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA,wDAAwD,KAAK,0BAA0B,oBAAoB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,gEAAgE,SAAS;AACzE;AACA;AACA;AACA;AACA,2EAA2E,UAAU;AACrF;AACA;AACA,aAAa;AACb;AACA,wBAAwB,WAAW;AACnC;AACA,2DAA2D,SAAS;AACpE;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,UAAU;AAClB,QAAQ,oOAAoO;AAC5O,QAAQ,uCAAuC;AAC/C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qCAAqC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA,SAAS;AACT,gBAAgB,YAAY,gBAAgB,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B,eAAe,IAAI;AAC/D;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B,+BAA+B,IAAI;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B,gBAAgB,IAAI;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA,gBAAgB,4BAA4B,+BAA+B,IAAI;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B,cAAc,IAAI;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B,cAAc,IAAI;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,oFAAoF,8BAA8B;AAClH;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B,8BAA8B,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD,wBAAwB,iBAAiB;AACzC,gFAAgF,eAAe,MAAM,eAAe;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,oBAAoB,iBAAiB;AACrC;AACA,oEAAoE,eAAe;AACnF,mDAAmD,eAAe,QAAQ,eAAe,MAAM,eAAe;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,oBAAoB,iBAAiB;AACrC,gEAAgE,eAAe,QAAQ,eAAe,MAAM,eAAe;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,oBAAoB,iBAAiB;AACrC,oFAAoF,eAAe,MAAM,eAAe;AACxH;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,oBAAoB,iBAAiB;AACrC,6EAA6E,eAAe,MAAM,gBAAgB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,oBAAoB,iBAAiB;AACrC,wEAAwE,eAAe,QAAQ,eAAe,MAAM,eAAe;AACnI;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAM;AACrB,eAAe,qBAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAqC,EAAE,EAG1C;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,IAAqC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,gBAAgB,iEAAiE;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qCAAqC;AACjD;AACA,YAAY,IAAqC;AACjD,iGAAiG,UAAU;AAC3G;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,iGAAiG,UAAU;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAqC;AACzD,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA,uDAAuD,gBAAgB,oDAAoD,GAAG,GAAG,SAAS;AAC1I,uFAAuF,gBAAgB,+EAA+E,GAAG,GAAG,SAAS;AACrM,+EAA+E,oBAAoB;AACnG,4FAA4F,SAAS,SAAS,SAAS,OAAO,GAAG;AACjI;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,SAAS;AACrB,QAAQ,IAAqC;AAC7C,gBAAgB,8BAA8B;AAC9C,6GAA6G,GAAG;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8BAA8B,MAAM,cAAc,cAAc,IAAI;AAChF;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB,yEAAyE,qBAAqB;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB,eAAe,IAAI;AACpD;AACA,KAAK;AACL;AACA;AACA,gBAAgB,iBAAiB,kBAAkB,IAAI;AACvD,YAAY,IAAqC;AACjD;AACA,mDAAmD,gBAAgB,oDAAoD,IAAI,mCAAmC,KAAK;AACnK,8EAA8E,iBAAiB,mCAAmC,IAAI,mCAAmC,KAAK;AAC9K,+GAA+G,IAAI,aAAa,KAAK,4CAA4C,SAAS;AAC1L;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,iBAAiB,qBAAqB,IAAI;AAC1D;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,iBAAiB,cAAc,IAAI;AACnD;AACA,KAAK;AACL;AACA;AACA,gBAAgB,iBAAiB,cAAc,IAAI;AACnD;AACA,KAAK;AACL;AACA;AACA,gBAAgB,iBAAiB,iBAAiB,IAAI;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,iBAAiB,iBAAiB,IAAI;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,MAAM;AACtB,gBAAgB,eAAe;AAC/B;AACA,KAAK;AACL;AACA;AACA,gBAAgB,MAAM;AACtB,gBAAgB,eAAe;AAC/B;AACA,KAAK;AACL;AACA;AACA,gBAAgB,iBAAiB,cAAc,IAAI;AACnD,YAAY,IAAqC;AACjD,2EAA2E,oBAAoB;AAC/F;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,iBAAiB,cAAc,IAAI;AACnD,YAAY,IAAqC;AACjD,2EAA2E,oBAAoB;AAC/F;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,iBAAiB,uBAAuB,IAAI;AAC5D,YAAY,IAAqC;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,iBAAiB,aAAa,IAAI;AAClD;AACA,KAAK;AACL;AACA;AACA,gBAAgB,iBAAiB,cAAc,IAAI;AACnD,YAAY,IAAqC;AACjD;AACA;AACA,0EAA0E,GAAG;AAC7E;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD,iEAAiE,qBAAqB;AACtF;AACA;AACA;AACA,wEAAwE,IAAI;AAC5E;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA,YAAY,KAAqC;AACjD;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B,YAAY;AACtC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,gBAAgB,IAAqC;AACrD,uDAAuD,YAAY;AACnE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,IAAI,IAAqC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAwC;AACxE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA,gBAAgB;AAChB;AACA,YAAY,gBAAgB,qCAAqC,cAAc,eAAe,IAAI;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,YAAY,2CAA2C;AACvD;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB,MAAM,IAAI;AACtC,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA,oBAAoB,wDAAwD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAqC;AACzD,mEAAmE,gBAAgB;AACnF;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA,uDAAuD,gBAAgB,oDAAoD,GAAG,GAAG,gBAAgB;AACjJ,kFAAkF,iBAAiB,mCAAmC,GAAG,GAAG,gBAAgB;AAC5J;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,qCAAqC;AACjD;AACA,YAAY,IAAqC;AACjD,+FAA+F,iBAAiB;AAChH;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA,uDAAuD,gBAAgB,oDAAoD,GAAG,GAAG,gBAAgB;AACjJ,kFAAkF,iBAAiB,mCAAmC,GAAG,GAAG,gBAAgB;AAC5J;AACA;AACA;AACA;AACA,qBAAqB,IAAqC;AAC1D,+EAA+E,iBAAiB,KAAK,IAAI;AACzG;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA,uDAAuD,gBAAgB,oDAAoD,GAAG,GAAG,gBAAgB;AACjJ,kFAAkF,iBAAiB,mCAAmC,GAAG,GAAG,gBAAgB;AAC5J;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW,2BAA2B,MAAM;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,2BAA2B,MAAM;AAClF;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW,2BAA2B,MAAM;AACjF;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW,2BAA2B,MAAM;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA,mFAAmF,WAAW,yBAAyB,KAAK;AAC5H;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAkD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAqC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAqC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,oBAAoB,yDAAyD;AAC7E;AACA;AACA,oBAAoB,IAAqC;AACzD,+DAA+D,kBAAkB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAqC;AACzD,8DAA8D,kBAAkB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,KAAyC,EAAE,EAK9C;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,2DAA2D,MAAM,EAAE,UAAU;AAC7E,wDAAwD,YAAY,QAAQ,cAAc,qBAAqB,QAAQ;AACvH;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,0DAA0D;AACtE,YAAY,mDAAmD;AAC/D;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,UAAU;AAC1E;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA,2EAA2E,UAAU;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uEAAuE;AACnF,QAAQ,IAAqC;AAC7C;AACA;AACA,4DAA4D,gBAAgB,6DAA6D,SAAS;AAClJ,mDAAmD,SAAS,gBAAgB,UAAU;AACtF;AACA;AACA,4IAA4I,sBAAsB;AAClK;AACA;AACA,0IAA0I,eAAe;AACzJ;AACA;AACA;AACA,YAAY,oFAAoF;AAChG;AACA,UAAU,mFAAmF;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAA0C;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,YAAY,kDAAkD,6CAA6C,IAAI;AAC/G,YAAY,mEAAmE;AAC/E,YAAY,gCAAgC;AAC5C;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA,YAAY,+GAA+G;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+BAA+B;AAC3C,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,KAAK;AACjB,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAoC,kBAAkB,IAAI;AACtE;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ,OAAO,SAAS;AACpC;AACA;AACA;AACA,YAAY,6CAA6C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,YAAY,WAAW;AACvB,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA,wDAAwD,IAAI,gBAAgB,0BAA0B,2DAA2D,6BAA6B;AAC9L;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa,qBAAqB,IAAI;AAClD;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa,iBAAiB,IAAI;AAC9C;AACA;AACA;AACA;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa,IAAI,IAAI;AACjC;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa,UAAU,IAAI;AACvC;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa,YAAY,IAAI;AACzC;AACA;AACA;AACA,YAAY,sBAAsB;AAClC,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA,iCAAiC,0BAA0B;AAC3D;AACA,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB,KAAK,IAAI;AACzC,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,sCAAsC;AAClD;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAqC;AACzD;AACA;AACA,2EAA2E,IAAI;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qCAAqC;AACjD,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,YAAY,UAAU;AACtB,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe,SAAS,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAqB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA,KAAK;AACL,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY,kCAAkC,IAAI;AAC9D;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA,0CAA0C,IAAI,8CAA8C,gBAAgB;AAC5G;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA,SAAS;AACT;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA,iDAAiD,kBAAkB,qBAAqB,gBAAgB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,IAAqC;AAC7D,8DAA8D,0CAA0C;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,IAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA,aAAa;AACb;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,8DAA8D,qBAAqB,OAAO,gBAAgB;AAC1G;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,0GAA0G,qBAAqB,QAAQ,gBAAgB;AACvJ;AACA;AACA,QAAQ,IAAqC;AAC7C,iGAAiG,qBAAqB,OAAO,gBAAgB;AAC7I;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA,uFAAuF,eAAe,QAAQ,iBAAiB,kBAAkB,EAAE,sBAAsB,eAAe;AACxL;AACA;AACA;AACA;AACA,+EAA+E,eAAe,QAAQ,iBAAiB,kBAAkB,EAAE;AAC3I;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD,kDAAkD,IAAI,OAAO,qBAAqB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,0CAA0C,GAAG;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA,yDAAyD,GAAG,GAAG,IAAI;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA,kBAAkB,IAAI,GAAG,IAAI;AAC7B;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kBAAkB,sBAAsB,IAAI;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB,IAAI,uBAAuB;AAC9D;AACA;AACA;AACA;AACA,cAAc,0BAA0B,IAAI,OAAO;AACnD;AACA;AACA,yBAAyB,aAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,YAAY,WAAW;AACvB,YAAY,qBAAqB;AACjC;AACA;AACA,4HAA4H,gDAAgD,YAAY,SAAS,OAAO,GAAG;AAC3M;AACA;AACA;AACA,6DAA6D,SAAS,OAAO,GAAG;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yLAAyL,oBAAoB;AAC7M;AACA;AACA,iLAAiL,qBAAqB;AACtM;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW,kCAAkC,0BAA0B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,gBAAgB;AACjG;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,EAAE,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA,CAAC;AACD;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA,CAAC;AACD;AACA,QAAQ,IAAqC;AAC7C,wHAAwH,iBAAiB;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA;AACA,oBAAoB,IAAqC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,GAAG,qEAAqE,YAAY,uCAAuC,iBAAiB;AAC3O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,YAAY,OAAO,QAAQ,gCAAgC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA,YAAY,IAAqC;AACjD,gFAAgF,WAAW,OAAO,GAAG;AACrG;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,MAAM;AACd;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ,IAAqC;AAC7C,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA,iEAAiE,IAAI;AACrE,uEAAuE,IAAI,uCAAuC,gBAAgB;AAClI,yEAAyE,IAAI,8CAA8C,gBAAgB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,yEAAyE,QAAQ;AACjF;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA,YAAY,0BAA0B;AACtC,sCAAsC,SAAS;AAC/C,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,8GAA8G,IAAI;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA,iCAAiC,UAAU,GAAG,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAqC;AACtD,8GAA8G,WAAW;AACzH;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,wFAAwF,WAAW;AACnG;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,kDAAkD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wCAAwC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO,kBAAkB,IAAI;AACzC,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,iKAAiK,eAAe;AAChL;AACA;AACA,yBAAyB;AACzB,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA,gBAAgB;AAChB;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,oEAAoE,IAAI;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sCAAsC;AAClD;AACA;AACA,sDAAsD,QAAQ;AAC9D,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kCAAkC,QAAQ,IAAI;AAC1D,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,QAAQ,IAAqC;AAC7C;AACA,gCAAgC,6BAA6B,oBAAoB,SAAS;AAC1F,gBAAgB,6BAA6B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc,KAAK,sBAAsB;AACvE;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA,SAAS,EAGJ;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,oCAAoC,0BAA0B;AAC9D,uDAAuD,6BAA6B;AACpF,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA,aAAa,EAGJ;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,IAAI;AACpE;AACA;AACA,gBAAgB,0DAA0D;AAC1E;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oCAAoC,eAAe,IAAI;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA,gBAAgB,QAAQ,OAAO,IAAI;AACnC,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA,2DAA2D,iBAAiB,4CAA4C;AACxH;AACA;AACA,oBAAoB,IAAqC;AACzD,2DAA2D,0CAA0C;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,+DAA+D,IAAI;AACnE;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,IAAqC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA,YAAY,IAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA,YAAY,IAAqC;AACjD,wEAAwE,wBAAwB,eAAe,0CAA0C;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ,YAAY,IAAI;AACpC;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,eAAe;AAC/B;AACA;AACA,gBAAgB,IAAqC;AACrD,wBAAwB,cAAc;AACtC,wDAAwD,0CAA0C,gBAAgB,SAAS,oCAAoC,UAAU,cAAc,oCAAoC,aAAa,GAAG;AAC3O;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,UAAU,sBAAsB;AAChC,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,uCAAuC,sBAAsB,IAAI,sCAAsC,8BAA8B,IAAI;AAC5M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,oDAAoD,0CAA0C,uDAAuD,uBAAuB,eAAe,aAAa;AACxM;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ,mBAAmB,IAAI;AAC3C,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA,kCAAkC,KAAK,IAAI,yCAAyC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,YAAY,IAAqC;AACjD,oBAAoB,cAAc;AAClC,oDAAoD,0CAA0C,uDAAuD,WAAW,eAAe,SAAS;AACxL;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD,wEAAwE,6CAA6C,eAAe,0CAA0C;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,6CAA6C,gBAAgB,SAAS,oCAAoC,+BAA+B,eAAe,4BAA4B;AACxO;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,qCAAqC,KAAK,kBAAkB,MAAM;AAClE;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAqC;AACjD;AACA;AACA,aAAa,EAKJ;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,qBAAqB,sBAAsB,cAAc;AACzD;AACA;AACA,cAAc;AACd,uBAAuB,uBAAuB,aAAa;AAC3D,yBAAyB,2BAA2B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,qBAAqB,qCAAqC,cAAc;AACxE;AACA;AACA,cAAc;AACd,uBAAuB,uBAAuB,aAAa;AAC3D,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,IAAqC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,KAAyC,EAAE,EAK9C;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,IAAI;AACxD;AACA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD;AACA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,IAAI,KAAK,IAAI;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW,GAAG,KAAK,IAAI,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC,IAAI;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,0HAA0H,QAAQ;AAClI;AACA;AACA,qIAAqI,KAAK;AAC1I;AACA;AACA,gHAAgH,MAAM;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,uDAAuD;AACnE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA,4GAA4G,oBAAoB;AAChI;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;;AAEA,wBAAwB;AACxB,mCAAmC;AACnC,oCAAoC;AACpC,WAAW;AACX,qCAAqC;AACrC,6BAA6B;AAC7B,qBAAqB;AACrB,sBAAsB;AACtB,+BAA+B;AAC/B,uBAAuB;AACvB,wBAAwB;AACxB,8BAA8B;AAC9B,0BAA0B;AAC1B,qBAAqB;AACrB,wBAAwB;AACxB,gBAAgB;AAChB,gBAAgB;AAChB,yBAAyB;AACzB,0BAA0B;AAC1B,wBAAwB;AACxB,gBAAgB;AAChB,uBAAuB;AACvB,yBAAyB;AACzB,sBAAsB;AACtB,6BAA6B;AAC7B,gBAAgB;AAChB,qBAAqB;AACrB,iBAAiB;AACjB,oBAAoB;AACpB,aAAa;AACb,cAAc;AACd,YAAY;AACZ;;;;;;;;;;;AC9qQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI;AACpD;AACA;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,iLAAiL;AACzL,QAAQ,UAAU;AAClB,QAAQ,2WAA2W;AACnX,QAAQ,gIAAgI;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAqB;AACjF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wOAAwO;AAChP,QAAQ,2GAA2G;AACnH,QAAQ,WAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yOAAyO;AACjP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,uEAAuE;AACvE;AACA;AACA,QAAQ,mDAAmD;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,QAAQ,yHAAyH;AACjI;AACA;AACA,QAAQ,oBAAoB;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wKAAwK;;AAEhL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gBAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAuD;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA,SAAS,EAIJ;AACL;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,uIAAuI,KAAK;AAC5I,kIAAkI,KAAK;AACvI,kLAAkL,KAAK;AACvL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,4IAA4I,MAAM;AAClJ,kIAAkI,KAAK;AACvI,mLAAmL,MAAM;AACzL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uBAAuB;AAC/B;AACA;AACA;AACA,yBAAyB;AACzB;AACA,wBAAwB;AACxB;AACA,wBAAwB;AACxB;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA,wBAAwB,aAAa,EAAE,UAAU;AACjD;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,eAAe;AAC9F;AACA;AACA;AACA;AACA,wEAAwE,gBAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAqC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAkD;AAC9D;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA,6FAA6F,gBAAgB,aAAa,KAAK,4CAA4C,SAAS;AACpL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA,gGAAgG,cAAc,aAAa,KAAK,4CAA4C,SAAS;AACrL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,iEAAiE,uBAAuB;AACxF;AACA;AACA;AACA,kEAAkE,yBAAyB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB;AACvB,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA,wCAAwC,gBAAgB;AACxD,aAAa;AACb;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8FAA8F;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA,YAAY,yCAAyC;AACrD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uHAAuH;AACvH;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAqC;AACrD,0FAA0F,cAAc;AACxG;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA,IAAI,IAA+B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,8FAA8F,cAAc,IAAI,eAAe;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAqC;AAC7C,iGAAiG,cAAc,IAAI,eAAe,4CAA4C,yBAAyB;AACvM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,cAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+MAA+M,UAAU,6CAA6C,MAAM;AAC5Q;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wCAAwC;AAC5D;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;;;;;;;;;;;;;;;;ACpkJA;AACA;AACA;AACA;AACA,gEAAgE,kCAAkC,+CAA+C,8BAA8B,kCAAkC,gCAAgC,mBAAmB,0BAA0B,eAAe,qCAAqC,mBAAmB,2BAA2B,eAAe,uCAAuC,0BAA0B,gBAAgB,iDAAiD,iFAAiF,2BAA2B;AAC7nB;AACA;AACA,iEAAe,YAAY;;;;;;;;;;;;;;;;;;ACPU;;AAEQ;;AAEyB;;AAElB;AACpD,mBAAmB,8CAAa,mGAAmG,EAAE,GAAG,EAAE,wEAAwE,EAAE,GAAG,EAAE,+FAA+F,EAAE,GAAG,EAAE,6EAA6E,EAAE,GAAG,EAAE,kGAAkG,EAAE,GAAG,EAAE,0HAA0H,EAAE,GAAG,EAAE;AAC7nB,mBAAmB,8CAAa,kHAAkH,EAAE,GAAG,EAAE,wEAAwE,EAAE,GAAG,EAAE,mHAAmH,EAAE,GAAG,EAAE,wCAAwC,EAAE,GAAG,EAAE,+DAA+D,EAAE,GAAG,EAAE,+EAA+E,EAAE,GAAG,EAAE,8DAA8D,EAAE,GAAG,EAAE,QAAQ,+NAA+N,EAAE,GAAG,EAAE;AACh2B,mBAAmB,8CAAa,wEAAwE,EAAE,GAAG,EAAE;AAC/G,mBAAmB,8CAAa,wEAAwE,EAAE,GAAG,EAAE;AAC/G;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,SAAS,2EAA2E;AACpF;AACA;AACA;AACA,iEAAe,qDAAgB,MAAM,EAAC;AACtC;;;AAGA,IAAI,gDAAoB;AACxB,gDAAgD,gDAAoB;AACpE;AACA,IAAI,mEAA0B;AAC9B,gDAAgD,mEAA0B;AAC1E;AACA;AACA,mDAAc;;;;;;;;;;;;;;;;;;AC7DiB;AACiD;AAChF,kBAAkB,iDAAgB;AAClC;AACA;AACA;AACA;AACA;AACA,iEAAe,sDAAkB;AACjC,QAAQ,iDAAK;AACb,CAAC,CAAC;;;;;;;;;;;ACVW;AACb,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;UCRlB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;ACN+B;AACK;AACT;;AAE3B,YAAY,kDAAa,aAAa,IAAI,8CAAK,EAAE;AACjD","sources":["webpack://inpcz/./node_modules/@lwc/engine-dom/dist/engine-dom.cjs.js","webpack://inpcz/./node_modules/@lwc/synthetic-shadow/dist/synthetic-shadow.js","webpack://inpcz/./src/client/modules/my/app/app.css","webpack://inpcz/./src/client/modules/my/app/app.html","webpack://inpcz/./src/client/modules/my/app/app.js","webpack://inpcz/./node_modules/lwc-webpack-plugin/dist/mocks/empty-style.js","webpack://inpcz/webpack/bootstrap","webpack://inpcz/webpack/runtime/compat get default export","webpack://inpcz/webpack/runtime/define property getters","webpack://inpcz/webpack/runtime/global","webpack://inpcz/webpack/runtime/hasOwnProperty shorthand","webpack://inpcz/webpack/runtime/make namespace object","webpack://inpcz/./src/client/index.js"],"sourcesContent":["/* proxy-compat-disable */\n'use strict';\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction invariant(value, msg) {\n    if (!value) {\n        throw new Error(`Invariant Violation: ${msg}`);\n    }\n}\nfunction isTrue$1(value, msg) {\n    if (!value) {\n        throw new Error(`Assert Violation: ${msg}`);\n    }\n}\nfunction isFalse$1(value, msg) {\n    if (value) {\n        throw new Error(`Assert Violation: ${msg}`);\n    }\n}\nfunction fail(msg) {\n    throw new Error(msg);\n}\n\nvar assert = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    fail: fail,\n    invariant: invariant,\n    isFalse: isFalse$1,\n    isTrue: isTrue$1\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { assign, create, defineProperties, defineProperty, freeze, getOwnPropertyDescriptor: getOwnPropertyDescriptor$1, getOwnPropertyNames: getOwnPropertyNames$1, getPrototypeOf: getPrototypeOf$1, hasOwnProperty: hasOwnProperty$1, isFrozen, keys, seal, setPrototypeOf, } = Object;\nconst { isArray: isArray$1 } = Array;\nconst { concat: ArrayConcat$1, copyWithin: ArrayCopyWithin, fill: ArrayFill, filter: ArrayFilter, find: ArrayFind, indexOf: ArrayIndexOf, join: ArrayJoin, map: ArrayMap, pop: ArrayPop, push: ArrayPush$1, reduce: ArrayReduce, reverse: ArrayReverse, shift: ArrayShift, slice: ArraySlice, some: ArraySome, sort: ArraySort, splice: ArraySplice, unshift: ArrayUnshift, forEach, } = Array.prototype;\nconst { fromCharCode: StringFromCharCode } = String;\nconst { charCodeAt: StringCharCodeAt, replace: StringReplace, split: StringSplit, slice: StringSlice, toLowerCase: StringToLowerCase, } = String.prototype;\nfunction isUndefined$1(obj) {\n    return obj === undefined;\n}\nfunction isNull(obj) {\n    return obj === null;\n}\nfunction isTrue(obj) {\n    return obj === true;\n}\nfunction isFalse(obj) {\n    return obj === false;\n}\nfunction isBoolean(obj) {\n    return typeof obj === 'boolean';\n}\nfunction isFunction$1(obj) {\n    return typeof obj === 'function';\n}\nfunction isObject(obj) {\n    return typeof obj === 'object';\n}\nfunction isString(obj) {\n    return typeof obj === 'string';\n}\nfunction isNumber(obj) {\n    return typeof obj === 'number';\n}\nfunction noop() {\n    /* Do nothing */\n}\nconst OtS$1 = {}.toString;\nfunction toString$1(obj) {\n    if (obj && obj.toString) {\n        // Arrays might hold objects with \"null\" prototype So using\n        // Array.prototype.toString directly will cause an error Iterate through\n        // all the items and handle individually.\n        if (isArray$1(obj)) {\n            return ArrayJoin.call(ArrayMap.call(obj, toString$1), ',');\n        }\n        return obj.toString();\n    }\n    else if (typeof obj === 'object') {\n        return OtS$1.call(obj);\n    }\n    else {\n        return obj + '';\n    }\n}\nfunction getPropertyDescriptor(o, p) {\n    do {\n        const d = getOwnPropertyDescriptor$1(o, p);\n        if (!isUndefined$1(d)) {\n            return d;\n        }\n        o = getPrototypeOf$1(o);\n    } while (o !== null);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and\n * ariaGrabbed) are deprecated:\n * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes\n *\n * The above list of 46 aria attributes is consistent with the following resources:\n * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060\n * https://wicg.github.io/aom/spec/aria-reflection.html\n *\n * NOTE: If you update this list, please update test files that implicitly reference this list!\n * Searching the codebase for `aria-flowto` and `ariaFlowTo` should be good enough to find all usages.\n */\nconst AriaPropertyNames = [\n    'ariaActiveDescendant',\n    'ariaAtomic',\n    'ariaAutoComplete',\n    'ariaBusy',\n    'ariaChecked',\n    'ariaColCount',\n    'ariaColIndex',\n    'ariaColSpan',\n    'ariaControls',\n    'ariaCurrent',\n    'ariaDescribedBy',\n    'ariaDetails',\n    'ariaDisabled',\n    'ariaErrorMessage',\n    'ariaExpanded',\n    'ariaFlowTo',\n    'ariaHasPopup',\n    'ariaHidden',\n    'ariaInvalid',\n    'ariaKeyShortcuts',\n    'ariaLabel',\n    'ariaLabelledBy',\n    'ariaLevel',\n    'ariaLive',\n    'ariaModal',\n    'ariaMultiLine',\n    'ariaMultiSelectable',\n    'ariaOrientation',\n    'ariaOwns',\n    'ariaPlaceholder',\n    'ariaPosInSet',\n    'ariaPressed',\n    'ariaReadOnly',\n    'ariaRelevant',\n    'ariaRequired',\n    'ariaRoleDescription',\n    'ariaRowCount',\n    'ariaRowIndex',\n    'ariaRowSpan',\n    'ariaSelected',\n    'ariaSetSize',\n    'ariaSort',\n    'ariaValueMax',\n    'ariaValueMin',\n    'ariaValueNow',\n    'ariaValueText',\n    'role',\n];\nconst { AriaAttrNameToPropNameMap, AriaPropNameToAttrNameMap } = /*@__PURE__*/ (() => {\n    const AriaAttrNameToPropNameMap = create(null);\n    const AriaPropNameToAttrNameMap = create(null);\n    // Synthetic creation of all AOM property descriptors for Custom Elements\n    forEach.call(AriaPropertyNames, (propName) => {\n        const attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, () => 'aria-'));\n        AriaAttrNameToPropNameMap[attrName] = propName;\n        AriaPropNameToAttrNameMap[propName] = attrName;\n    });\n    return { AriaAttrNameToPropNameMap, AriaPropNameToAttrNameMap };\n})();\n// These attributes take either an ID or a list of IDs as values.\n// This includes aria-* attributes as well as the special non-ARIA \"for\" attribute\nconst ID_REFERENCING_ATTRIBUTES_SET = new Set([\n    'aria-activedescendant',\n    'aria-controls',\n    'aria-describedby',\n    'aria-details',\n    'aria-errormessage',\n    'aria-flowto',\n    'aria-labelledby',\n    'aria-owns',\n    'for',\n]);\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// See browser support for globalThis:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility\n/* istanbul ignore next */\n// @ts-ignore\nconst _globalThis = typeof globalThis === 'object' ? globalThis : window;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst KEY__IS_NATIVE_SHADOW_ROOT_DEFINED = '$isNativeShadowRootDefined$';\nconst KEY__SHADOW_RESOLVER = '$shadowResolver$';\nconst KEY__SHADOW_STATIC = '$shadowStaticNode$';\nconst KEY__SHADOW_TOKEN = '$shadowToken$';\nconst KEY__SYNTHETIC_MODE = '$$lwc-synthetic-mode';\nconst KEY__SCOPED_CSS = '$scoped$';\nconst KEY__NATIVE_GET_ELEMENT_BY_ID = '$nativeGetElementById$';\nconst KEY__NATIVE_QUERY_SELECTOR_ALL = '$nativeQuerySelectorAll$';\nconst XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\nconst SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\nconst XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CAMEL_REGEX = /-([a-z])/g;\n// Convoluted map generation so that @lwc/shared remains fully tree-shakable (verify-treeshakable)\nconst { NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING, NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING } = \n/*#__PURE__*/ (() => {\n    /**\n     * Map composed of properties to attributes not following the HTML property to attribute mapping\n     * convention.\n     */\n    const NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING = new Map([\n        ['accessKey', 'accesskey'],\n        ['readOnly', 'readonly'],\n        ['tabIndex', 'tabindex'],\n        ['bgColor', 'bgcolor'],\n        ['colSpan', 'colspan'],\n        ['rowSpan', 'rowspan'],\n        ['contentEditable', 'contenteditable'],\n        ['crossOrigin', 'crossorigin'],\n        ['dateTime', 'datetime'],\n        ['formAction', 'formaction'],\n        ['isMap', 'ismap'],\n        ['maxLength', 'maxlength'],\n        ['minLength', 'minlength'],\n        ['noValidate', 'novalidate'],\n        ['useMap', 'usemap'],\n        ['htmlFor', 'for'],\n    ]);\n    /**\n     * Inverted map with attribute name key and property name value.\n     */\n    const NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING = new Map();\n    NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING.forEach((value, key) => NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING.set(value, key));\n    return {\n        NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING,\n        NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING,\n    };\n})();\n/**\n * Map associating previously transformed HTML property into HTML attribute.\n */\nconst CACHED_PROPERTY_ATTRIBUTE_MAPPING = new Map();\n/**\n * Map associating previously transformed HTML attribute into HTML property.\n */\nconst CACHED_ATTRIBUTE_PROPERTY_MAPPING = new Map();\nfunction htmlPropertyToAttribute(propName) {\n    const ariaAttributeName = AriaPropNameToAttrNameMap[propName];\n    if (!isUndefined$1(ariaAttributeName)) {\n        return ariaAttributeName;\n    }\n    const specialAttributeName = NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING.get(propName);\n    if (!isUndefined$1(specialAttributeName)) {\n        return specialAttributeName;\n    }\n    const cachedAttributeName = CACHED_PROPERTY_ATTRIBUTE_MAPPING.get(propName);\n    if (!isUndefined$1(cachedAttributeName)) {\n        return cachedAttributeName;\n    }\n    let attributeName = '';\n    for (let i = 0, len = propName.length; i < len; i++) {\n        const code = StringCharCodeAt.call(propName, i);\n        if (code >= 65 && // \"A\"\n            code <= 90 // \"Z\"\n        ) {\n            attributeName += '-' + StringFromCharCode(code + 32);\n        }\n        else {\n            attributeName += StringFromCharCode(code);\n        }\n    }\n    CACHED_PROPERTY_ATTRIBUTE_MAPPING.set(propName, attributeName);\n    return attributeName;\n}\nfunction htmlAttributeToProperty(attrName) {\n    const ariaPropertyName = AriaAttrNameToPropNameMap[attrName];\n    if (!isUndefined$1(ariaPropertyName)) {\n        return ariaPropertyName;\n    }\n    const specialPropertyName = NO_STANDARD_ATTRIBUTE_PROPERTY_MAPPING.get(attrName);\n    if (!isUndefined$1(specialPropertyName)) {\n        return specialPropertyName;\n    }\n    const cachedPropertyName = CACHED_ATTRIBUTE_PROPERTY_MAPPING.get(attrName);\n    if (!isUndefined$1(cachedPropertyName)) {\n        return cachedPropertyName;\n    }\n    const propertyName = StringReplace.call(attrName, CAMEL_REGEX, (g) => g[1].toUpperCase());\n    CACHED_ATTRIBUTE_PROPERTY_MAPPING.set(attrName, propertyName);\n    return propertyName;\n}\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ESCAPED_CHARS = {\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n};\nfunction htmlEscape(str, attrMode = false) {\n    const searchValue = attrMode ? /[\"&]/g : /[\"'<>&]/g;\n    return str.replace(searchValue, (char) => ESCAPED_CHARS[char]);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Increment whenever the LWC template compiler changes\nconst LWC_VERSION = \"2.37.3\";\nconst LWC_VERSION_COMMENT_REGEX = /\\/\\*LWC compiler v([\\d.]+)\\*\\/\\s*}/;\n/** version: 2.37.3 */\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst features = {\n    DUMMY_TEST_FLAG: null,\n    ENABLE_FORCE_NATIVE_SHADOW_MODE_FOR_TEST: null,\n    ENABLE_MIXED_SHADOW_MODE: null,\n    ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE: null,\n    ENABLE_WIRE_SYNC_EMIT: null,\n    ENABLE_LIGHT_GET_ROOT_NODE_PATCH: null,\n    DISABLE_LIGHT_DOM_UNSCOPED_CSS: null,\n    ENABLE_FROZEN_TEMPLATE: null,\n    DISABLE_ARIA_REFLECTION_POLYFILL: null,\n};\n// eslint-disable-next-line no-restricted-properties\nif (!_globalThis.lwcRuntimeFlags) {\n    Object.defineProperty(_globalThis, 'lwcRuntimeFlags', { value: create(null) });\n}\n// eslint-disable-next-line no-restricted-properties\nconst flags = _globalThis.lwcRuntimeFlags;\n/**\n * Set the value at runtime of a given feature flag. This method only be invoked once per feature\n * flag. It is meant to be used during the app initialization.\n */\nfunction setFeatureFlag(name, value) {\n    if (!isBoolean(value)) {\n        const message = `Failed to set the value \"${value}\" for the runtime feature flag \"${name}\". Runtime feature flags can only be set to a boolean value.`;\n        if (process.env.NODE_ENV !== 'production') {\n            throw new TypeError(message);\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.error(message);\n            return;\n        }\n    }\n    if (isUndefined$1(features[name])) {\n        const availableFlags = keys(features)\n            .map((name) => `\"${name}\"`)\n            .join(', ');\n        // eslint-disable-next-line no-console\n        console.warn(`Failed to set the value \"${value}\" for the runtime feature flag \"${name}\" because it is undefined. Available flags: ${availableFlags}.`);\n        return;\n    }\n    // This may seem redundant, but `process.env.NODE_ENV === 'test-karma-lwc'` is replaced by Karma tests\n    if (process.env.NODE_ENV === 'test-karma-lwc' || process.env.NODE_ENV !== 'production') {\n        // Allow the same flag to be set more than once outside of production to enable testing\n        flags[name] = value;\n    }\n    else {\n        // Disallow the same flag to be set more than once in production\n        const runtimeValue = flags[name];\n        if (!isUndefined$1(runtimeValue)) {\n            // eslint-disable-next-line no-console\n            console.error(`Failed to set the value \"${value}\" for the runtime feature flag \"${name}\". \"${name}\" has already been set with the value \"${runtimeValue}\".`);\n            return;\n        }\n        defineProperty(flags, name, { value });\n    }\n}\n/**\n * Set the value at runtime of a given feature flag. This method should only be used for testing\n * purposes. It is a no-op when invoked in production mode.\n */\nfunction setFeatureFlagForTest(name, value) {\n    // This may seem redundant, but `process.env.NODE_ENV === 'test-karma-lwc'` is replaced by Karma tests\n    if (process.env.NODE_ENV === 'test-karma-lwc' || process.env.NODE_ENV !== 'production') {\n        setFeatureFlag(name, value);\n    }\n}\n/** version: 2.37.3 */\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect(propName, prototype) {\n    return isUndefined$1(getOwnPropertyDescriptor$1(prototype, propName));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction createAriaPropertyPropertyDescriptor(attrName) {\n    // Note that we need to call this.{get,set,has,remove}Attribute rather than dereferencing\n    // from Element.prototype, because these methods are overridden in LightningElement.\n    return {\n        get() {\n            // reflect what's in the attribute\n            return this.hasAttribute(attrName) ? this.getAttribute(attrName) : null;\n        },\n        set(newValue) {\n            // reflect into the corresponding attribute\n            if (isNull(newValue)) {\n                this.removeAttribute(attrName);\n            }\n            else {\n                this.setAttribute(attrName, newValue);\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    };\n}\nfunction patch$1(propName, prototype) {\n    const attrName = AriaPropNameToAttrNameMap[propName];\n    const descriptor = createAriaPropertyPropertyDescriptor(attrName);\n    defineProperty(prototype, propName, descriptor);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction applyAriaReflection(prototype = Element.prototype) {\n    const ElementPrototypeAriaPropertyNames = keys(AriaPropNameToAttrNameMap);\n    for (let i = 0, len = ElementPrototypeAriaPropertyNames.length; i < len; i += 1) {\n        const propName = ElementPrototypeAriaPropertyNames[i];\n        if (detect(propName, prototype)) {\n            patch$1(propName, prototype);\n        }\n    }\n}\n/** version: 2.37.3 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (!lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {\n    // If DISABLE_ARIA_REFLECTION_POLYFILL is false, then we need to apply the ARIA reflection polyfill globally,\n    // i.e. to the global Element.prototype\n    applyAriaReflection();\n}\n\n/* proxy-compat-disable */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst onReportingEnabledCallbacks = [];\n/** The currently assigned reporting dispatcher. */\nlet currentDispatcher$1 = noop;\n/**\n * Whether reporting is enabled.\n *\n * Note that this may seem redundant, given you can just check if the currentDispatcher is undefined,\n * but it turns out that Terser only strips out unused code if we use this explicit boolean.\n */\nlet enabled$1 = false;\nconst reportingControl = {\n    /**\n     * Attach a new reporting control (aka dispatcher).\n     *\n     * @param dispatcher - reporting control\n     */\n    attachDispatcher(dispatcher) {\n        enabled$1 = true;\n        currentDispatcher$1 = dispatcher;\n        for (const callback of onReportingEnabledCallbacks) {\n            try {\n                callback();\n            }\n            catch (err) {\n                // This should never happen. But if it does, we don't want one callback to cause another to fail\n                // eslint-disable-next-line no-console\n                console.error('Could not invoke callback', err);\n            }\n        }\n        onReportingEnabledCallbacks.length = 0; // clear the array\n    },\n    /**\n     * Detach the current reporting control (aka dispatcher).\n     */\n    detachDispatcher() {\n        enabled$1 = false;\n        currentDispatcher$1 = noop;\n    },\n};\n/**\n * Call a callback when reporting is enabled, or immediately if reporting is already enabled.\n * Will only ever be called once.\n * @param callback\n */\nfunction onReportingEnabled(callback) {\n    if (enabled$1) {\n        // call immediately\n        callback();\n    }\n    else {\n        // call later\n        onReportingEnabledCallbacks.push(callback);\n    }\n}\n/**\n * Report to the current dispatcher, if there is one.\n * @param reportingEventId\n * @param payload - data to report\n */\nfunction report(reportingEventId, payload) {\n    if (enabled$1) {\n        currentDispatcher$1(reportingEventId, payload);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getComponentTag(vm) {\n    return `<${StringToLowerCase.call(vm.tagName)}>`;\n}\n// TODO [#1695]: Unify getComponentStack and getErrorComponentStack\nfunction getComponentStack(vm) {\n    const stack = [];\n    let prefix = '';\n    while (!isNull(vm.owner)) {\n        ArrayPush$1.call(stack, prefix + getComponentTag(vm));\n        vm = vm.owner;\n        prefix += '\\t';\n    }\n    return ArrayJoin.call(stack, '\\n');\n}\nfunction getErrorComponentStack(vm) {\n    const wcStack = [];\n    let currentVm = vm;\n    while (!isNull(currentVm)) {\n        ArrayPush$1.call(wcStack, getComponentTag(currentVm));\n        currentVm = currentVm.owner;\n    }\n    return wcStack.reverse().join('\\n\\t');\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction addErrorComponentStack(vm, error) {\n    if (!isFrozen(error) && isUndefined$1(error.wcStack)) {\n        const wcStack = getErrorComponentStack(vm);\n        defineProperty(error, 'wcStack', {\n            get() {\n                return wcStack;\n            },\n        });\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst alreadyLoggedMessages = new Set();\n// Only used in LWC's Karma tests\nif (process.env.NODE_ENV === 'test-karma-lwc') {\n    // @ts-ignore\n    window.__lwcResetAlreadyLoggedMessages = () => {\n        alreadyLoggedMessages.clear();\n    };\n}\nfunction log(method, message, vm, once) {\n    let msg = `[LWC ${method}]: ${message}`;\n    if (!isUndefined$1(vm)) {\n        msg = `${msg}\\n${getComponentStack(vm)}`;\n    }\n    if (once) {\n        if (alreadyLoggedMessages.has(msg)) {\n            return;\n        }\n        alreadyLoggedMessages.add(msg);\n    }\n    // In Jest tests, reduce the warning and error verbosity by not printing the callstack\n    if (process.env.NODE_ENV === 'test') {\n        /* eslint-disable-next-line no-console */\n        console[method](msg);\n        return;\n    }\n    try {\n        throw new Error(msg);\n    }\n    catch (e) {\n        /* eslint-disable-next-line no-console */\n        console[method](e);\n    }\n}\nfunction logError(message, vm) {\n    log('error', message, vm, false);\n}\nfunction logWarn(message, vm) {\n    log('warn', message, vm, false);\n}\nfunction logWarnOnce(message, vm) {\n    log('warn', message, vm, true);\n}\n\n/*\n * Copyright (c) 2019, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst TargetToReactiveRecordMap = new WeakMap();\nfunction getReactiveRecord(target) {\n    let reactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (isUndefined$1(reactiveRecord)) {\n        const newRecord = create(null);\n        reactiveRecord = newRecord;\n        TargetToReactiveRecordMap.set(target, newRecord);\n    }\n    return reactiveRecord;\n}\nlet currentReactiveObserver = null;\nfunction valueMutated(target, key) {\n    const reactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (!isUndefined$1(reactiveRecord)) {\n        const reactiveObservers = reactiveRecord[key];\n        if (!isUndefined$1(reactiveObservers)) {\n            for (let i = 0, len = reactiveObservers.length; i < len; i += 1) {\n                const ro = reactiveObservers[i];\n                ro.notify();\n            }\n        }\n    }\n}\nfunction valueObserved(target, key) {\n    // We should determine if an active Observing Record is present to track mutations.\n    if (currentReactiveObserver === null) {\n        return;\n    }\n    const ro = currentReactiveObserver;\n    const reactiveRecord = getReactiveRecord(target);\n    let reactiveObservers = reactiveRecord[key];\n    if (isUndefined$1(reactiveObservers)) {\n        reactiveObservers = [];\n        reactiveRecord[key] = reactiveObservers;\n    }\n    else if (reactiveObservers[0] === ro) {\n        return; // perf optimization considering that most subscriptions will come from the same record\n    }\n    if (ArrayIndexOf.call(reactiveObservers, ro) === -1) {\n        ro.link(reactiveObservers);\n    }\n}\nclass ReactiveObserver {\n    constructor(callback) {\n        this.listeners = [];\n        this.callback = callback;\n    }\n    observe(job) {\n        const inceptionReactiveRecord = currentReactiveObserver;\n        currentReactiveObserver = this;\n        let error;\n        try {\n            job();\n        }\n        catch (e) {\n            error = Object(e);\n        }\n        finally {\n            currentReactiveObserver = inceptionReactiveRecord;\n            if (error !== undefined) {\n                throw error; // eslint-disable-line no-unsafe-finally\n            }\n        }\n    }\n    /**\n     * This method is responsible for disconnecting the Reactive Observer\n     * from any Reactive Record that has a reference to it, to prevent future\n     * notifications about previously recorded access.\n     */\n    reset() {\n        const { listeners } = this;\n        const len = listeners.length;\n        if (len > 0) {\n            for (let i = 0; i < len; i += 1) {\n                const set = listeners[i];\n                const pos = ArrayIndexOf.call(listeners[i], this);\n                ArraySplice.call(set, pos, 1);\n            }\n            listeners.length = 0;\n        }\n    }\n    // friend methods\n    notify() {\n        this.callback.call(undefined, this);\n    }\n    link(reactiveObservers) {\n        ArrayPush$1.call(reactiveObservers, this);\n        // we keep track of observing records where the observing record was added to so we can do some clean up later on\n        ArrayPush$1.call(this.listeners, reactiveObservers);\n    }\n}\nfunction componentValueMutated(vm, key) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    {\n        valueMutated(vm.component, key);\n    }\n}\nfunction componentValueObserved(vm, key) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    {\n        valueObserved(vm.component, key);\n    }\n}\nfunction createReactiveObserver(callback) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    return new ReactiveObserver(callback) ;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet nextTickCallbackQueue = [];\nconst SPACE_CHAR = 32;\nconst EmptyObject = seal(create(null));\nconst EmptyArray = seal([]);\nfunction flushCallbackQueue() {\n    if (process.env.NODE_ENV !== 'production') {\n        if (nextTickCallbackQueue.length === 0) {\n            throw new Error(`Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.`);\n        }\n    }\n    const callbacks = nextTickCallbackQueue;\n    nextTickCallbackQueue = []; // reset to a new queue\n    for (let i = 0, len = callbacks.length; i < len; i += 1) {\n        callbacks[i]();\n    }\n}\nfunction addCallbackToNextTick(callback) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isFunction$1(callback)) {\n            throw new Error(`Internal Error: addCallbackToNextTick() can only accept a function callback`);\n        }\n    }\n    if (nextTickCallbackQueue.length === 0) {\n        Promise.resolve().then(flushCallbackQueue);\n    }\n    ArrayPush$1.call(nextTickCallbackQueue, callback);\n}\nfunction guid() {\n    function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000)\n            .toString(16)\n            .substring(1);\n    }\n    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();\n}\n// Borrowed from Vue template compiler.\n// https://github.com/vuejs/vue/blob/531371b818b0e31a989a06df43789728f23dc4e8/src/platforms/web/util/style.js#L5-L16\nconst DECLARATION_DELIMITER = /;(?![^(]*\\))/g;\nconst PROPERTY_DELIMITER = /:(.+)/;\nfunction parseStyleText(cssText) {\n    const styleMap = {};\n    const declarations = cssText.split(DECLARATION_DELIMITER);\n    for (const declaration of declarations) {\n        if (declaration) {\n            const [prop, value] = declaration.split(PROPERTY_DELIMITER);\n            if (prop !== undefined && value !== undefined) {\n                styleMap[prop.trim()] = value.trim();\n            }\n        }\n    }\n    return styleMap;\n}\n// Make a shallow copy of an object but omit the given key\nfunction cloneAndOmitKey(object, keyToOmit) {\n    const result = {};\n    for (const key of keys(object)) {\n        if (key !== keyToOmit) {\n            result[key] = object[key];\n        }\n    }\n    return result;\n}\nfunction flattenStylesheets(stylesheets) {\n    const list = [];\n    for (const stylesheet of stylesheets) {\n        if (!isArray$1(stylesheet)) {\n            list.push(stylesheet);\n        }\n        else {\n            list.push(...flattenStylesheets(stylesheet));\n        }\n    }\n    return list;\n}\n// Set a ref (lwc:ref) on a VM, from a template API\nfunction setRefVNode(vm, ref, vnode) {\n    if (process.env.NODE_ENV !== 'production' && isUndefined$1(vm.refVNodes)) {\n        throw new Error('refVNodes must be defined when setting a ref');\n    }\n    // If this method is called, then vm.refVNodes is set as the template has refs.\n    // If not, then something went wrong and we threw an error above.\n    const refVNodes = vm.refVNodes;\n    // In cases of conflict (two elements with the same ref), prefer, the last one,\n    // in depth-first traversal order.\n    if (!(ref in refVNodes) || refVNodes[ref].key < vnode.key) {\n        refVNodes[ref] = vnode;\n    }\n}\n// Throw an error if we're running in prod mode. Ensures code is truly removed from prod mode.\nfunction assertNotProd() {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n}\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction resolveCircularModuleDependency(fn) {\n    const module = fn();\n    return (module === null || module === void 0 ? void 0 : module.__esModule) ? module.default : module;\n}\nfunction isCircularModuleDependency(obj) {\n    return isFunction$1(obj) && hasOwnProperty$1.call(obj, '__circular__');\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// This is a temporary workaround to get the @lwc/engine-server to evaluate in node without having\n// to inject at runtime.\nconst HTMLElementConstructor = typeof HTMLElement !== 'undefined' ? HTMLElement : function () { };\nconst HTMLElementPrototype = HTMLElementConstructor.prototype;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// These properties get added to LWCElement.prototype publicProps automatically\nconst defaultDefHTMLPropertyNames = [\n    'accessKey',\n    'dir',\n    'draggable',\n    'hidden',\n    'id',\n    'lang',\n    'spellcheck',\n    'tabIndex',\n    'title',\n];\nfunction offsetPropertyErrorMessage(name) {\n    return `Using the \\`${name}\\` property is an anti-pattern because it rounds the value to an integer. Instead, use the \\`getBoundingClientRect\\` method to obtain fractional values for the size of an element and its position relative to the viewport.`;\n}\n// Global HTML Attributes & Properties\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\n//\n// If you update this list, check for test files that recapitulate the same list. Searching the codebase\n// for e.g. \"dropzone\" should suffice.\nconst globalHTMLProperties = {\n    accessKey: {\n        attribute: 'accesskey',\n    },\n    accessKeyLabel: {\n        readOnly: true,\n    },\n    className: {\n        attribute: 'class',\n        error: 'Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead.',\n    },\n    contentEditable: {\n        attribute: 'contenteditable',\n    },\n    dataset: {\n        readOnly: true,\n        error: \"Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead.\",\n    },\n    dir: {\n        attribute: 'dir',\n    },\n    draggable: {\n        attribute: 'draggable',\n    },\n    dropzone: {\n        attribute: 'dropzone',\n        readOnly: true,\n    },\n    hidden: {\n        attribute: 'hidden',\n    },\n    id: {\n        attribute: 'id',\n    },\n    inputMode: {\n        attribute: 'inputmode',\n    },\n    lang: {\n        attribute: 'lang',\n    },\n    slot: {\n        attribute: 'slot',\n        error: 'Using the `slot` property is an anti-pattern.',\n    },\n    spellcheck: {\n        attribute: 'spellcheck',\n    },\n    style: {\n        attribute: 'style',\n    },\n    tabIndex: {\n        attribute: 'tabindex',\n    },\n    title: {\n        attribute: 'title',\n    },\n    translate: {\n        attribute: 'translate',\n    },\n    // additional \"global attributes\" that are not present in the link above.\n    isContentEditable: {\n        readOnly: true,\n    },\n    offsetHeight: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetHeight'),\n    },\n    offsetLeft: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetLeft'),\n    },\n    offsetParent: {\n        readOnly: true,\n    },\n    offsetTop: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetTop'),\n    },\n    offsetWidth: {\n        readOnly: true,\n        error: offsetPropertyErrorMessage('offsetWidth'),\n    },\n    role: {\n        attribute: 'role',\n    },\n};\nlet controlledElement = null;\nlet controlledAttributeName;\nfunction isAttributeLocked(elm, attrName) {\n    return elm !== controlledElement || attrName !== controlledAttributeName;\n}\nfunction lockAttribute(_elm, _key) {\n    controlledElement = null;\n    controlledAttributeName = undefined;\n}\nfunction unlockAttribute(elm, key) {\n    controlledElement = elm;\n    controlledAttributeName = key;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This is a descriptor map that contains\n * all standard properties that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base HTML Element and\n * Base Lightning Element should support.\n */\nconst HTMLElementOriginalDescriptors = create(null);\nforEach.call(keys(AriaPropNameToAttrNameMap), (propName) => {\n    // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n    // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.\n    const descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);\n    if (!isUndefined$1(descriptor)) {\n        HTMLElementOriginalDescriptors[propName] = descriptor;\n    }\n});\nforEach.call(defaultDefHTMLPropertyNames, (propName) => {\n    // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n    // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into\n    // this category, so, better to be sure.\n    const descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);\n    if (!isUndefined$1(descriptor)) {\n        HTMLElementOriginalDescriptors[propName] = descriptor;\n    }\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction generateDataDescriptor(options) {\n    return assign({\n        configurable: true,\n        enumerable: true,\n        writable: true,\n    }, options);\n}\nfunction generateAccessorDescriptor(options) {\n    return assign({\n        configurable: true,\n        enumerable: true,\n    }, options);\n}\nlet isDomMutationAllowed = false;\nfunction unlockDomMutation() {\n    assertNotProd(); // this method should never leak to prod\n    isDomMutationAllowed = true;\n}\nfunction lockDomMutation() {\n    assertNotProd(); // this method should never leak to prod\n    isDomMutationAllowed = false;\n}\nfunction logMissingPortalError(name, type) {\n    return logError(`The \\`${name}\\` ${type} is available only on elements that use the \\`lwc:dom=\"manual\"\\` directive.`);\n}\nfunction patchElementWithRestrictions(elm, options) {\n    assertNotProd(); // this method should never leak to prod\n    const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n    const descriptors = {\n        outerHTML: generateAccessorDescriptor({\n            get() {\n                return originalOuterHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set outerHTML on Element.`);\n            },\n        }),\n    };\n    // Apply extra restriction related to DOM manipulation if the element is not a portal.\n    if (!options.isLight && options.isSynthetic && !options.isPortal) {\n        const { appendChild, insertBefore, removeChild, replaceChild } = elm;\n        const originalNodeValueDescriptor = getPropertyDescriptor(elm, 'nodeValue');\n        const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n        const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');\n        assign(descriptors, {\n            appendChild: generateDataDescriptor({\n                value(aChild) {\n                    logMissingPortalError('appendChild', 'method');\n                    return appendChild.call(this, aChild);\n                },\n            }),\n            insertBefore: generateDataDescriptor({\n                value(newNode, referenceNode) {\n                    if (!isDomMutationAllowed) {\n                        logMissingPortalError('insertBefore', 'method');\n                    }\n                    return insertBefore.call(this, newNode, referenceNode);\n                },\n            }),\n            removeChild: generateDataDescriptor({\n                value(aChild) {\n                    if (!isDomMutationAllowed) {\n                        logMissingPortalError('removeChild', 'method');\n                    }\n                    return removeChild.call(this, aChild);\n                },\n            }),\n            replaceChild: generateDataDescriptor({\n                value(newChild, oldChild) {\n                    logMissingPortalError('replaceChild', 'method');\n                    return replaceChild.call(this, newChild, oldChild);\n                },\n            }),\n            nodeValue: generateAccessorDescriptor({\n                get() {\n                    return originalNodeValueDescriptor.get.call(this);\n                },\n                set(value) {\n                    if (!isDomMutationAllowed) {\n                        logMissingPortalError('nodeValue', 'property');\n                    }\n                    originalNodeValueDescriptor.set.call(this, value);\n                },\n            }),\n            textContent: generateAccessorDescriptor({\n                get() {\n                    return originalTextContentDescriptor.get.call(this);\n                },\n                set(value) {\n                    logMissingPortalError('textContent', 'property');\n                    originalTextContentDescriptor.set.call(this, value);\n                },\n            }),\n            innerHTML: generateAccessorDescriptor({\n                get() {\n                    return originalInnerHTMLDescriptor.get.call(this);\n                },\n                set(value) {\n                    logMissingPortalError('innerHTML', 'property');\n                    return originalInnerHTMLDescriptor.set.call(this, value);\n                },\n            }),\n        });\n    }\n    defineProperties(elm, descriptors);\n}\nfunction getShadowRootRestrictionsDescriptors(sr) {\n    assertNotProd(); // this method should never leak to prod\n    // Disallowing properties in dev mode only to avoid people doing the wrong\n    // thing when using the real shadow root, because if that's the case,\n    // the component will not work when running with synthetic shadow.\n    const originalAddEventListener = sr.addEventListener;\n    const originalInnerHTMLDescriptor = getPropertyDescriptor(sr, 'innerHTML');\n    const originalTextContentDescriptor = getPropertyDescriptor(sr, 'textContent');\n    return {\n        innerHTML: generateAccessorDescriptor({\n            get() {\n                return originalInnerHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set innerHTML on ShadowRoot.`);\n            },\n        }),\n        textContent: generateAccessorDescriptor({\n            get() {\n                return originalTextContentDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set textContent on ShadowRoot.`);\n            },\n        }),\n        addEventListener: generateDataDescriptor({\n            value(type, listener, options) {\n                // TODO [#420]: this is triggered when the component author attempts to add a listener\n                // programmatically into its Component's shadow root\n                if (!isUndefined$1(options)) {\n                    logError('The `addEventListener` method on ShadowRoot does not support any options.', getAssociatedVMIfPresent(this));\n                }\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                return originalAddEventListener.apply(this, arguments);\n            },\n        }),\n    };\n}\n// Custom Elements Restrictions:\n// -----------------------------\nfunction getCustomElementRestrictionsDescriptors(elm) {\n    assertNotProd(); // this method should never leak to prod\n    const originalAddEventListener = elm.addEventListener;\n    const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n    const originalOuterHTMLDescriptor = getPropertyDescriptor(elm, 'outerHTML');\n    const originalTextContentDescriptor = getPropertyDescriptor(elm, 'textContent');\n    return {\n        innerHTML: generateAccessorDescriptor({\n            get() {\n                return originalInnerHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set innerHTML on HTMLElement.`);\n            },\n        }),\n        outerHTML: generateAccessorDescriptor({\n            get() {\n                return originalOuterHTMLDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set outerHTML on HTMLElement.`);\n            },\n        }),\n        textContent: generateAccessorDescriptor({\n            get() {\n                return originalTextContentDescriptor.get.call(this);\n            },\n            set(_value) {\n                throw new TypeError(`Invalid attempt to set textContent on HTMLElement.`);\n            },\n        }),\n        addEventListener: generateDataDescriptor({\n            value(type, listener, options) {\n                // TODO [#420]: this is triggered when the component author attempts to add a listener\n                // programmatically into a lighting element node\n                if (!isUndefined$1(options)) {\n                    logError('The `addEventListener` method in `LightningElement` does not support any options.', getAssociatedVMIfPresent(this));\n                }\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                return originalAddEventListener.apply(this, arguments);\n            },\n        }),\n    };\n}\nfunction getComponentRestrictionsDescriptors() {\n    assertNotProd(); // this method should never leak to prod\n    return {\n        tagName: generateAccessorDescriptor({\n            get() {\n                throw new Error(`Usage of property \\`tagName\\` is disallowed because the component itself does` +\n                    ` not know which tagName will be used to create the element, therefore writing` +\n                    ` code that check for that value is error prone.`);\n            },\n            configurable: true,\n            enumerable: false, // no enumerable properties on component\n        }),\n    };\n}\nfunction getLightningElementPrototypeRestrictionsDescriptors(proto) {\n    assertNotProd(); // this method should never leak to prod\n    const originalDispatchEvent = proto.dispatchEvent;\n    const descriptors = {\n        dispatchEvent: generateDataDescriptor({\n            value(event) {\n                const vm = getAssociatedVM(this);\n                if (!isNull(event) && isObject(event)) {\n                    const { type } = event;\n                    if (!/^[a-z][a-z0-9_]*$/.test(type)) {\n                        logError(`Invalid event type \"${type}\" dispatched in element ${getComponentTag(vm)}.` +\n                            ` Event name must start with a lowercase letter and followed only lowercase` +\n                            ` letters, numbers, and underscores`, vm);\n                    }\n                }\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                return originalDispatchEvent.apply(this, arguments);\n            },\n        }),\n    };\n    forEach.call(getOwnPropertyNames$1(globalHTMLProperties), (propName) => {\n        if (propName in proto) {\n            return; // no need to redefine something that we are already exposing\n        }\n        descriptors[propName] = generateAccessorDescriptor({\n            get() {\n                const { error, attribute } = globalHTMLProperties[propName];\n                const msg = [];\n                msg.push(`Accessing the global HTML property \"${propName}\" is disabled.`);\n                if (error) {\n                    msg.push(error);\n                }\n                else if (attribute) {\n                    msg.push(`Instead access it via \\`this.getAttribute(\"${attribute}\")\\`.`);\n                }\n                logError(msg.join('\\n'), getAssociatedVM(this));\n            },\n            set() {\n                const { readOnly } = globalHTMLProperties[propName];\n                if (readOnly) {\n                    logError(`The global HTML property \\`${propName}\\` is read-only.`, getAssociatedVM(this));\n                }\n            },\n        });\n    });\n    return descriptors;\n}\n// This routine will prevent access to certain properties on a shadow root instance to guarantee\n// that all components will work fine in IE11 and other browsers without shadow dom support.\nfunction patchShadowRootWithRestrictions(sr) {\n    defineProperties(sr, getShadowRootRestrictionsDescriptors(sr));\n}\nfunction patchCustomElementWithRestrictions(elm) {\n    const restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm);\n    const elmProto = getPrototypeOf$1(elm);\n    setPrototypeOf(elm, create(elmProto, restrictionsDescriptors));\n}\nfunction patchComponentWithRestrictions(cmp) {\n    defineProperties(cmp, getComponentRestrictionsDescriptors());\n}\nfunction patchLightningElementPrototypeWithRestrictions(proto) {\n    defineProperties(proto, getLightningElementPrototypeRestrictionsDescriptors(proto));\n}\n\nfunction updateComponentValue(vm, key, newValue) {\n    const { cmpFields } = vm;\n    if (newValue !== cmpFields[key]) {\n        cmpFields[key] = newValue;\n        componentValueMutated(vm, key);\n    }\n}\n\n/**\n * Copyright (C) 2017 salesforce.com, inc.\n */\nconst { isArray } = Array;\nconst { prototype: ObjectDotPrototype, getPrototypeOf, create: ObjectCreate, defineProperty: ObjectDefineProperty, isExtensible, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, preventExtensions, hasOwnProperty, } = Object;\nconst { push: ArrayPush, concat: ArrayConcat } = Array.prototype;\nconst OtS = {}.toString;\nfunction toString(obj) {\n    if (obj && obj.toString) {\n        return obj.toString();\n    }\n    else if (typeof obj === 'object') {\n        return OtS.call(obj);\n    }\n    else {\n        return obj + '';\n    }\n}\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\nconst proxyToValueMap = new WeakMap();\nfunction registerProxy(proxy, value) {\n    proxyToValueMap.set(proxy, value);\n}\nconst unwrap$1 = (replicaOrAny) => proxyToValueMap.get(replicaOrAny) || replicaOrAny;\n\nclass BaseProxyHandler {\n    constructor(membrane, value) {\n        this.originalTarget = value;\n        this.membrane = membrane;\n    }\n    // Shared utility methods\n    wrapDescriptor(descriptor) {\n        if (hasOwnProperty.call(descriptor, 'value')) {\n            descriptor.value = this.wrapValue(descriptor.value);\n        }\n        else {\n            const { set: originalSet, get: originalGet } = descriptor;\n            if (!isUndefined(originalGet)) {\n                descriptor.get = this.wrapGetter(originalGet);\n            }\n            if (!isUndefined(originalSet)) {\n                descriptor.set = this.wrapSetter(originalSet);\n            }\n        }\n        return descriptor;\n    }\n    copyDescriptorIntoShadowTarget(shadowTarget, key) {\n        const { originalTarget } = this;\n        // Note: a property might get defined multiple times in the shadowTarget\n        //       but it will always be compatible with the previous descriptor\n        //       to preserve the object invariants, which makes these lines safe.\n        const originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);\n        // TODO: it should be impossible for the originalDescriptor to ever be undefined, this `if` can be removed\n        /* istanbul ignore else */\n        if (!isUndefined(originalDescriptor)) {\n            const wrappedDesc = this.wrapDescriptor(originalDescriptor);\n            ObjectDefineProperty(shadowTarget, key, wrappedDesc);\n        }\n    }\n    lockShadowTarget(shadowTarget) {\n        const { originalTarget } = this;\n        const targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));\n        targetKeys.forEach((key) => {\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        });\n        const { membrane: { tagPropertyKey }, } = this;\n        if (!isUndefined(tagPropertyKey) && !hasOwnProperty.call(shadowTarget, tagPropertyKey)) {\n            ObjectDefineProperty(shadowTarget, tagPropertyKey, ObjectCreate(null));\n        }\n        preventExtensions(shadowTarget);\n    }\n    // Shared Traps\n    // TODO: apply() is never called\n    /* istanbul ignore next */\n    apply(shadowTarget, thisArg, argArray) {\n        /* No op */\n    }\n    // TODO: construct() is never called\n    /* istanbul ignore next */\n    construct(shadowTarget, argArray, newTarget) {\n        /* No op */\n    }\n    get(shadowTarget, key) {\n        const { originalTarget, membrane: { valueObserved }, } = this;\n        const value = originalTarget[key];\n        valueObserved(originalTarget, key);\n        return this.wrapValue(value);\n    }\n    has(shadowTarget, key) {\n        const { originalTarget, membrane: { tagPropertyKey, valueObserved }, } = this;\n        valueObserved(originalTarget, key);\n        // since key is never going to be undefined, and tagPropertyKey might be undefined\n        // we can simply compare them as the second part of the condition.\n        return key in originalTarget || key === tagPropertyKey;\n    }\n    ownKeys(shadowTarget) {\n        const { originalTarget, membrane: { tagPropertyKey }, } = this;\n        // if the membrane tag key exists and it is not in the original target, we add it to the keys.\n        const keys = isUndefined(tagPropertyKey) || hasOwnProperty.call(originalTarget, tagPropertyKey)\n            ? []\n            : [tagPropertyKey];\n        // small perf optimization using push instead of concat to avoid creating an extra array\n        ArrayPush.apply(keys, getOwnPropertyNames(originalTarget));\n        ArrayPush.apply(keys, getOwnPropertySymbols(originalTarget));\n        return keys;\n    }\n    isExtensible(shadowTarget) {\n        const { originalTarget } = this;\n        // optimization to avoid attempting to lock down the shadowTarget multiple times\n        if (!isExtensible(shadowTarget)) {\n            return false; // was already locked down\n        }\n        if (!isExtensible(originalTarget)) {\n            this.lockShadowTarget(shadowTarget);\n            return false;\n        }\n        return true;\n    }\n    getPrototypeOf(shadowTarget) {\n        const { originalTarget } = this;\n        return getPrototypeOf(originalTarget);\n    }\n    getOwnPropertyDescriptor(shadowTarget, key) {\n        const { originalTarget, membrane: { valueObserved, tagPropertyKey }, } = this;\n        // keys looked up via getOwnPropertyDescriptor need to be reactive\n        valueObserved(originalTarget, key);\n        let desc = getOwnPropertyDescriptor(originalTarget, key);\n        if (isUndefined(desc)) {\n            if (key !== tagPropertyKey) {\n                return undefined;\n            }\n            // if the key is the membrane tag key, and is not in the original target,\n            // we produce a synthetic descriptor and install it on the shadow target\n            desc = { value: undefined, writable: false, configurable: false, enumerable: false };\n            ObjectDefineProperty(shadowTarget, tagPropertyKey, desc);\n            return desc;\n        }\n        if (desc.configurable === false) {\n            // updating the descriptor to non-configurable on the shadow\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        }\n        // Note: by accessing the descriptor, the key is marked as observed\n        // but access to the value, setter or getter (if available) cannot observe\n        // mutations, just like regular methods, in which case we just do nothing.\n        return this.wrapDescriptor(desc);\n    }\n}\n\nconst getterMap$1 = new WeakMap();\nconst setterMap$1 = new WeakMap();\nconst reverseGetterMap = new WeakMap();\nconst reverseSetterMap = new WeakMap();\nclass ReactiveProxyHandler extends BaseProxyHandler {\n    wrapValue(value) {\n        return this.membrane.getProxy(value);\n    }\n    wrapGetter(originalGet) {\n        const wrappedGetter = getterMap$1.get(originalGet);\n        if (!isUndefined(wrappedGetter)) {\n            return wrappedGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the original getter with the original target\n            return handler.wrapValue(originalGet.call(unwrap$1(this)));\n        };\n        getterMap$1.set(originalGet, get);\n        reverseGetterMap.set(get, originalGet);\n        return get;\n    }\n    wrapSetter(originalSet) {\n        const wrappedSetter = setterMap$1.get(originalSet);\n        if (!isUndefined(wrappedSetter)) {\n            return wrappedSetter;\n        }\n        const set = function (v) {\n            // invoking the original setter with the original target\n            originalSet.call(unwrap$1(this), unwrap$1(v));\n        };\n        setterMap$1.set(originalSet, set);\n        reverseSetterMap.set(set, originalSet);\n        return set;\n    }\n    unwrapDescriptor(descriptor) {\n        if (hasOwnProperty.call(descriptor, 'value')) {\n            // dealing with a data descriptor\n            descriptor.value = unwrap$1(descriptor.value);\n        }\n        else {\n            const { set, get } = descriptor;\n            if (!isUndefined(get)) {\n                descriptor.get = this.unwrapGetter(get);\n            }\n            if (!isUndefined(set)) {\n                descriptor.set = this.unwrapSetter(set);\n            }\n        }\n        return descriptor;\n    }\n    unwrapGetter(redGet) {\n        const reverseGetter = reverseGetterMap.get(redGet);\n        if (!isUndefined(reverseGetter)) {\n            return reverseGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the red getter with the proxy of this\n            return unwrap$1(redGet.call(handler.wrapValue(this)));\n        };\n        getterMap$1.set(get, redGet);\n        reverseGetterMap.set(redGet, get);\n        return get;\n    }\n    unwrapSetter(redSet) {\n        const reverseSetter = reverseSetterMap.get(redSet);\n        if (!isUndefined(reverseSetter)) {\n            return reverseSetter;\n        }\n        const handler = this;\n        const set = function (v) {\n            // invoking the red setter with the proxy of this\n            redSet.call(handler.wrapValue(this), handler.wrapValue(v));\n        };\n        setterMap$1.set(set, redSet);\n        reverseSetterMap.set(redSet, set);\n        return set;\n    }\n    set(shadowTarget, key, value) {\n        const { originalTarget, membrane: { valueMutated }, } = this;\n        const oldValue = originalTarget[key];\n        if (oldValue !== value) {\n            originalTarget[key] = value;\n            valueMutated(originalTarget, key);\n        }\n        else if (key === 'length' && isArray(originalTarget)) {\n            // fix for issue #236: push will add the new index, and by the time length\n            // is updated, the internal length is already equal to the new length value\n            // therefore, the oldValue is equal to the value. This is the forking logic\n            // to support this use case.\n            valueMutated(originalTarget, key);\n        }\n        return true;\n    }\n    deleteProperty(shadowTarget, key) {\n        const { originalTarget, membrane: { valueMutated }, } = this;\n        delete originalTarget[key];\n        valueMutated(originalTarget, key);\n        return true;\n    }\n    setPrototypeOf(shadowTarget, prototype) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${toString(this.originalTarget)}. Prototype of reactive objects cannot be changed.`);\n        }\n    }\n    preventExtensions(shadowTarget) {\n        if (isExtensible(shadowTarget)) {\n            const { originalTarget } = this;\n            preventExtensions(originalTarget);\n            // if the originalTarget is a proxy itself, it might reject\n            // the preventExtension call, in which case we should not attempt to lock down\n            // the shadow target.\n            // TODO: It should not actually be possible to reach this `if` statement.\n            // If a proxy rejects extensions, then calling preventExtensions will throw an error:\n            // https://codepen.io/nolanlawson-the-selector/pen/QWMOjbY\n            /* istanbul ignore if */\n            if (isExtensible(originalTarget)) {\n                return false;\n            }\n            this.lockShadowTarget(shadowTarget);\n        }\n        return true;\n    }\n    defineProperty(shadowTarget, key, descriptor) {\n        const { originalTarget, membrane: { valueMutated, tagPropertyKey }, } = this;\n        if (key === tagPropertyKey && !hasOwnProperty.call(originalTarget, key)) {\n            // To avoid leaking the membrane tag property into the original target, we must\n            // be sure that the original target doesn't have yet.\n            // NOTE: we do not return false here because Object.freeze and equivalent operations\n            // will attempt to set the descriptor to the same value, and expect no to throw. This\n            // is an small compromise for the sake of not having to diff the descriptors.\n            return true;\n        }\n        ObjectDefineProperty(originalTarget, key, this.unwrapDescriptor(descriptor));\n        // intentionally testing if false since it could be undefined as well\n        if (descriptor.configurable === false) {\n            this.copyDescriptorIntoShadowTarget(shadowTarget, key);\n        }\n        valueMutated(originalTarget, key);\n        return true;\n    }\n}\n\nconst getterMap = new WeakMap();\nconst setterMap = new WeakMap();\nclass ReadOnlyHandler extends BaseProxyHandler {\n    wrapValue(value) {\n        return this.membrane.getReadOnlyProxy(value);\n    }\n    wrapGetter(originalGet) {\n        const wrappedGetter = getterMap.get(originalGet);\n        if (!isUndefined(wrappedGetter)) {\n            return wrappedGetter;\n        }\n        const handler = this;\n        const get = function () {\n            // invoking the original getter with the original target\n            return handler.wrapValue(originalGet.call(unwrap$1(this)));\n        };\n        getterMap.set(originalGet, get);\n        return get;\n    }\n    wrapSetter(originalSet) {\n        const wrappedSetter = setterMap.get(originalSet);\n        if (!isUndefined(wrappedSetter)) {\n            return wrappedSetter;\n        }\n        const handler = this;\n        const set = function (v) {\n            /* istanbul ignore else */\n            if (process.env.NODE_ENV !== 'production') {\n                const { originalTarget } = handler;\n                throw new Error(`Invalid mutation: Cannot invoke a setter on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n            }\n        };\n        setterMap.set(originalSet, set);\n        return set;\n    }\n    set(shadowTarget, key, value) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            const { originalTarget } = this;\n            const msg = isArray(originalTarget)\n                ? `Invalid mutation: Cannot mutate array at index ${key.toString()}. Array is read-only.`\n                : `Invalid mutation: Cannot set \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`;\n            throw new Error(msg);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n    deleteProperty(shadowTarget, key) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot delete \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n    setPrototypeOf(shadowTarget, prototype) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            const { originalTarget } = this;\n            throw new Error(`Invalid prototype mutation: Cannot set prototype on \"${originalTarget}\". \"${originalTarget}\" prototype is read-only.`);\n        }\n    }\n    preventExtensions(shadowTarget) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot preventExtensions on ${originalTarget}\". \"${originalTarget} is read-only.`);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n    defineProperty(shadowTarget, key, descriptor) {\n        /* istanbul ignore else */\n        if (process.env.NODE_ENV !== 'production') {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot defineProperty \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n        }\n        /* istanbul ignore next */\n        return false;\n    }\n}\n\nfunction extract(objectOrArray) {\n    if (isArray(objectOrArray)) {\n        return objectOrArray.map((item) => {\n            const original = unwrap$1(item);\n            if (original !== item) {\n                return extract(original);\n            }\n            return item;\n        });\n    }\n    const obj = ObjectCreate(getPrototypeOf(objectOrArray));\n    const names = getOwnPropertyNames(objectOrArray);\n    return ArrayConcat.call(names, getOwnPropertySymbols(objectOrArray)).reduce((seed, key) => {\n        const item = objectOrArray[key];\n        const original = unwrap$1(item);\n        if (original !== item) {\n            seed[key] = extract(original);\n        }\n        else {\n            seed[key] = item;\n        }\n        return seed;\n    }, obj);\n}\nconst formatter = {\n    header: (plainOrProxy) => {\n        const originalTarget = unwrap$1(plainOrProxy);\n        // if originalTarget is falsy or not unwrappable, exit\n        if (!originalTarget || originalTarget === plainOrProxy) {\n            return null;\n        }\n        const obj = extract(plainOrProxy);\n        return ['object', { object: obj }];\n    },\n    hasBody: () => {\n        return false;\n    },\n    body: () => {\n        return null;\n    },\n};\n// Inspired from paulmillr/es6-shim\n// https://github.com/paulmillr/es6-shim/blob/master/es6-shim.js#L176-L185\n/* istanbul ignore next */\nfunction getGlobal() {\n    // the only reliable means to get the global object is `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof globalThis !== 'undefined') {\n        return globalThis;\n    }\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    // Gracefully degrade if not able to locate the global object\n    return {};\n}\nfunction init$1() {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV === 'production') {\n        // this method should never leak to prod\n        throw new ReferenceError();\n    }\n    const global = getGlobal();\n    // Custom Formatter for Dev Tools. To enable this, open Chrome Dev Tools\n    //  - Go to Settings,\n    //  - Under console, select \"Enable custom formatters\"\n    // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview\n    const devtoolsFormatters = global.devtoolsFormatters || [];\n    ArrayPush.call(devtoolsFormatters, formatter);\n    global.devtoolsFormatters = devtoolsFormatters;\n}\n\n/* istanbul ignore else */\nif (process.env.NODE_ENV !== 'production') {\n    init$1();\n}\nfunction defaultValueIsObservable(value) {\n    // intentionally checking for null\n    if (value === null) {\n        return false;\n    }\n    // treat all non-object types, including undefined, as non-observable values\n    if (typeof value !== 'object') {\n        return false;\n    }\n    if (isArray(value)) {\n        return true;\n    }\n    const proto = getPrototypeOf(value);\n    return proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null;\n}\nconst defaultValueObserved = (obj, key) => {\n    /* do nothing */\n};\nconst defaultValueMutated = (obj, key) => {\n    /* do nothing */\n};\nfunction createShadowTarget(value) {\n    return isArray(value) ? [] : {};\n}\nclass ObservableMembrane {\n    constructor(options = {}) {\n        this.readOnlyObjectGraph = new WeakMap();\n        this.reactiveObjectGraph = new WeakMap();\n        const { valueMutated, valueObserved, valueIsObservable, tagPropertyKey } = options;\n        this.valueMutated = isFunction(valueMutated) ? valueMutated : defaultValueMutated;\n        this.valueObserved = isFunction(valueObserved) ? valueObserved : defaultValueObserved;\n        this.valueIsObservable = isFunction(valueIsObservable)\n            ? valueIsObservable\n            : defaultValueIsObservable;\n        this.tagPropertyKey = tagPropertyKey;\n    }\n    getProxy(value) {\n        const unwrappedValue = unwrap$1(value);\n        if (this.valueIsObservable(unwrappedValue)) {\n            // When trying to extract the writable version of a readonly we return the readonly.\n            if (this.readOnlyObjectGraph.get(unwrappedValue) === value) {\n                return value;\n            }\n            return this.getReactiveHandler(unwrappedValue);\n        }\n        return unwrappedValue;\n    }\n    getReadOnlyProxy(value) {\n        value = unwrap$1(value);\n        if (this.valueIsObservable(value)) {\n            return this.getReadOnlyHandler(value);\n        }\n        return value;\n    }\n    unwrapProxy(p) {\n        return unwrap$1(p);\n    }\n    getReactiveHandler(value) {\n        let proxy = this.reactiveObjectGraph.get(value);\n        if (isUndefined(proxy)) {\n            // caching the proxy after the first time it is accessed\n            const handler = new ReactiveProxyHandler(this, value);\n            proxy = new Proxy(createShadowTarget(value), handler);\n            registerProxy(proxy, value);\n            this.reactiveObjectGraph.set(value, proxy);\n        }\n        return proxy;\n    }\n    getReadOnlyHandler(value) {\n        let proxy = this.readOnlyObjectGraph.get(value);\n        if (isUndefined(proxy)) {\n            // caching the proxy after the first time it is accessed\n            const handler = new ReadOnlyHandler(this, value);\n            proxy = new Proxy(createShadowTarget(value), handler);\n            registerProxy(proxy, value);\n            this.readOnlyObjectGraph.set(value, proxy);\n        }\n        return proxy;\n    }\n}\n/** version: 2.0.0 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst lockerLivePropertyKey = Symbol.for('@@lockerLiveValue');\nconst reactiveMembrane = new ObservableMembrane({\n    valueObserved,\n    valueMutated,\n    tagPropertyKey: lockerLivePropertyKey,\n});\n/**\n * EXPERIMENTAL: This function implements an unwrap mechanism that\n * works for observable membrane objects. This API is subject to\n * change or being removed.\n */\nfunction unwrap(value) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    return reactiveMembrane.unwrapProxy(value) ;\n}\nfunction getReadOnlyProxy(value) {\n    // We must return a frozen wrapper around the value, so that child components cannot mutate properties passed to\n    // them from their parents. This applies to both the client and server.\n    return reactiveMembrane.getReadOnlyProxy(value);\n}\nfunction getReactiveProxy(value) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    return reactiveMembrane.getProxy(value) ;\n}\n// Making the component instance a live value when using Locker to support expandos.\nfunction markLockerLiveObject(obj) {\n    // On the server side, we don't need mutation tracking. Skipping it improves performance.\n    {\n        obj[lockerLivePropertyKey] = undefined;\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This operation is called with a descriptor of an standard html property\n * that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors\n * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.\n */\nfunction createBridgeToElementDescriptor(propName, descriptor) {\n    const { get, set, enumerable, configurable } = descriptor;\n    if (!isFunction$1(get)) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard getter.`);\n        }\n        throw new TypeError();\n    }\n    if (!isFunction$1(set)) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard setter.`);\n        }\n        throw new TypeError();\n    }\n    return {\n        enumerable,\n        configurable,\n        get() {\n            const vm = getAssociatedVM(this);\n            if (isBeingConstructed(vm)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logError(`The value of property \\`${propName}\\` can't be read from the constructor because the owner component hasn't set the value yet. Instead, use the constructor to set a default value for the property.`, vm);\n                }\n                return;\n            }\n            componentValueObserved(vm, propName);\n            return get.call(vm.elm);\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                const vmBeingRendered = getVMBeingRendered();\n                assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);\n                assert.invariant(!isUpdatingTemplate, `When updating the template of ${vmBeingRendered}, one of the accessors used by the template has side effects on the state of ${vm}.${propName}`);\n                assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n                assert.invariant(!isObject(newValue) || isNull(newValue), `Invalid value \"${newValue}\" for \"${propName}\" of ${vm}. Value cannot be an object, must be a primitive value.`);\n            }\n            updateComponentValue(vm, propName, newValue);\n            return set.call(vm.elm, newValue);\n        },\n    };\n}\nconst refsCache = new WeakMap();\n/**\n * This class is the base class for any LWC element.\n * Some elements directly extends this class, others implement it via inheritance.\n **/\n// @ts-ignore\nconst LightningElement = function () {\n    // This should be as performant as possible, while any initialization should be done lazily\n    if (isNull(vmBeingConstructed)) {\n        // Thrown when doing something like `new LightningElement()` or\n        // `class Foo extends LightningElement {}; new Foo()`\n        throw new TypeError('Illegal constructor');\n    }\n    const vm = vmBeingConstructed;\n    const { def, elm } = vm;\n    const { bridge } = def;\n    if (process.env.NODE_ENV !== 'production') {\n        const { assertInstanceOfHTMLElement } = vm.renderer;\n        assertInstanceOfHTMLElement(vm.elm, `Component creation requires a DOM element to be associated to ${vm}.`);\n    }\n    const component = this;\n    setPrototypeOf(elm, bridge.prototype);\n    vm.component = this;\n    // Locker hooks assignment. When the LWC engine run with Locker, Locker intercepts all the new\n    // component creation and passes hooks to instrument all the component interactions with the\n    // engine. We are intentionally hiding this argument from the formal API of LightningElement\n    // because we don't want folks to know about it just yet.\n    if (arguments.length === 1) {\n        const { callHook, setHook, getHook } = arguments[0];\n        vm.callHook = callHook;\n        vm.setHook = setHook;\n        vm.getHook = getHook;\n    }\n    markLockerLiveObject(this);\n    // Linking elm, shadow root and component with the VM.\n    associateVM(component, vm);\n    associateVM(elm, vm);\n    if (vm.renderMode === 1 /* RenderMode.Shadow */) {\n        vm.renderRoot = doAttachShadow(vm);\n    }\n    else {\n        vm.renderRoot = elm;\n    }\n    // Adding extra guard rails in DEV mode.\n    if (process.env.NODE_ENV !== 'production') {\n        patchCustomElementWithRestrictions(elm);\n        patchComponentWithRestrictions(component);\n    }\n    return this;\n};\nfunction doAttachShadow(vm) {\n    const { elm, mode, shadowMode, def: { ctor }, renderer: { attachShadow }, } = vm;\n    const shadowRoot = attachShadow(elm, {\n        [KEY__SYNTHETIC_MODE]: shadowMode === 1 /* ShadowMode.Synthetic */,\n        delegatesFocus: Boolean(ctor.delegatesFocus),\n        mode,\n    });\n    vm.shadowRoot = shadowRoot;\n    associateVM(shadowRoot, vm);\n    if (process.env.NODE_ENV !== 'production') {\n        patchShadowRootWithRestrictions(shadowRoot);\n    }\n    return shadowRoot;\n}\nfunction warnIfInvokedDuringConstruction(vm, methodOrPropName) {\n    if (isBeingConstructed(vm)) {\n        logError(`this.${methodOrPropName} should not be called during the construction of the custom element for ${getComponentTag(vm)} because the element is not yet in the DOM or has no children yet.`);\n    }\n}\n// @ts-ignore\nLightningElement.prototype = {\n    constructor: LightningElement,\n    dispatchEvent(event) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { dispatchEvent }, } = vm;\n        return dispatchEvent(elm, event);\n    },\n    addEventListener(type, listener, options) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { addEventListener }, } = vm;\n        if (process.env.NODE_ENV !== 'production') {\n            const vmBeingRendered = getVMBeingRendered();\n            assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n            assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n            assert.invariant(isFunction$1(listener), `Invalid second argument for this.addEventListener() in ${vm} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n        }\n        const wrappedListener = getWrappedComponentsListener(vm, listener);\n        addEventListener(elm, type, wrappedListener, options);\n    },\n    removeEventListener(type, listener, options) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { removeEventListener }, } = vm;\n        const wrappedListener = getWrappedComponentsListener(vm, listener);\n        removeEventListener(elm, type, wrappedListener, options);\n    },\n    hasAttribute(name) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getAttribute }, } = vm;\n        return !isNull(getAttribute(elm, name));\n    },\n    hasAttributeNS(namespace, name) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getAttribute }, } = vm;\n        return !isNull(getAttribute(elm, name, namespace));\n    },\n    removeAttribute(name) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { removeAttribute }, } = vm;\n        unlockAttribute(elm, name);\n        removeAttribute(elm, name);\n        lockAttribute();\n    },\n    removeAttributeNS(namespace, name) {\n        const { elm, renderer: { removeAttribute }, } = getAssociatedVM(this);\n        unlockAttribute(elm, name);\n        removeAttribute(elm, name, namespace);\n        lockAttribute();\n    },\n    getAttribute(name) {\n        const vm = getAssociatedVM(this);\n        const { elm } = vm;\n        const { getAttribute } = vm.renderer;\n        return getAttribute(elm, name);\n    },\n    getAttributeNS(namespace, name) {\n        const vm = getAssociatedVM(this);\n        const { elm } = vm;\n        const { getAttribute } = vm.renderer;\n        return getAttribute(elm, name, namespace);\n    },\n    setAttribute(name, value) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { setAttribute }, } = vm;\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n        }\n        unlockAttribute(elm, name);\n        setAttribute(elm, name, value);\n        lockAttribute();\n    },\n    setAttributeNS(namespace, name, value) {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { setAttribute }, } = vm;\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentTag(vm)}': The result must not have attributes.`);\n        }\n        unlockAttribute(elm, name);\n        setAttribute(elm, name, value, namespace);\n        lockAttribute();\n    },\n    getBoundingClientRect() {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getBoundingClientRect }, } = vm;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'getBoundingClientRect()');\n        }\n        return getBoundingClientRect(elm);\n    },\n    get isConnected() {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { isConnected }, } = vm;\n        return isConnected(elm);\n    },\n    get classList() {\n        const vm = getAssociatedVM(this);\n        const { elm, renderer: { getClassList }, } = vm;\n        if (process.env.NODE_ENV !== 'production') {\n            // TODO [#1290]: this still fails in dev but works in production, eventually, we should\n            // just throw in all modes\n            assert.isFalse(isBeingConstructed(vm), `Failed to construct ${vm}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`);\n        }\n        return getClassList(elm);\n    },\n    get template() {\n        const vm = getAssociatedVM(this);\n        if (process.env.NODE_ENV !== 'production') {\n            if (vm.renderMode === 0 /* RenderMode.Light */) {\n                logError('`this.template` returns null for light DOM components. Since there is no shadow, the rendered content can be accessed via `this` itself. e.g. instead of `this.template.querySelector`, use `this.querySelector`.');\n            }\n        }\n        return vm.shadowRoot;\n    },\n    get refs() {\n        const vm = getAssociatedVM(this);\n        if (isUpdatingTemplate) {\n            if (process.env.NODE_ENV !== 'production') {\n                logError(`this.refs should not be called while ${getComponentTag(vm)} is rendering. Use this.refs only when the DOM is stable, e.g. in renderedCallback().`);\n            }\n            // If the template is in the process of being updated, then we don't want to go through the normal\n            // process of returning the refs and caching them, because the state of the refs is unstable.\n            // This can happen if e.g. a template contains `<div class={foo}></div>` and `foo` is computed\n            // based on `this.refs.bar`.\n            return;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'refs');\n        }\n        const { refVNodes, cmpTemplate } = vm;\n        // If the `cmpTemplate` is null, that means that the template has not been rendered yet. Most likely this occurs\n        // if `this.refs` is called during the `connectedCallback` phase. The DOM elements have not been rendered yet,\n        // so log a warning. Note we also check `isBeingConstructed()` to avoid a double warning (due to\n        // `warnIfInvokedDuringConstruction` above).\n        if (process.env.NODE_ENV !== 'production' &&\n            isNull(cmpTemplate) &&\n            !isBeingConstructed(vm)) {\n            logError(`this.refs is undefined for ${getComponentTag(vm)}. This is either because the attached template has no \"lwc:ref\" directive, or this.refs was ` +\n                `invoked before renderedCallback(). Use this.refs only when the referenced HTML elements have ` +\n                `been rendered to the DOM, such as within renderedCallback() or disconnectedCallback().`);\n        }\n        // For backwards compatibility with component written before template refs\n        // were introduced, we return undefined if the template has no refs defined\n        // anywhere. This fixes components that may want to add an expando called `refs`\n        // and are checking if it exists with `if (this.refs)`  before adding it.\n        // Note we use a null refVNodes to indicate that the template has no refs defined.\n        if (isNull(refVNodes)) {\n            return;\n        }\n        // The refNodes can be cached based on the refVNodes, since the refVNodes\n        // are recreated from scratch every time the template is rendered.\n        // This happens with `vm.refVNodes = null` in `template.ts` in `@lwc/engine-core`.\n        let refs = refsCache.get(refVNodes);\n        if (isUndefined$1(refs)) {\n            refs = create(null);\n            for (const key of keys(refVNodes)) {\n                refs[key] = refVNodes[key].elm;\n            }\n            freeze(refs);\n            refsCache.set(refVNodes, refs);\n        }\n        return refs;\n    },\n    // For backwards compat, we allow component authors to set `refs` as an expando\n    set refs(value) {\n        defineProperty(this, 'refs', {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value,\n        });\n    },\n    get shadowRoot() {\n        // From within the component instance, the shadowRoot is always reported as \"closed\".\n        // Authors should rely on this.template instead.\n        return null;\n    },\n    get children() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'children');\n        }\n        return renderer.getChildren(vm.elm);\n    },\n    get childNodes() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'childNodes');\n        }\n        return renderer.getChildNodes(vm.elm);\n    },\n    get firstChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'firstChild');\n        }\n        return renderer.getFirstChild(vm.elm);\n    },\n    get firstElementChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'firstElementChild');\n        }\n        return renderer.getFirstElementChild(vm.elm);\n    },\n    get lastChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'lastChild');\n        }\n        return renderer.getLastChild(vm.elm);\n    },\n    get lastElementChild() {\n        const vm = getAssociatedVM(this);\n        const renderer = vm.renderer;\n        if (process.env.NODE_ENV !== 'production') {\n            warnIfInvokedDuringConstruction(vm, 'lastElementChild');\n        }\n        return renderer.getLastElementChild(vm.elm);\n    },\n    render() {\n        const vm = getAssociatedVM(this);\n        return vm.def.template;\n    },\n    toString() {\n        const vm = getAssociatedVM(this);\n        return `[object ${vm.def.name}]`;\n    },\n};\nconst queryAndChildGetterDescriptors = create(null);\nconst queryMethods = [\n    'getElementsByClassName',\n    'getElementsByTagName',\n    'querySelector',\n    'querySelectorAll',\n];\n// Generic passthrough for query APIs on HTMLElement to the relevant Renderer APIs\nfor (const queryMethod of queryMethods) {\n    queryAndChildGetterDescriptors[queryMethod] = {\n        value(arg) {\n            const vm = getAssociatedVM(this);\n            const { elm, renderer } = vm;\n            if (process.env.NODE_ENV !== 'production') {\n                warnIfInvokedDuringConstruction(vm, `${queryMethod}()`);\n            }\n            return renderer[queryMethod](elm, arg);\n        },\n        configurable: true,\n        enumerable: true,\n        writable: true,\n    };\n}\ndefineProperties(LightningElement.prototype, queryAndChildGetterDescriptors);\nconst lightningBasedDescriptors = create(null);\nfor (const propName in HTMLElementOriginalDescriptors) {\n    lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);\n}\ndefineProperties(LightningElement.prototype, lightningBasedDescriptors);\nfunction applyAriaReflectionToLightningElement() {\n    // If ARIA reflection is not applied globally to Element.prototype, or if we are running server-side,\n    // apply it to LightningElement.prototype.\n    // This allows `this.aria*` property accessors to work from inside a component, and to reflect `aria-*` attrs.\n    applyAriaReflection(LightningElement.prototype);\n}\nif (lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {\n    applyAriaReflectionToLightningElement();\n}\ndefineProperty(LightningElement, 'CustomElementConstructor', {\n    get() {\n        // If required, a runtime-specific implementation must be defined.\n        throw new ReferenceError('The current runtime does not support CustomElementConstructor.');\n    },\n    configurable: true,\n});\nif (process.env.NODE_ENV !== 'production') {\n    patchLightningElementPrototypeWithRestrictions(LightningElement.prototype);\n}\n\nfunction createObservedFieldPropertyDescriptor(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            componentValueObserved(vm, key);\n            return vm.cmpFields[key];\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            updateComponentValue(vm, key, newValue);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';\nconst DeprecatedWiredParamsMeta = '$$DeprecatedWiredParamsMetaKey$$';\nconst WIRE_DEBUG_ENTRY = '@wire';\nconst WireMetaMap = new Map();\nclass WireContextRegistrationEvent extends CustomEvent {\n    constructor(adapterToken, { setNewContext, setDisconnectedCallback }) {\n        super(adapterToken, {\n            bubbles: true,\n            composed: true,\n        });\n        defineProperties(this, {\n            setNewContext: {\n                value: setNewContext,\n            },\n            setDisconnectedCallback: {\n                value: setDisconnectedCallback,\n            },\n        });\n    }\n}\nfunction createFieldDataCallback(vm, name) {\n    return (value) => {\n        updateComponentValue(vm, name, value);\n    };\n}\nfunction createMethodDataCallback(vm, method) {\n    return (value) => {\n        // dispatching new value into the wired method\n        runWithBoundaryProtection(vm, vm.owner, noop, () => {\n            // job\n            method.call(vm.component, value);\n        }, noop);\n    };\n}\nfunction createConfigWatcher(component, configCallback, callbackWhenConfigIsReady) {\n    let hasPendingConfig = false;\n    // creating the reactive observer for reactive params when needed\n    const ro = createReactiveObserver(() => {\n        if (hasPendingConfig === false) {\n            hasPendingConfig = true;\n            // collect new config in the micro-task\n            Promise.resolve().then(() => {\n                hasPendingConfig = false;\n                // resetting current reactive params\n                ro.reset();\n                // dispatching a new config due to a change in the configuration\n                computeConfigAndUpdate();\n            });\n        }\n    });\n    const computeConfigAndUpdate = () => {\n        let config;\n        ro.observe(() => (config = configCallback(component)));\n        // eslint-disable-next-line @lwc/lwc-internal/no-invalid-todo\n        // TODO: dev-mode validation of config based on the adapter.configSchema\n        // @ts-ignore it is assigned in the observe() callback\n        callbackWhenConfigIsReady(config);\n    };\n    return {\n        computeConfigAndUpdate,\n        ro,\n    };\n}\nfunction createContextWatcher(vm, wireDef, callbackWhenContextIsReady) {\n    const { adapter } = wireDef;\n    const adapterContextToken = getAdapterToken(adapter);\n    if (isUndefined$1(adapterContextToken)) {\n        return; // no provider found, nothing to be done\n    }\n    const { elm, context: { wiredConnecting, wiredDisconnecting }, renderer: { dispatchEvent }, } = vm;\n    // waiting for the component to be connected to formally request the context via the token\n    ArrayPush$1.call(wiredConnecting, () => {\n        // This event is responsible for connecting the host element with another\n        // element in the composed path that is providing contextual data. The provider\n        // must be listening for a special dom event with the name corresponding to the value of\n        // `adapterContextToken`, which will remain secret and internal to this file only to\n        // guarantee that the linkage can be forged.\n        const contextRegistrationEvent = new WireContextRegistrationEvent(adapterContextToken, {\n            setNewContext(newContext) {\n                // eslint-disable-next-line @lwc/lwc-internal/no-invalid-todo\n                // TODO: dev-mode validation of config based on the adapter.contextSchema\n                callbackWhenContextIsReady(newContext);\n            },\n            setDisconnectedCallback(disconnectCallback) {\n                // adds this callback into the disconnect bucket so it gets disconnected from parent\n                // the the element hosting the wire is disconnected\n                ArrayPush$1.call(wiredDisconnecting, disconnectCallback);\n            },\n        });\n        dispatchEvent(elm, contextRegistrationEvent);\n    });\n}\nfunction createConnector(vm, name, wireDef) {\n    const { method, adapter, configCallback, dynamic } = wireDef;\n    let debugInfo;\n    if (process.env.NODE_ENV !== 'production') {\n        const wiredPropOrMethod = isUndefined$1(method) ? name : method.name;\n        debugInfo = create(null);\n        debugInfo.wasDataProvisionedForConfig = false;\n        vm.debugInfo[WIRE_DEBUG_ENTRY][wiredPropOrMethod] = debugInfo;\n    }\n    const fieldOrMethodCallback = isUndefined$1(method)\n        ? createFieldDataCallback(vm, name)\n        : createMethodDataCallback(vm, method);\n    const dataCallback = (value) => {\n        if (process.env.NODE_ENV !== 'production') {\n            debugInfo.data = value;\n            // Note: most of the time, the data provided is for the current config, but there may be\n            // some conditions in which it does not, ex:\n            // race conditions in a poor network while the adapter does not cancel a previous request.\n            debugInfo.wasDataProvisionedForConfig = true;\n        }\n        fieldOrMethodCallback(value);\n    };\n    let context;\n    let connector;\n    // Workaround to pass the component element associated to this wire adapter instance.\n    defineProperty(dataCallback, DeprecatedWiredElementHost, {\n        value: vm.elm,\n    });\n    defineProperty(dataCallback, DeprecatedWiredParamsMeta, {\n        value: dynamic,\n    });\n    runWithBoundaryProtection(vm, vm, noop, () => {\n        // job\n        connector = new adapter(dataCallback);\n    }, noop);\n    const updateConnectorConfig = (config) => {\n        // every time the config is recomputed due to tracking,\n        // this callback will be invoked with the new computed config\n        runWithBoundaryProtection(vm, vm, noop, () => {\n            // job\n            if (process.env.NODE_ENV !== 'production') {\n                debugInfo.config = config;\n                debugInfo.context = context;\n                debugInfo.wasDataProvisionedForConfig = false;\n            }\n            connector.update(config, context);\n        }, noop);\n    };\n    // Computes the current wire config and calls the update method on the wire adapter.\n    // If it has params, we will need to observe changes in the next tick.\n    const { computeConfigAndUpdate, ro } = createConfigWatcher(vm.component, configCallback, updateConnectorConfig);\n    // if the adapter needs contextualization, we need to watch for new context and push it alongside the config\n    if (!isUndefined$1(adapter.contextSchema)) {\n        createContextWatcher(vm, wireDef, (newContext) => {\n            // every time the context is pushed into this component,\n            // this callback will be invoked with the new computed context\n            if (context !== newContext) {\n                context = newContext;\n                // Note: when new context arrives, the config will be recomputed and pushed along side the new\n                // context, this is to preserve the identity characteristics, config should not have identity\n                // (ever), while context can have identity\n                if (vm.state === 1 /* VMState.connected */) {\n                    computeConfigAndUpdate();\n                }\n            }\n        });\n    }\n    return {\n        // @ts-ignore the boundary protection executes sync, connector is always defined\n        connector,\n        computeConfigAndUpdate,\n        resetConfigWatcher: () => ro.reset(),\n    };\n}\nconst AdapterToTokenMap = new Map();\nfunction getAdapterToken(adapter) {\n    return AdapterToTokenMap.get(adapter);\n}\nfunction setAdapterToken(adapter, token) {\n    AdapterToTokenMap.set(adapter, token);\n}\nfunction storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic) {\n    // support for callable adapters\n    if (adapter.adapter) {\n        adapter = adapter.adapter;\n    }\n    const method = descriptor.value;\n    const def = {\n        adapter,\n        method,\n        configCallback,\n        dynamic,\n    };\n    WireMetaMap.set(descriptor, def);\n}\nfunction storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic) {\n    // support for callable adapters\n    if (adapter.adapter) {\n        adapter = adapter.adapter;\n    }\n    const def = {\n        adapter,\n        configCallback,\n        dynamic,\n    };\n    WireMetaMap.set(descriptor, def);\n}\nfunction installWireAdapters(vm) {\n    const { context, def: { wire }, } = vm;\n    if (process.env.NODE_ENV !== 'production') {\n        vm.debugInfo[WIRE_DEBUG_ENTRY] = create(null);\n    }\n    const wiredConnecting = (context.wiredConnecting = []);\n    const wiredDisconnecting = (context.wiredDisconnecting = []);\n    for (const fieldNameOrMethod in wire) {\n        const descriptor = wire[fieldNameOrMethod];\n        const wireDef = WireMetaMap.get(descriptor);\n        if (process.env.NODE_ENV !== 'production') {\n            assert.invariant(wireDef, `Internal Error: invalid wire definition found.`);\n        }\n        if (!isUndefined$1(wireDef)) {\n            const { connector, computeConfigAndUpdate, resetConfigWatcher } = createConnector(vm, fieldNameOrMethod, wireDef);\n            const hasDynamicParams = wireDef.dynamic.length > 0;\n            ArrayPush$1.call(wiredConnecting, () => {\n                connector.connect();\n                if (!lwcRuntimeFlags.ENABLE_WIRE_SYNC_EMIT) {\n                    if (hasDynamicParams) {\n                        Promise.resolve().then(computeConfigAndUpdate);\n                        return;\n                    }\n                }\n                computeConfigAndUpdate();\n            });\n            ArrayPush$1.call(wiredDisconnecting, () => {\n                connector.disconnect();\n                resetConfigWatcher();\n            });\n        }\n    }\n}\nfunction connectWireAdapters(vm) {\n    const { wiredConnecting } = vm.context;\n    for (let i = 0, len = wiredConnecting.length; i < len; i += 1) {\n        wiredConnecting[i]();\n    }\n}\nfunction disconnectWireAdapters(vm) {\n    const { wiredDisconnecting } = vm.context;\n    runWithBoundaryProtection(vm, vm, noop, () => {\n        // job\n        for (let i = 0, len = wiredDisconnecting.length; i < len; i += 1) {\n            wiredDisconnecting[i]();\n        }\n    }, noop);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction api$1() {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.fail(`@api decorator can only be used as a decorator function.`);\n    }\n    throw new Error();\n}\nfunction createPublicPropertyDescriptor(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            if (isBeingConstructed(vm)) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logError(`Can’t read the value of property \\`${toString$1(key)}\\` from the constructor because the owner component hasn’t set the value yet. Instead, use the constructor to set a default value for the property.`, vm);\n                }\n                return;\n            }\n            componentValueObserved(vm, key);\n            return vm.cmpProps[key];\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                const vmBeingRendered = getVMBeingRendered();\n                assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString$1(key)}`);\n                assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString$1(key)}`);\n            }\n            vm.cmpProps[key] = newValue;\n            componentValueMutated(vm, key);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\nfunction createPublicAccessorDescriptor(key, descriptor) {\n    const { get, set, enumerable, configurable } = descriptor;\n    if (!isFunction$1(get)) {\n        if (process.env.NODE_ENV !== 'production') {\n            assert.invariant(isFunction$1(get), `Invalid compiler output for public accessor ${toString$1(key)} decorated with @api`);\n        }\n        throw new Error();\n    }\n    return {\n        get() {\n            if (process.env.NODE_ENV !== 'production') {\n                // Assert that the this value is an actual Component with an associated VM.\n                getAssociatedVM(this);\n            }\n            return get.call(this);\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                const vmBeingRendered = getVMBeingRendered();\n                assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString$1(key)}`);\n                assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString$1(key)}`);\n            }\n            if (set) {\n                set.call(this, newValue);\n            }\n            else if (process.env.NODE_ENV !== 'production') {\n                assert.fail(`Invalid attempt to set a new value for property ${toString$1(key)} of ${vm} that does not has a setter decorated with @api.`);\n            }\n        },\n        enumerable,\n        configurable,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction track(target) {\n    if (arguments.length === 1) {\n        return getReactiveProxy(target);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert.fail(`@track decorator can only be used with one argument to return a trackable object, or as a decorator function.`);\n    }\n    throw new Error();\n}\nfunction internalTrackDecorator(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            componentValueObserved(vm, key);\n            return vm.cmpFields[key];\n        },\n        set(newValue) {\n            const vm = getAssociatedVM(this);\n            if (process.env.NODE_ENV !== 'production') {\n                const vmBeingRendered = getVMBeingRendered();\n                assert.invariant(!isInvokingRender, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString$1(key)}`);\n                assert.invariant(!isUpdatingTemplate, `Updating the template of ${vmBeingRendered} has side effects on the state of ${vm}.${toString$1(key)}`);\n            }\n            const reactiveOrAnyValue = getReactiveProxy(newValue);\n            updateComponentValue(vm, key, reactiveOrAnyValue);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * @wire decorator to wire fields and methods to a wire adapter in\n * LWC Components. This function implements the internals of this\n * decorator.\n */\nfunction wire(_adapter, _config) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.fail('@wire(adapter, config?) may only be used as a decorator.');\n    }\n    throw new Error();\n}\nfunction internalWireFieldDecorator(key) {\n    return {\n        get() {\n            const vm = getAssociatedVM(this);\n            componentValueObserved(vm, key);\n            return vm.cmpFields[key];\n        },\n        set(value) {\n            const vm = getAssociatedVM(this);\n            /**\n             * Reactivity for wired fields is provided in wiring.\n             * We intentionally add reactivity here since this is just\n             * letting the author to do the wrong thing, but it will keep our\n             * system to be backward compatible.\n             */\n            updateComponentValue(vm, key, value);\n        },\n        enumerable: true,\n        configurable: true,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getClassDescriptorType(descriptor) {\n    if (isFunction$1(descriptor.value)) {\n        return \"method\" /* DescriptorType.Method */;\n    }\n    else if (isFunction$1(descriptor.set) || isFunction$1(descriptor.get)) {\n        return \"accessor\" /* DescriptorType.Accessor */;\n    }\n    else {\n        return \"field\" /* DescriptorType.Field */;\n    }\n}\nfunction validateObservedField(Ctor, fieldName, descriptor) {\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        const message = `Invalid observed ${fieldName} field. Found a duplicate ${type} with the same name.`;\n        // [W-9927596] Ideally we always throw an error when detecting duplicate observed field.\n        // This branch is only here for backward compatibility reasons.\n        if (type === \"accessor\" /* DescriptorType.Accessor */) {\n            logError(message);\n        }\n        else {\n            assert.fail(message);\n        }\n    }\n}\nfunction validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor) {\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        assert.fail(`Invalid @track ${fieldName} field. Found a duplicate ${type} with the same name.`);\n    }\n}\nfunction validateFieldDecoratedWithWire(Ctor, fieldName, descriptor) {\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        assert.fail(`Invalid @wire ${fieldName} field. Found a duplicate ${type} with the same name.`);\n    }\n}\nfunction validateMethodDecoratedWithWire(Ctor, methodName, descriptor) {\n    if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {\n        assert.fail(`Invalid @wire ${methodName} method.`);\n    }\n}\nfunction validateFieldDecoratedWithApi(Ctor, fieldName, descriptor) {\n    if (!isUndefined$1(descriptor)) {\n        const type = getClassDescriptorType(descriptor);\n        const message = `Invalid @api ${fieldName} field. Found a duplicate ${type} with the same name.`;\n        // [W-9927596] Ideally we always throw an error when detecting duplicate public properties.\n        // This branch is only here for backward compatibility reasons.\n        if (type === \"accessor\" /* DescriptorType.Accessor */) {\n            logError(message);\n        }\n        else {\n            assert.fail(message);\n        }\n    }\n}\nfunction validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor) {\n    if (isUndefined$1(descriptor)) {\n        assert.fail(`Invalid @api get ${fieldName} accessor.`);\n    }\n    else if (isFunction$1(descriptor.set)) {\n        assert.isTrue(isFunction$1(descriptor.get), `Missing getter for property ${fieldName} decorated with @api in ${Ctor}. You cannot have a setter without the corresponding getter.`);\n    }\n    else if (!isFunction$1(descriptor.get)) {\n        assert.fail(`Missing @api get ${fieldName} accessor.`);\n    }\n}\nfunction validateMethodDecoratedWithApi(Ctor, methodName, descriptor) {\n    if (isUndefined$1(descriptor) || !isFunction$1(descriptor.value) || isFalse(descriptor.writable)) {\n        assert.fail(`Invalid @api ${methodName} method.`);\n    }\n}\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by user-land code.\n */\nfunction registerDecorators(Ctor, meta) {\n    const proto = Ctor.prototype;\n    const { publicProps, publicMethods, wire, track, fields } = meta;\n    const apiMethods = create(null);\n    const apiFields = create(null);\n    const wiredMethods = create(null);\n    const wiredFields = create(null);\n    const observedFields = create(null);\n    const apiFieldsConfig = create(null);\n    let descriptor;\n    if (!isUndefined$1(publicProps)) {\n        for (const fieldName in publicProps) {\n            const propConfig = publicProps[fieldName];\n            apiFieldsConfig[fieldName] = propConfig.config;\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n            if (propConfig.config > 0) {\n                // accessor declaration\n                if (process.env.NODE_ENV !== 'production') {\n                    validateAccessorDecoratedWithApi(Ctor, fieldName, descriptor);\n                }\n                if (isUndefined$1(descriptor)) {\n                    throw new Error();\n                }\n                descriptor = createPublicAccessorDescriptor(fieldName, descriptor);\n            }\n            else {\n                // field declaration\n                if (process.env.NODE_ENV !== 'production') {\n                    validateFieldDecoratedWithApi(Ctor, fieldName, descriptor);\n                }\n                // [W-9927596] If a component has both a public property and a private setter/getter\n                // with the same name, the property is defined as a public accessor. This branch is\n                // only here for backward compatibility reasons.\n                if (!isUndefined$1(descriptor) && !isUndefined$1(descriptor.get)) {\n                    descriptor = createPublicAccessorDescriptor(fieldName, descriptor);\n                }\n                else {\n                    descriptor = createPublicPropertyDescriptor(fieldName);\n                }\n            }\n            apiFields[fieldName] = descriptor;\n            defineProperty(proto, fieldName, descriptor);\n        }\n    }\n    if (!isUndefined$1(publicMethods)) {\n        forEach.call(publicMethods, (methodName) => {\n            descriptor = getOwnPropertyDescriptor$1(proto, methodName);\n            if (process.env.NODE_ENV !== 'production') {\n                validateMethodDecoratedWithApi(Ctor, methodName, descriptor);\n            }\n            if (isUndefined$1(descriptor)) {\n                throw new Error();\n            }\n            apiMethods[methodName] = descriptor;\n        });\n    }\n    if (!isUndefined$1(wire)) {\n        for (const fieldOrMethodName in wire) {\n            const { adapter, method, config: configCallback, dynamic = [], } = wire[fieldOrMethodName];\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldOrMethodName);\n            if (method === 1) {\n                if (process.env.NODE_ENV !== 'production') {\n                    assert.isTrue(adapter, `@wire on method \"${fieldOrMethodName}\": adapter id must be truthy.`);\n                    validateMethodDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);\n                }\n                if (isUndefined$1(descriptor)) {\n                    throw new Error();\n                }\n                wiredMethods[fieldOrMethodName] = descriptor;\n                storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic);\n            }\n            else {\n                if (process.env.NODE_ENV !== 'production') {\n                    assert.isTrue(adapter, `@wire on field \"${fieldOrMethodName}\": adapter id must be truthy.`);\n                    validateFieldDecoratedWithWire(Ctor, fieldOrMethodName, descriptor);\n                }\n                descriptor = internalWireFieldDecorator(fieldOrMethodName);\n                wiredFields[fieldOrMethodName] = descriptor;\n                storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic);\n                defineProperty(proto, fieldOrMethodName, descriptor);\n            }\n        }\n    }\n    if (!isUndefined$1(track)) {\n        for (const fieldName in track) {\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n            if (process.env.NODE_ENV !== 'production') {\n                validateFieldDecoratedWithTrack(Ctor, fieldName, descriptor);\n            }\n            descriptor = internalTrackDecorator(fieldName);\n            defineProperty(proto, fieldName, descriptor);\n        }\n    }\n    if (!isUndefined$1(fields)) {\n        for (let i = 0, n = fields.length; i < n; i++) {\n            const fieldName = fields[i];\n            descriptor = getOwnPropertyDescriptor$1(proto, fieldName);\n            if (process.env.NODE_ENV !== 'production') {\n                validateObservedField(Ctor, fieldName, descriptor);\n            }\n            // [W-9927596] Only mark a field as observed whenever it isn't a duplicated public nor\n            // tracked property. This is only here for backward compatibility purposes.\n            const isDuplicatePublicProp = !isUndefined$1(publicProps) && fieldName in publicProps;\n            const isDuplicateTrackedProp = !isUndefined$1(track) && fieldName in track;\n            if (!isDuplicatePublicProp && !isDuplicateTrackedProp) {\n                observedFields[fieldName] = createObservedFieldPropertyDescriptor(fieldName);\n            }\n        }\n    }\n    setDecoratorsMeta(Ctor, {\n        apiMethods,\n        apiFields,\n        apiFieldsConfig,\n        wiredMethods,\n        wiredFields,\n        observedFields,\n    });\n    return Ctor;\n}\nconst signedDecoratorToMetaMap = new Map();\nfunction setDecoratorsMeta(Ctor, meta) {\n    signedDecoratorToMetaMap.set(Ctor, meta);\n}\nconst defaultMeta = {\n    apiMethods: EmptyObject,\n    apiFields: EmptyObject,\n    apiFieldsConfig: EmptyObject,\n    wiredMethods: EmptyObject,\n    wiredFields: EmptyObject,\n    observedFields: EmptyObject,\n};\nfunction getDecoratorsMeta(Ctor) {\n    const meta = signedDecoratorToMetaMap.get(Ctor);\n    return isUndefined$1(meta) ? defaultMeta : meta;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet warned = false;\n// Only used in LWC's Karma tests\nif (process.env.NODE_ENV === 'test-karma-lwc') {\n    // @ts-ignore\n    window.__lwcResetWarnedOnVersionMismatch = () => {\n        warned = false;\n    };\n}\nfunction checkVersionMismatch(func, type) {\n    const versionMatcher = func.toString().match(LWC_VERSION_COMMENT_REGEX);\n    if (!isNull(versionMatcher) && !warned) {\n        const version = versionMatcher[1];\n        const [major, minor] = version.split('.');\n        const [expectedMajor, expectedMinor] = LWC_VERSION.split('.');\n        if (major !== expectedMajor || minor !== expectedMinor) {\n            warned = true; // only warn once to avoid flooding the console\n            // stylesheets and templates do not have user-meaningful names, but components do\n            const friendlyName = type === 'component' ? `${type} ${func.name}` : type;\n            logError(`LWC WARNING: current engine is v${LWC_VERSION}, but ${friendlyName} was compiled with v${version}.\\nPlease update your compiled code or LWC engine so that the versions match.\\nNo further warnings will appear.`);\n            report(\"CompilerRuntimeVersionMismatch\" /* ReportingEventId.CompilerRuntimeVersionMismatch */, {\n                compilerVersion: version,\n                runtimeVersion: LWC_VERSION,\n            });\n        }\n    }\n}\n\nconst signedTemplateSet = new Set();\nfunction defaultEmptyTemplate() {\n    return [];\n}\nsignedTemplateSet.add(defaultEmptyTemplate);\nfunction isTemplateRegistered(tpl) {\n    return signedTemplateSet.has(tpl);\n}\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\nfunction registerTemplate(tpl) {\n    if (process.env.NODE_ENV !== 'production') {\n        checkVersionMismatch(tpl, 'template');\n    }\n    signedTemplateSet.add(tpl);\n    // chaining this method as a way to wrap existing\n    // assignment of templates easily, without too much transformation\n    return tpl;\n}\n/**\n * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar\n * libraries to sanitize vulnerable attributes.\n */\nfunction sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {\n    // locker-service patches this function during runtime to sanitize vulnerable attributes. When\n    // ran off-core this function becomes a noop and returns the user authored value.\n    return attrValue;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// A bridge descriptor is a descriptor whose job is just to get the component instance\n// from the element instance, and get the value or set a new value on the component.\n// This means that across different elements, similar names can get the exact same\n// descriptor, so we can cache them:\nconst cachedGetterByKey = create(null);\nconst cachedSetterByKey = create(null);\nfunction createGetter(key) {\n    let fn = cachedGetterByKey[key];\n    if (isUndefined$1(fn)) {\n        fn = cachedGetterByKey[key] = function () {\n            const vm = getAssociatedVM(this);\n            const { getHook } = vm;\n            return getHook(vm.component, key);\n        };\n    }\n    return fn;\n}\nfunction createSetter(key) {\n    let fn = cachedSetterByKey[key];\n    if (isUndefined$1(fn)) {\n        fn = cachedSetterByKey[key] = function (newValue) {\n            const vm = getAssociatedVM(this);\n            const { setHook } = vm;\n            newValue = getReadOnlyProxy(newValue);\n            setHook(vm.component, key, newValue);\n        };\n    }\n    return fn;\n}\nfunction createMethodCaller(methodName) {\n    return function () {\n        const vm = getAssociatedVM(this);\n        const { callHook, component } = vm;\n        const fn = component[methodName];\n        return callHook(vm.component, fn, ArraySlice.call(arguments));\n    };\n}\nfunction createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback) {\n    return function attributeChangedCallback(attrName, oldValue, newValue) {\n        if (oldValue === newValue) {\n            // Ignore same values.\n            return;\n        }\n        const propName = attributeToPropMap[attrName];\n        if (isUndefined$1(propName)) {\n            if (!isUndefined$1(superAttributeChangedCallback)) {\n                // delegate unknown attributes to the super.\n                // Typescript does not like it when you treat the `arguments` object as an array\n                // @ts-ignore type-mismatch\n                superAttributeChangedCallback.apply(this, arguments);\n            }\n            return;\n        }\n        if (!isAttributeLocked(this, attrName)) {\n            // Ignore changes triggered by the engine itself during:\n            // * diffing when public props are attempting to reflect to the DOM\n            // * component via `this.setAttribute()`, should never update the prop\n            // Both cases, the setAttribute call is always wrapped by the unlocking of the\n            // attribute to be changed\n            return;\n        }\n        // Reflect attribute change to the corresponding property when changed from outside.\n        this[propName] = newValue;\n    };\n}\nfunction HTMLBridgeElementFactory(SuperClass, props, methods) {\n    let HTMLBridgeElement;\n    /**\n     * Modern browsers will have all Native Constructors as regular Classes\n     * and must be instantiated with the new keyword. In older browsers,\n     * specifically IE11, those are objects with a prototype property defined,\n     * since they are not supposed to be extended or instantiated with the\n     * new keyword. This forking logic supports both cases, specifically because\n     * wc.ts relies on the construction path of the bridges to create new\n     * fully qualifying web components.\n     */\n    if (isFunction$1(SuperClass)) {\n        HTMLBridgeElement = class extends SuperClass {\n        };\n    }\n    else {\n        HTMLBridgeElement = function () {\n            // Bridge classes are not supposed to be instantiated directly in\n            // browsers that do not support web components.\n            throw new TypeError('Illegal constructor');\n        };\n        // prototype inheritance dance\n        setPrototypeOf(HTMLBridgeElement, SuperClass);\n        setPrototypeOf(HTMLBridgeElement.prototype, SuperClass.prototype);\n        defineProperty(HTMLBridgeElement.prototype, 'constructor', {\n            writable: true,\n            configurable: true,\n            value: HTMLBridgeElement,\n        });\n    }\n    // generating the hash table for attributes to avoid duplicate fields and facilitate validation\n    // and false positives in case of inheritance.\n    const attributeToPropMap = create(null);\n    const { attributeChangedCallback: superAttributeChangedCallback } = SuperClass.prototype;\n    const { observedAttributes: superObservedAttributes = [] } = SuperClass;\n    const descriptors = create(null);\n    // expose getters and setters for each public props on the new Element Bridge\n    for (let i = 0, len = props.length; i < len; i += 1) {\n        const propName = props[i];\n        attributeToPropMap[htmlPropertyToAttribute(propName)] = propName;\n        descriptors[propName] = {\n            get: createGetter(propName),\n            set: createSetter(propName),\n            enumerable: true,\n            configurable: true,\n        };\n    }\n    // expose public methods as props on the new Element Bridge\n    for (let i = 0, len = methods.length; i < len; i += 1) {\n        const methodName = methods[i];\n        descriptors[methodName] = {\n            value: createMethodCaller(methodName),\n            writable: true,\n            configurable: true,\n        };\n    }\n    // creating a new attributeChangedCallback per bridge because they are bound to the corresponding\n    // map of attributes to props. We do this after all other props and methods to avoid the possibility\n    // of getting overrule by a class declaration in user-land, and we make it non-writable, non-configurable\n    // to preserve this definition.\n    descriptors.attributeChangedCallback = {\n        value: createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback),\n    };\n    // Specify attributes for which we want to reflect changes back to their corresponding\n    // properties via attributeChangedCallback.\n    defineProperty(HTMLBridgeElement, 'observedAttributes', {\n        get() {\n            return [...superObservedAttributes, ...keys(attributeToPropMap)];\n        },\n    });\n    defineProperties(HTMLBridgeElement.prototype, descriptors);\n    return HTMLBridgeElement;\n}\nconst BaseBridgeElement = HTMLBridgeElementFactory(HTMLElementConstructor, getOwnPropertyNames$1(HTMLElementOriginalDescriptors), []);\n{\n    // This ARIA reflection only really makes sense in the browser. On the server, there is no `renderedCallback()`,\n    // so you cannot do e.g. `this.template.querySelector('x-child').ariaBusy = 'true'`. So we don't need to expose\n    // ARIA props outside the LightningElement\n    if (lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {\n        // If ARIA reflection is not applied globally to Element.prototype, apply it to HTMLBridgeElement.prototype.\n        // This allows `elm.aria*` property accessors to work from outside a component, and to reflect `aria-*` attrs.\n        // This is especially important because the template compiler compiles aria-* attrs on components to aria* props\n        //\n        // Also note that we apply this to BaseBridgeElement.prototype to avoid excessively redefining property\n        // accessors inside the HTMLBridgeElementFactory.\n        applyAriaReflection(BaseBridgeElement.prototype);\n    }\n}\nfreeze(BaseBridgeElement);\nseal(BaseBridgeElement.prototype);\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst swappedTemplateMap = new WeakMap();\nconst swappedComponentMap = new WeakMap();\nconst swappedStyleMap = new WeakMap();\nconst activeTemplates = new WeakMap();\nconst activeComponents = new WeakMap();\nconst activeStyles = new WeakMap();\nfunction rehydrateHotTemplate(tpl) {\n    const list = activeTemplates.get(tpl);\n    if (!isUndefined$1(list)) {\n        list.forEach((vm) => {\n            if (isFalse(vm.isDirty)) {\n                // forcing the vm to rehydrate in the micro-task:\n                markComponentAsDirty(vm);\n                scheduleRehydration(vm);\n            }\n        });\n        // resetting the Set to release the memory of those vm references\n        // since they are not longer related to this template, instead\n        // they will get re-associated once these instances are rehydrated.\n        list.clear();\n    }\n    return true;\n}\nfunction rehydrateHotStyle(style) {\n    const list = activeStyles.get(style);\n    if (!isUndefined$1(list)) {\n        list.forEach((vm) => {\n            // if a style definition is swapped, we must reset\n            // vm's template content in the next micro-task:\n            forceRehydration(vm);\n        });\n        // resetting the Set to release the memory of those vm references\n        // since they are not longer related to this style, instead\n        // they will get re-associated once these instances are rehydrated.\n        list.clear();\n    }\n    return true;\n}\nfunction rehydrateHotComponent(Ctor) {\n    const list = activeComponents.get(Ctor);\n    let canRefreshAllInstances = true;\n    if (!isUndefined$1(list)) {\n        list.forEach((vm) => {\n            const { owner } = vm;\n            if (!isNull(owner)) {\n                // if a component class definition is swapped, we must reset\n                // owner's template content in the next micro-task:\n                forceRehydration(owner);\n            }\n            else {\n                // the hot swapping for components only work for instances of components\n                // created from a template, root elements can't be swapped because we\n                // don't have a way to force the creation of the element with the same state\n                // of the current element.\n                // Instead, we can report the problem to the caller so it can take action,\n                // for example: reload the entire page.\n                canRefreshAllInstances = false;\n            }\n        });\n        // resetting the Set to release the memory of those vm references\n        // since they are not longer related to this constructor, instead\n        // they will get re-associated once these instances are rehydrated.\n        list.clear();\n    }\n    return canRefreshAllInstances;\n}\nfunction getTemplateOrSwappedTemplate(tpl) {\n    assertNotProd(); // this method should never leak to prod\n    const visited = new Set();\n    while (swappedTemplateMap.has(tpl) && !visited.has(tpl)) {\n        visited.add(tpl);\n        tpl = swappedTemplateMap.get(tpl);\n    }\n    return tpl;\n}\nfunction getComponentOrSwappedComponent(Ctor) {\n    assertNotProd(); // this method should never leak to prod\n    const visited = new Set();\n    while (swappedComponentMap.has(Ctor) && !visited.has(Ctor)) {\n        visited.add(Ctor);\n        Ctor = swappedComponentMap.get(Ctor);\n    }\n    return Ctor;\n}\nfunction getStyleOrSwappedStyle(style) {\n    assertNotProd(); // this method should never leak to prod\n    const visited = new Set();\n    while (swappedStyleMap.has(style) && !visited.has(style)) {\n        visited.add(style);\n        style = swappedStyleMap.get(style);\n    }\n    return style;\n}\nfunction setActiveVM(vm) {\n    assertNotProd(); // this method should never leak to prod\n    // tracking active component\n    const Ctor = vm.def.ctor;\n    let componentVMs = activeComponents.get(Ctor);\n    if (isUndefined$1(componentVMs)) {\n        componentVMs = new Set();\n        activeComponents.set(Ctor, componentVMs);\n    }\n    // this will allow us to keep track of the hot components\n    componentVMs.add(vm);\n    // tracking active template\n    const tpl = vm.cmpTemplate;\n    if (tpl) {\n        let templateVMs = activeTemplates.get(tpl);\n        if (isUndefined$1(templateVMs)) {\n            templateVMs = new Set();\n            activeTemplates.set(tpl, templateVMs);\n        }\n        // this will allow us to keep track of the templates that are\n        // being used by a hot component\n        templateVMs.add(vm);\n        // tracking active styles associated to template\n        const stylesheets = tpl.stylesheets;\n        if (!isUndefined$1(stylesheets)) {\n            flattenStylesheets(stylesheets).forEach((stylesheet) => {\n                // this is necessary because we don't hold the list of styles\n                // in the vm, we only hold the selected (already swapped template)\n                // but the styles attached to the template might not be the actual\n                // active ones, but the swapped versions of those.\n                stylesheet = getStyleOrSwappedStyle(stylesheet);\n                let stylesheetVMs = activeStyles.get(stylesheet);\n                if (isUndefined$1(stylesheetVMs)) {\n                    stylesheetVMs = new Set();\n                    activeStyles.set(stylesheet, stylesheetVMs);\n                }\n                // this will allow us to keep track of the stylesheet that are\n                // being used by a hot component\n                stylesheetVMs.add(vm);\n            });\n        }\n    }\n}\nfunction removeActiveVM(vm) {\n    assertNotProd(); // this method should never leak to prod\n    // tracking inactive component\n    const Ctor = vm.def.ctor;\n    let list = activeComponents.get(Ctor);\n    if (!isUndefined$1(list)) {\n        // deleting the vm from the set to avoid leaking memory\n        list.delete(vm);\n    }\n    // removing inactive template\n    const tpl = vm.cmpTemplate;\n    if (tpl) {\n        list = activeTemplates.get(tpl);\n        if (!isUndefined$1(list)) {\n            // deleting the vm from the set to avoid leaking memory\n            list.delete(vm);\n        }\n        // removing active styles associated to template\n        const styles = tpl.stylesheets;\n        if (!isUndefined$1(styles)) {\n            flattenStylesheets(styles).forEach((style) => {\n                list = activeStyles.get(style);\n                if (!isUndefined$1(list)) {\n                    // deleting the vm from the set to avoid leaking memory\n                    list.delete(vm);\n                }\n            });\n        }\n    }\n}\nfunction swapTemplate(oldTpl, newTpl) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (isTemplateRegistered(oldTpl) && isTemplateRegistered(newTpl)) {\n            swappedTemplateMap.set(oldTpl, newTpl);\n            return rehydrateHotTemplate(oldTpl);\n        }\n        else {\n            throw new TypeError(`Invalid Template`);\n        }\n    }\n    return false;\n}\nfunction swapComponent(oldComponent, newComponent) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (isComponentConstructor(oldComponent) && isComponentConstructor(newComponent)) {\n            swappedComponentMap.set(oldComponent, newComponent);\n            return rehydrateHotComponent(oldComponent);\n        }\n        else {\n            throw new TypeError(`Invalid Component`);\n        }\n    }\n    return false;\n}\nfunction swapStyle(oldStyle, newStyle) {\n    if (process.env.NODE_ENV !== 'production') {\n        // TODO [#1887]: once the support for registering styles is implemented\n        // we can add the validation of both styles around this block.\n        swappedStyleMap.set(oldStyle, newStyle);\n        return rehydrateHotStyle(oldStyle);\n    }\n    return false;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CtorToDefMap = new WeakMap();\nfunction getCtorProto(Ctor) {\n    let proto = getPrototypeOf$1(Ctor);\n    if (isNull(proto)) {\n        throw new ReferenceError(`Invalid prototype chain for ${Ctor.name}, you must extend LightningElement.`);\n    }\n    // covering the cases where the ref is circular in AMD\n    if (isCircularModuleDependency(proto)) {\n        const p = resolveCircularModuleDependency(proto);\n        if (process.env.NODE_ENV !== 'production') {\n            if (isNull(p)) {\n                throw new ReferenceError(`Circular module dependency for ${Ctor.name}, must resolve to a constructor that extends LightningElement.`);\n            }\n        }\n        // escape hatch for Locker and other abstractions to provide their own base class instead\n        // of our Base class without having to leak it to user-land. If the circular function returns\n        // itself, that's the signal that we have hit the end of the proto chain, which must always\n        // be base.\n        proto = p === proto ? LightningElement : p;\n    }\n    return proto;\n}\nfunction createComponentDef(Ctor) {\n    const { shadowSupportMode: ctorShadowSupportMode, renderMode: ctorRenderMode } = Ctor;\n    if (process.env.NODE_ENV !== 'production') {\n        const ctorName = Ctor.name;\n        // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.\n        // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a \"name\" property with string value, but found ${ctorName}.`);\n        assert.isTrue(Ctor.constructor, `Missing ${ctorName}.constructor, ${ctorName} should have a \"constructor\" property.`);\n        if (!isUndefined$1(ctorShadowSupportMode)) {\n            assert.invariant(ctorShadowSupportMode === \"any\" /* ShadowSupportMode.Any */ ||\n                ctorShadowSupportMode === \"reset\" /* ShadowSupportMode.Default */, `Invalid value for static property shadowSupportMode: '${ctorShadowSupportMode}'`);\n        }\n        if (!isUndefined$1(ctorRenderMode)) {\n            assert.invariant(ctorRenderMode === 'light' || ctorRenderMode === 'shadow', `Invalid value for static property renderMode: '${ctorRenderMode}'. renderMode must be either 'light' or 'shadow'.`);\n        }\n    }\n    const decoratorsMeta = getDecoratorsMeta(Ctor);\n    const { apiFields, apiFieldsConfig, apiMethods, wiredFields, wiredMethods, observedFields } = decoratorsMeta;\n    const proto = Ctor.prototype;\n    let { connectedCallback, disconnectedCallback, renderedCallback, errorCallback, render } = proto;\n    const superProto = getCtorProto(Ctor);\n    const superDef = superProto !== LightningElement ? getComponentInternalDef(superProto) : lightingElementDef;\n    const bridge = HTMLBridgeElementFactory(superDef.bridge, keys(apiFields), keys(apiMethods));\n    const props = assign(create(null), superDef.props, apiFields);\n    const propsConfig = assign(create(null), superDef.propsConfig, apiFieldsConfig);\n    const methods = assign(create(null), superDef.methods, apiMethods);\n    const wire = assign(create(null), superDef.wire, wiredFields, wiredMethods);\n    connectedCallback = connectedCallback || superDef.connectedCallback;\n    disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;\n    renderedCallback = renderedCallback || superDef.renderedCallback;\n    errorCallback = errorCallback || superDef.errorCallback;\n    render = render || superDef.render;\n    let shadowSupportMode = superDef.shadowSupportMode;\n    if (!isUndefined$1(ctorShadowSupportMode)) {\n        shadowSupportMode = ctorShadowSupportMode;\n    }\n    let renderMode = superDef.renderMode;\n    if (!isUndefined$1(ctorRenderMode)) {\n        renderMode = ctorRenderMode === 'light' ? 0 /* RenderMode.Light */ : 1 /* RenderMode.Shadow */;\n    }\n    const template = getComponentRegisteredTemplate(Ctor) || superDef.template;\n    const name = Ctor.name || superDef.name;\n    // installing observed fields into the prototype.\n    defineProperties(proto, observedFields);\n    const def = {\n        ctor: Ctor,\n        name,\n        wire,\n        props,\n        propsConfig,\n        methods,\n        bridge,\n        template,\n        renderMode,\n        shadowSupportMode,\n        connectedCallback,\n        disconnectedCallback,\n        renderedCallback,\n        errorCallback,\n        render,\n    };\n    if (process.env.NODE_ENV !== 'production') {\n        freeze(Ctor.prototype);\n    }\n    return def;\n}\n/**\n * EXPERIMENTAL: This function allows for the identification of LWC constructors. This API is\n * subject to change or being removed.\n */\nfunction isComponentConstructor(ctor) {\n    if (!isFunction$1(ctor)) {\n        return false;\n    }\n    // Fast path: LightningElement is part of the prototype chain of the constructor.\n    if (ctor.prototype instanceof LightningElement) {\n        return true;\n    }\n    // Slow path: LightningElement is not part of the prototype chain of the constructor, we need\n    // climb up the constructor prototype chain to check in case there are circular dependencies\n    // to resolve.\n    let current = ctor;\n    do {\n        if (isCircularModuleDependency(current)) {\n            const circularResolved = resolveCircularModuleDependency(current);\n            // If the circular function returns itself, that's the signal that we have hit the end\n            // of the proto chain, which must always be a valid base constructor.\n            if (circularResolved === current) {\n                return true;\n            }\n            current = circularResolved;\n        }\n        if (current === LightningElement) {\n            return true;\n        }\n    } while (!isNull(current) && (current = getPrototypeOf$1(current)));\n    // Finally return false if the LightningElement is not part of the prototype chain.\n    return false;\n}\nfunction getComponentInternalDef(Ctor) {\n    if (process.env.NODE_ENV !== 'production') {\n        Ctor = getComponentOrSwappedComponent(Ctor);\n    }\n    let def = CtorToDefMap.get(Ctor);\n    if (isUndefined$1(def)) {\n        if (isCircularModuleDependency(Ctor)) {\n            const resolvedCtor = resolveCircularModuleDependency(Ctor);\n            def = getComponentInternalDef(resolvedCtor);\n            // Cache the unresolved component ctor too. The next time if the same unresolved ctor is used,\n            // look up the definition in cache instead of re-resolving and recreating the def.\n            CtorToDefMap.set(Ctor, def);\n            return def;\n        }\n        if (!isComponentConstructor(Ctor)) {\n            throw new TypeError(`${Ctor} is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration.`);\n        }\n        def = createComponentDef(Ctor);\n        CtorToDefMap.set(Ctor, def);\n    }\n    return def;\n}\nfunction getComponentHtmlPrototype(Ctor) {\n    const def = getComponentInternalDef(Ctor);\n    return def.bridge;\n}\nconst lightingElementDef = {\n    ctor: LightningElement,\n    name: LightningElement.name,\n    props: lightningBasedDescriptors,\n    propsConfig: EmptyObject,\n    methods: EmptyObject,\n    renderMode: 1 /* RenderMode.Shadow */,\n    shadowSupportMode: \"reset\" /* ShadowSupportMode.Default */,\n    wire: EmptyObject,\n    bridge: BaseBridgeElement,\n    template: defaultEmptyTemplate,\n    render: LightningElement.prototype.render,\n};\n/**\n * EXPERIMENTAL: This function allows for the collection of internal component metadata. This API is\n * subject to change or being removed.\n */\nfunction getComponentDef(Ctor) {\n    const def = getComponentInternalDef(Ctor);\n    // From the internal def object, we need to extract the info that is useful\n    // for some external services, e.g.: Locker Service, usually, all they care\n    // is about the shape of the constructor, the internals of it are not relevant\n    // because they don't have a way to mess with that.\n    const { ctor, name, props, propsConfig, methods } = def;\n    const publicProps = {};\n    for (const key in props) {\n        // avoid leaking the reference to the public props descriptors\n        publicProps[key] = {\n            config: propsConfig[key] || 0,\n            type: \"any\" /* PropDefType.any */,\n            attr: htmlPropertyToAttribute(key),\n        };\n    }\n    const publicMethods = {};\n    for (const key in methods) {\n        // avoid leaking the reference to the public method descriptors\n        publicMethods[key] = methods[key].value;\n    }\n    return {\n        ctor,\n        name,\n        props: publicProps,\n        methods: publicMethods,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction makeHostToken(token) {\n    return `${token}-host`;\n}\nfunction createInlineStyleVNode(content) {\n    return api.h('style', {\n        key: 'style',\n        attrs: {\n            type: 'text/css',\n        },\n    }, [api.t(content)]);\n}\nfunction updateStylesheetToken(vm, template) {\n    const { elm, context, renderMode, shadowMode, renderer: { getClassList, removeAttribute, setAttribute }, } = vm;\n    const { stylesheets: newStylesheets, stylesheetToken: newStylesheetToken } = template;\n    const { stylesheets: newVmStylesheets } = vm;\n    const isSyntheticShadow = renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 1 /* ShadowMode.Synthetic */;\n    const { hasScopedStyles } = context;\n    let newToken;\n    let newHasTokenInClass;\n    let newHasTokenInAttribute;\n    // Reset the styling token applied to the host element.\n    const { stylesheetToken: oldToken, hasTokenInClass: oldHasTokenInClass, hasTokenInAttribute: oldHasTokenInAttribute, } = context;\n    if (!isUndefined$1(oldToken)) {\n        if (oldHasTokenInClass) {\n            getClassList(elm).remove(makeHostToken(oldToken));\n        }\n        if (oldHasTokenInAttribute) {\n            removeAttribute(elm, makeHostToken(oldToken));\n        }\n    }\n    // Apply the new template styling token to the host element, if the new template has any\n    // associated stylesheets. In the case of light DOM, also ensure there is at least one scoped stylesheet.\n    const hasNewStylesheets = hasStyles(newStylesheets);\n    const hasNewVmStylesheets = hasStyles(newVmStylesheets);\n    if (hasNewStylesheets || hasNewVmStylesheets) {\n        newToken = newStylesheetToken;\n    }\n    // Set the new styling token on the host element\n    if (!isUndefined$1(newToken)) {\n        if (hasScopedStyles) {\n            getClassList(elm).add(makeHostToken(newToken));\n            newHasTokenInClass = true;\n        }\n        if (isSyntheticShadow) {\n            setAttribute(elm, makeHostToken(newToken), '');\n            newHasTokenInAttribute = true;\n        }\n    }\n    // Update the styling tokens present on the context object.\n    context.stylesheetToken = newToken;\n    context.hasTokenInClass = newHasTokenInClass;\n    context.hasTokenInAttribute = newHasTokenInAttribute;\n}\nfunction evaluateStylesheetsContent(stylesheets, stylesheetToken, vm) {\n    const content = [];\n    let root;\n    for (let i = 0; i < stylesheets.length; i++) {\n        let stylesheet = stylesheets[i];\n        if (isArray$1(stylesheet)) {\n            ArrayPush$1.apply(content, evaluateStylesheetsContent(stylesheet, stylesheetToken, vm));\n        }\n        else {\n            if (process.env.NODE_ENV !== 'production') {\n                // Check for compiler version mismatch in dev mode only\n                checkVersionMismatch(stylesheet, 'stylesheet');\n                // in dev-mode, we support hot swapping of stylesheet, which means that\n                // the component instance might be attempting to use an old version of\n                // the stylesheet, while internally, we have a replacement for it.\n                stylesheet = getStyleOrSwappedStyle(stylesheet);\n            }\n            const isScopedCss = stylesheet[KEY__SCOPED_CSS];\n            if (lwcRuntimeFlags.DISABLE_LIGHT_DOM_UNSCOPED_CSS &&\n                !isScopedCss &&\n                vm.renderMode === 0 /* RenderMode.Light */) {\n                logError('Unscoped CSS is not supported in Light DOM. Please use scoped CSS (*.scoped.css) instead of unscoped CSS (*.css).');\n                continue;\n            }\n            // Apply the scope token only if the stylesheet itself is scoped, or if we're rendering synthetic shadow.\n            const scopeToken = isScopedCss ||\n                (vm.shadowMode === 1 /* ShadowMode.Synthetic */ && vm.renderMode === 1 /* RenderMode.Shadow */)\n                ? stylesheetToken\n                : undefined;\n            // Use the actual `:host` selector if we're rendering global CSS for light DOM, or if we're rendering\n            // native shadow DOM. Synthetic shadow DOM never uses `:host`.\n            const useActualHostSelector = vm.renderMode === 0 /* RenderMode.Light */\n                ? !isScopedCss\n                : vm.shadowMode === 0 /* ShadowMode.Native */;\n            // Use the native :dir() pseudoclass only in native shadow DOM. Otherwise, in synthetic shadow,\n            // we use an attribute selector on the host to simulate :dir().\n            let useNativeDirPseudoclass;\n            if (vm.renderMode === 1 /* RenderMode.Shadow */) {\n                useNativeDirPseudoclass = vm.shadowMode === 0 /* ShadowMode.Native */;\n            }\n            else {\n                // Light DOM components should only render `[dir]` if they're inside of a synthetic shadow root.\n                // At the top level (root is null) or inside of a native shadow root, they should use `:dir()`.\n                if (isUndefined$1(root)) {\n                    // Only calculate the root once as necessary\n                    root = getNearestShadowComponent(vm);\n                }\n                useNativeDirPseudoclass = isNull(root) || root.shadowMode === 0 /* ShadowMode.Native */;\n            }\n            ArrayPush$1.call(content, stylesheet(scopeToken, useActualHostSelector, useNativeDirPseudoclass));\n        }\n    }\n    return content;\n}\nfunction getStylesheetsContent(vm, template) {\n    const { stylesheets, stylesheetToken } = template;\n    const { stylesheets: vmStylesheets } = vm;\n    let content = [];\n    if (hasStyles(stylesheets)) {\n        content = evaluateStylesheetsContent(stylesheets, stylesheetToken, vm);\n    }\n    // VM (component) stylesheets apply after template stylesheets\n    if (hasStyles(vmStylesheets)) {\n        ArrayPush$1.apply(content, evaluateStylesheetsContent(vmStylesheets, stylesheetToken, vm));\n    }\n    return content;\n}\n// It might be worth caching this to avoid doing the lookup repeatedly, but\n// perf testing has not shown it to be a huge improvement yet:\n// https://github.com/salesforce/lwc/pull/2460#discussion_r691208892\nfunction getNearestShadowComponent(vm) {\n    let owner = vm;\n    while (!isNull(owner)) {\n        if (owner.renderMode === 1 /* RenderMode.Shadow */) {\n            return owner;\n        }\n        owner = owner.owner;\n    }\n    return owner;\n}\n/**\n * If the component that is currently being rendered uses scoped styles,\n * this returns the unique token for that scoped stylesheet. Otherwise\n * it returns null.\n */\nfunction getScopeTokenClass(owner) {\n    const { cmpTemplate, context } = owner;\n    return (context.hasScopedStyles && (cmpTemplate === null || cmpTemplate === void 0 ? void 0 : cmpTemplate.stylesheetToken)) || null;\n}\n/**\n * This function returns the host style token for a custom element if it\n * exists. Otherwise it returns null.\n *\n * A host style token is applied to the component if scoped styles are used.\n */\nfunction getStylesheetTokenHost(vnode) {\n    const { template } = getComponentInternalDef(vnode.ctor);\n    const { vm } = vnode;\n    const { stylesheetToken } = template;\n    return !isUndefined$1(stylesheetToken) && computeHasScopedStyles(template, vm)\n        ? makeHostToken(stylesheetToken)\n        : null;\n}\nfunction getNearestNativeShadowComponent(vm) {\n    const owner = getNearestShadowComponent(vm);\n    if (!isNull(owner) && owner.shadowMode === 1 /* ShadowMode.Synthetic */) {\n        // Synthetic-within-native is impossible. So if the nearest shadow component is\n        // synthetic, we know we won't find a native component if we go any further.\n        return null;\n    }\n    return owner;\n}\nfunction createStylesheet(vm, stylesheets) {\n    const { renderMode, shadowMode, renderer: { insertStylesheet }, } = vm;\n    if (renderMode === 1 /* RenderMode.Shadow */ && shadowMode === 1 /* ShadowMode.Synthetic */) {\n        for (let i = 0; i < stylesheets.length; i++) {\n            insertStylesheet(stylesheets[i]);\n        }\n    }\n    else if (vm.hydrated) {\n        // Note: We need to ensure that during hydration, the stylesheets method is the same as those in ssr.\n        //       This works in the client, because the stylesheets are created, and cached in the VM\n        //       the first time the VM renders.\n        // native shadow or light DOM, SSR\n        return ArrayMap.call(stylesheets, createInlineStyleVNode);\n    }\n    else {\n        // native shadow or light DOM, DOM renderer\n        const root = getNearestNativeShadowComponent(vm);\n        // null root means a global style\n        const target = isNull(root) ? undefined : root.shadowRoot;\n        for (let i = 0; i < stylesheets.length; i++) {\n            insertStylesheet(stylesheets[i], target);\n        }\n    }\n    return null;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction isVBaseElement(vnode) {\n    const { type } = vnode;\n    return type === 2 /* VNodeType.Element */ || type === 3 /* VNodeType.CustomElement */;\n}\nfunction isSameVnode(vnode1, vnode2) {\n    return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;\n}\nfunction isVCustomElement(vnode) {\n    return vnode.type === 3 /* VNodeType.CustomElement */;\n}\nfunction isVFragment(vnode) {\n    return vnode.type === 5 /* VNodeType.Fragment */;\n}\nfunction isVScopedSlotFragment(vnode) {\n    return vnode.type === 6 /* VNodeType.ScopedSlotFragment */;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ColonCharCode$1 = 58;\nfunction patchAttributes(oldVnode, vnode, renderer) {\n    const { attrs } = vnode.data;\n    if (isUndefined$1(attrs)) {\n        return;\n    }\n    const oldAttrs = isNull(oldVnode) ? EmptyObject : oldVnode.data.attrs;\n    if (oldAttrs === attrs) {\n        return;\n    }\n    const { elm } = vnode;\n    const { setAttribute, removeAttribute } = renderer;\n    for (const key in attrs) {\n        const cur = attrs[key];\n        const old = oldAttrs[key];\n        if (old !== cur) {\n            unlockAttribute(elm, key);\n            if (StringCharCodeAt.call(key, 3) === ColonCharCode$1) {\n                // Assume xml namespace\n                setAttribute(elm, key, cur, XML_NAMESPACE);\n            }\n            else if (StringCharCodeAt.call(key, 5) === ColonCharCode$1) {\n                // Assume xlink namespace\n                setAttribute(elm, key, cur, XLINK_NAMESPACE);\n            }\n            else if (isNull(cur) || isUndefined$1(cur)) {\n                removeAttribute(elm, key);\n            }\n            else {\n                setAttribute(elm, key, cur);\n            }\n            lockAttribute();\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ColonCharCode = 58;\nfunction patchAttrUnlessProp(oldVnode, vnode, renderer) {\n    const { data: { attrs }, elm, } = vnode;\n    if (isUndefined$1(attrs)) {\n        return;\n    }\n    const { removeAttribute, setAttribute, setProperty } = renderer;\n    const oldAttrs = isNull(oldVnode) ? EmptyObject : oldVnode.data.attrs;\n    for (const name in attrs) {\n        const cur = attrs[name];\n        const old = oldAttrs[name];\n        if (old !== cur) {\n            const propName = htmlAttributeToProperty(name);\n            if (propName in elm) {\n                setProperty(elm, name, cur);\n            }\n            else if (StringCharCodeAt.call(name, 3) === ColonCharCode) {\n                // Assume xml namespace\n                setAttribute(elm, name, cur, XML_NAMESPACE);\n            }\n            else if (StringCharCodeAt.call(name, 5) === ColonCharCode) {\n                // Assume xlink namespace\n                setAttribute(elm, name, cur, XLINK_NAMESPACE);\n            }\n            else if (isNull(cur) || isUndefined$1(cur)) {\n                removeAttribute(elm, name);\n            }\n            else {\n                setAttribute(elm, name, cur);\n            }\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction isLiveBindingProp(sel, key) {\n    // For properties with live bindings, we read values from the DOM element\n    // instead of relying on internally tracked values.\n    return sel === 'input' && (key === 'value' || key === 'checked');\n}\nfunction patchProps(oldVnode, vnode, renderer) {\n    let { props } = vnode.data;\n    const { spread } = vnode.data;\n    if (isUndefined$1(props) && isUndefined$1(spread)) {\n        return;\n    }\n    let oldProps;\n    if (!isNull(oldVnode)) {\n        oldProps = oldVnode.data.props;\n        const oldSpread = oldVnode.data.spread;\n        if (oldProps === props && oldSpread === spread) {\n            return;\n        }\n        if (isUndefined$1(oldProps)) {\n            oldProps = EmptyObject;\n        }\n        if (!isUndefined$1(oldSpread)) {\n            oldProps = assign({}, oldProps, oldSpread);\n        }\n    }\n    if (!isUndefined$1(spread)) {\n        props = assign({}, props, spread);\n    }\n    const isFirstPatch = isNull(oldVnode);\n    const { elm, sel } = vnode;\n    const { getProperty, setProperty } = renderer;\n    for (const key in props) {\n        const cur = props[key];\n        // Set the property if it's the first time is is patched or if the previous property is\n        // different than the one previously set.\n        if (isFirstPatch ||\n            cur !== (isLiveBindingProp(sel, key) ? getProperty(elm, key) : oldProps[key]) ||\n            !(key in oldProps) // this is required because the above case will pass when `cur` is `undefined` and key is missing in `oldProps`\n        ) {\n            // Additional verification if properties are supported by the element\n            // Validation relies on html properties and public properties being defined on the element,\n            // SSR has its own custom validation.\n            if (process.env.NODE_ENV !== 'production') {\n                if (!(key in elm)) {\n                    logWarn(`Unknown public property \"${key}\" of element <${elm.tagName.toLowerCase()}>. This is either a typo on the corresponding attribute \"${htmlPropertyToAttribute(key)}\", or the attribute does not exist in this browser or DOM implementation.`);\n                }\n            }\n            setProperty(elm, key, cur);\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst classNameToClassMap = create(null);\nfunction getMapFromClassName(className) {\n    // Intentionally using == to match undefined and null values from computed style attribute\n    if (className == null) {\n        return EmptyObject;\n    }\n    // computed class names must be string\n    className = isString(className) ? className : className + '';\n    let map = classNameToClassMap[className];\n    if (map) {\n        return map;\n    }\n    map = create(null);\n    let start = 0;\n    let o;\n    const len = className.length;\n    for (o = 0; o < len; o++) {\n        if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {\n            if (o > start) {\n                map[StringSlice.call(className, start, o)] = true;\n            }\n            start = o + 1;\n        }\n    }\n    if (o > start) {\n        map[StringSlice.call(className, start, o)] = true;\n    }\n    classNameToClassMap[className] = map;\n    if (process.env.NODE_ENV !== 'production') {\n        // just to make sure that this object never changes as part of the diffing algo\n        freeze(map);\n    }\n    return map;\n}\nfunction patchClassAttribute(oldVnode, vnode, renderer) {\n    const { elm, data: { className: newClass }, } = vnode;\n    const oldClass = isNull(oldVnode) ? undefined : oldVnode.data.className;\n    if (oldClass === newClass) {\n        return;\n    }\n    const { getClassList } = renderer;\n    const classList = getClassList(elm);\n    const newClassMap = getMapFromClassName(newClass);\n    const oldClassMap = getMapFromClassName(oldClass);\n    let name;\n    for (name in oldClassMap) {\n        // remove only if it is not in the new class collection and it is not set from within the instance\n        if (isUndefined$1(newClassMap[name])) {\n            classList.remove(name);\n        }\n    }\n    for (name in newClassMap) {\n        if (isUndefined$1(oldClassMap[name])) {\n            classList.add(name);\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The style property is a string when defined via an expression in the template.\nfunction patchStyleAttribute(oldVnode, vnode, renderer) {\n    const { elm, data: { style: newStyle }, } = vnode;\n    const oldStyle = isNull(oldVnode) ? undefined : oldVnode.data.style;\n    if (oldStyle === newStyle) {\n        return;\n    }\n    const { setAttribute, removeAttribute } = renderer;\n    if (!isString(newStyle) || newStyle === '') {\n        removeAttribute(elm, 'style');\n    }\n    else {\n        setAttribute(elm, 'style', newStyle);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction applyEventListeners(vnode, renderer) {\n    const { elm, data: { on }, } = vnode;\n    if (isUndefined$1(on)) {\n        return;\n    }\n    const { addEventListener } = renderer;\n    for (const name in on) {\n        const handler = on[name];\n        addEventListener(elm, name, handler);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The HTML class property becomes the vnode.data.classMap object when defined as a string in the template.\n// The compiler takes care of transforming the inline classnames into an object. It's faster to set the\n// different classnames properties individually instead of via a string.\nfunction applyStaticClassAttribute(vnode, renderer) {\n    const { elm, data: { classMap }, } = vnode;\n    if (isUndefined$1(classMap)) {\n        return;\n    }\n    const { getClassList } = renderer;\n    const classList = getClassList(elm);\n    for (const name in classMap) {\n        classList.add(name);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The HTML style property becomes the vnode.data.styleDecls object when defined as a string in the template.\n// The compiler takes care of transforming the inline style into an object. It's faster to set the\n// different style properties individually instead of via a string.\nfunction applyStaticStyleAttribute(vnode, renderer) {\n    const { elm, data: { styleDecls }, } = vnode;\n    if (isUndefined$1(styleDecls)) {\n        return;\n    }\n    const { setCSSStyleProperty } = renderer;\n    for (let i = 0; i < styleDecls.length; i++) {\n        const [prop, value, important] = styleDecls[i];\n        setCSSStyleProperty(elm, prop, value, important);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction patchChildren(c1, c2, parent, renderer) {\n    if (hasDynamicChildren(c2)) {\n        updateDynamicChildren(c1, c2, parent, renderer);\n    }\n    else {\n        updateStaticChildren(c1, c2, parent, renderer);\n    }\n}\nfunction patch(n1, n2, parent, renderer) {\n    var _a, _b;\n    if (n1 === n2) {\n        return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isSameVnode(n1, n2)) {\n            throw new Error('Expected these VNodes to be the same: ' +\n                JSON.stringify({ sel: n1.sel, key: n1.key }) +\n                ', ' +\n                JSON.stringify({ sel: n2.sel, key: n2.key }));\n        }\n    }\n    switch (n2.type) {\n        case 0 /* VNodeType.Text */:\n            // VText has no special capability, fallback to the owner's renderer\n            patchText(n1, n2, renderer);\n            break;\n        case 1 /* VNodeType.Comment */:\n            // VComment has no special capability, fallback to the owner's renderer\n            patchComment(n1, n2, renderer);\n            break;\n        case 4 /* VNodeType.Static */:\n            n2.elm = n1.elm;\n            break;\n        case 5 /* VNodeType.Fragment */:\n            patchFragment(n1, n2, parent, renderer);\n            break;\n        case 2 /* VNodeType.Element */:\n            patchElement(n1, n2, (_a = n2.data.renderer) !== null && _a !== void 0 ? _a : renderer);\n            break;\n        case 3 /* VNodeType.CustomElement */:\n            patchCustomElement(n1, n2, parent, (_b = n2.data.renderer) !== null && _b !== void 0 ? _b : renderer);\n            break;\n    }\n}\nfunction mount(node, parent, renderer, anchor) {\n    var _a, _b;\n    switch (node.type) {\n        case 0 /* VNodeType.Text */:\n            // VText has no special capability, fallback to the owner's renderer\n            mountText(node, parent, anchor, renderer);\n            break;\n        case 1 /* VNodeType.Comment */:\n            // VComment has no special capability, fallback to the owner's renderer\n            mountComment(node, parent, anchor, renderer);\n            break;\n        case 4 /* VNodeType.Static */:\n            // VStatic cannot have a custom renderer associated to them, using owner's renderer\n            mountStatic(node, parent, anchor, renderer);\n            break;\n        case 5 /* VNodeType.Fragment */:\n            mountFragment(node, parent, anchor, renderer);\n            break;\n        case 2 /* VNodeType.Element */:\n            // If the vnode data has a renderer override use it, else fallback to owner's renderer\n            mountElement(node, parent, anchor, (_a = node.data.renderer) !== null && _a !== void 0 ? _a : renderer);\n            break;\n        case 3 /* VNodeType.CustomElement */:\n            // If the vnode data has a renderer override use it, else fallback to owner's renderer\n            mountCustomElement(node, parent, anchor, (_b = node.data.renderer) !== null && _b !== void 0 ? _b : renderer);\n            break;\n    }\n}\nfunction patchText(n1, n2, renderer) {\n    n2.elm = n1.elm;\n    if (n2.text !== n1.text) {\n        updateTextContent(n2, renderer);\n    }\n}\nfunction mountText(vnode, parent, anchor, renderer) {\n    const { owner } = vnode;\n    const { createText } = renderer;\n    const textNode = (vnode.elm = createText(vnode.text));\n    linkNodeToShadow(textNode, owner, renderer);\n    insertNode(textNode, parent, anchor, renderer);\n}\nfunction patchComment(n1, n2, renderer) {\n    n2.elm = n1.elm;\n    // FIXME: Comment nodes should be static, we shouldn't need to diff them together. However\n    // it is the case today.\n    if (n2.text !== n1.text) {\n        updateTextContent(n2, renderer);\n    }\n}\nfunction mountComment(vnode, parent, anchor, renderer) {\n    const { owner } = vnode;\n    const { createComment } = renderer;\n    const commentNode = (vnode.elm = createComment(vnode.text));\n    linkNodeToShadow(commentNode, owner, renderer);\n    insertNode(commentNode, parent, anchor, renderer);\n}\nfunction mountFragment(vnode, parent, anchor, renderer) {\n    const { children } = vnode;\n    mountVNodes(children, parent, renderer, anchor);\n    // children of a fragment will always have at least the two delimiters.\n    vnode.elm = children[children.length - 1].elm;\n}\nfunction patchFragment(n1, n2, parent, renderer) {\n    const { children, stable } = n2;\n    if (stable) {\n        updateStaticChildren(n1.children, children, parent, renderer);\n    }\n    else {\n        updateDynamicChildren(n1.children, children, parent, renderer);\n    }\n    // Note: not reusing n1.elm, because during patching, it may be patched with another text node.\n    n2.elm = children[children.length - 1].elm;\n}\nfunction mountElement(vnode, parent, anchor, renderer) {\n    const { sel, owner, data: { svg }, } = vnode;\n    const { createElement } = renderer;\n    const namespace = isTrue(svg) ? SVG_NAMESPACE : undefined;\n    const elm = (vnode.elm = createElement(sel, namespace));\n    linkNodeToShadow(elm, owner, renderer);\n    applyStyleScoping(elm, owner, renderer);\n    applyDomManual(elm, vnode);\n    applyElementRestrictions(elm, vnode);\n    patchElementPropsAndAttrs$1(null, vnode, renderer);\n    insertNode(elm, parent, anchor, renderer);\n    mountVNodes(vnode.children, elm, renderer, null);\n}\nfunction patchElement(n1, n2, renderer) {\n    const elm = (n2.elm = n1.elm);\n    patchElementPropsAndAttrs$1(n1, n2, renderer);\n    patchChildren(n1.children, n2.children, elm, renderer);\n}\nfunction mountStatic(vnode, parent, anchor, renderer) {\n    const { owner } = vnode;\n    const { cloneNode, isSyntheticShadowDefined } = renderer;\n    const elm = (vnode.elm = cloneNode(vnode.fragment, true));\n    linkNodeToShadow(elm, owner, renderer);\n    applyElementRestrictions(elm, vnode);\n    // Marks this node as Static to propagate the shadow resolver. must happen after elm is assigned to the proper shadow\n    const { renderMode, shadowMode } = owner;\n    if (isSyntheticShadowDefined) {\n        if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {\n            elm[KEY__SHADOW_STATIC] = true;\n        }\n    }\n    insertNode(elm, parent, anchor, renderer);\n}\nfunction mountCustomElement(vnode, parent, anchor, renderer) {\n    const { sel, owner } = vnode;\n    const { createCustomElement } = renderer;\n    /**\n     * Note: if the upgradable constructor does not expect, or throw when we new it\n     * with a callback as the first argument, we could implement a more advanced\n     * mechanism that only passes that argument if the constructor is known to be\n     * an upgradable custom element.\n     */\n    let vm;\n    const upgradeCallback = (elm) => {\n        // the custom element from the registry is expecting an upgrade callback\n        vm = createViewModelHook(elm, vnode, renderer);\n    };\n    let connectedCallback;\n    let disconnectedCallback;\n    if (lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {\n        connectedCallback = (elm) => {\n            connectRootElement(elm);\n        };\n        disconnectedCallback = (elm) => {\n            disconnectRootElement(elm);\n        };\n    }\n    // Should never get a tag with upper case letter at this point; the compiler\n    // should produce only tags with lowercase letters. However, the Java\n    // compiler may generate tagnames with uppercase letters so - for backwards\n    // compatibility, we lower case the tagname here.\n    const normalizedTagname = sel.toLowerCase();\n    const elm = createCustomElement(normalizedTagname, upgradeCallback, connectedCallback, disconnectedCallback);\n    vnode.elm = elm;\n    vnode.vm = vm;\n    linkNodeToShadow(elm, owner, renderer);\n    applyStyleScoping(elm, owner, renderer);\n    if (vm) {\n        allocateChildren(vnode, vm);\n    }\n    patchElementPropsAndAttrs$1(null, vnode, renderer);\n    insertNode(elm, parent, anchor, renderer);\n    if (vm) {\n        {\n            if (!lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {\n                if (process.env.NODE_ENV !== 'production') {\n                    // With synthetic lifecycle callbacks, it's possible for elements to be removed without the engine\n                    // noticing it (e.g. `appendChild` the same host element twice). This test ensures we don't regress.\n                    assert.isTrue(vm.state === 0 /* VMState.created */, `${vm} cannot be recycled.`);\n                }\n                runConnectedCallback(vm);\n            }\n        }\n    }\n    mountVNodes(vnode.children, elm, renderer, null);\n    if (vm) {\n        appendVM(vm);\n    }\n}\nfunction patchCustomElement(n1, n2, parent, renderer) {\n    if (n1.ctor !== n2.ctor) {\n        // If the constructor, unmount the current component and mount a new one using the new\n        // constructor.\n        const anchor = renderer.nextSibling(n1.elm);\n        unmount(n1, parent, renderer, true);\n        mountCustomElement(n2, parent, anchor, renderer);\n    }\n    else {\n        // Otherwise patch the existing component with new props/attrs/etc.\n        const elm = (n2.elm = n1.elm);\n        const vm = (n2.vm = n1.vm);\n        patchElementPropsAndAttrs$1(n1, n2, renderer);\n        if (!isUndefined$1(vm)) {\n            // in fallback mode, the allocation will always set children to\n            // empty and delegate the real allocation to the slot elements\n            allocateChildren(n2, vm);\n            // Solves an edge case with slotted VFragments in native shadow mode.\n            //\n            // During allocation, in native shadow, slotted VFragment nodes are flattened and their text delimiters are removed\n            // to avoid interfering with native slot behavior. When this happens, if any of the fragments\n            // were not stable, the children must go through the dynamic diffing algo.\n            //\n            // If the new children (n2.children) contain no VFragments, but the previous children (n1.children) were dynamic,\n            // the new nodes must be marked dynamic so that all nodes are properly updated. The only indicator that the new\n            // nodes need to be dynamic comes from the previous children, so we check that to determine whether we need to\n            // mark the new children dynamic.\n            //\n            // Example:\n            // n1.children: [div, VFragment('', div, null, ''), div] => [div, div, null, div]; // marked dynamic\n            // n2.children: [div, null, div] => [div, null, div] // marked ???\n            const { shadowMode, renderMode } = vm;\n            if (shadowMode == 0 /* ShadowMode.Native */ &&\n                renderMode !== 0 /* RenderMode.Light */ &&\n                hasDynamicChildren(n1.children)) {\n                // No-op if children has already been marked dynamic by 'allocateChildren()'.\n                markAsDynamicChildren(n2.children);\n            }\n        }\n        // in fallback mode, the children will be always empty, so, nothing\n        // will happen, but in native, it does allocate the light dom\n        patchChildren(n1.children, n2.children, elm, renderer);\n        if (!isUndefined$1(vm)) {\n            // this will probably update the shadowRoot, but only if the vm is in a dirty state\n            // this is important to preserve the top to bottom synchronous rendering phase.\n            rerenderVM(vm);\n        }\n    }\n}\nfunction mountVNodes(vnodes, parent, renderer, anchor, start = 0, end = vnodes.length) {\n    for (; start < end; ++start) {\n        const vnode = vnodes[start];\n        if (isVNode(vnode)) {\n            mount(vnode, parent, renderer, anchor);\n        }\n    }\n}\nfunction unmount(vnode, parent, renderer, doRemove = false) {\n    const { type, elm, sel } = vnode;\n    // When unmounting a VNode subtree not all the elements have to removed from the DOM. The\n    // subtree root, is the only element worth unmounting from the subtree.\n    if (doRemove) {\n        if (type === 5 /* VNodeType.Fragment */) {\n            unmountVNodes(vnode.children, parent, renderer, doRemove);\n        }\n        else {\n            // The vnode might or might not have a data.renderer associated to it\n            // but the removal used here is from the owner instead.\n            removeNode(elm, parent, renderer);\n        }\n    }\n    switch (type) {\n        case 2 /* VNodeType.Element */: {\n            // Slot content is removed to trigger slotchange event when removing slot.\n            // Only required for synthetic shadow.\n            const shouldRemoveChildren = sel === 'slot' && vnode.owner.shadowMode === 1 /* ShadowMode.Synthetic */;\n            unmountVNodes(vnode.children, elm, renderer, shouldRemoveChildren);\n            break;\n        }\n        case 3 /* VNodeType.CustomElement */: {\n            const { vm } = vnode;\n            // No need to unmount the children here, `removeVM` will take care of removing the\n            // children.\n            if (!isUndefined$1(vm)) {\n                removeVM(vm);\n            }\n        }\n    }\n}\nfunction unmountVNodes(vnodes, parent, renderer, doRemove = false, start = 0, end = vnodes.length) {\n    for (; start < end; ++start) {\n        const ch = vnodes[start];\n        if (isVNode(ch)) {\n            unmount(ch, parent, renderer, doRemove);\n        }\n    }\n}\nfunction isVNode(vnode) {\n    return vnode != null;\n}\nfunction linkNodeToShadow(elm, owner, renderer) {\n    const { renderRoot, renderMode, shadowMode } = owner;\n    const { isSyntheticShadowDefined } = renderer;\n    // TODO [#1164]: this should eventually be done by the polyfill directly\n    if (isSyntheticShadowDefined) {\n        if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {\n            elm[KEY__SHADOW_RESOLVER] = renderRoot[KEY__SHADOW_RESOLVER];\n        }\n    }\n}\nfunction updateTextContent(vnode, renderer) {\n    const { elm, text } = vnode;\n    const { setText } = renderer;\n    if (process.env.NODE_ENV !== 'production') {\n        unlockDomMutation();\n    }\n    setText(elm, text);\n    if (process.env.NODE_ENV !== 'production') {\n        lockDomMutation();\n    }\n}\nfunction insertNode(node, parent, anchor, renderer) {\n    if (process.env.NODE_ENV !== 'production') {\n        unlockDomMutation();\n    }\n    renderer.insert(node, parent, anchor);\n    if (process.env.NODE_ENV !== 'production') {\n        lockDomMutation();\n    }\n}\nfunction removeNode(node, parent, renderer) {\n    if (process.env.NODE_ENV !== 'production') {\n        unlockDomMutation();\n    }\n    renderer.remove(node, parent);\n    if (process.env.NODE_ENV !== 'production') {\n        lockDomMutation();\n    }\n}\nfunction patchElementPropsAndAttrs$1(oldVnode, vnode, renderer) {\n    if (isNull(oldVnode)) {\n        applyEventListeners(vnode, renderer);\n        applyStaticClassAttribute(vnode, renderer);\n        applyStaticStyleAttribute(vnode, renderer);\n    }\n    // Attrs need to be applied to element before props IE11 will wipe out value on radio inputs if\n    // value is set before type=radio.\n    patchClassAttribute(oldVnode, vnode, renderer);\n    patchStyleAttribute(oldVnode, vnode, renderer);\n    if (vnode.data.external) {\n        patchAttrUnlessProp(oldVnode, vnode, renderer);\n    }\n    else {\n        patchAttributes(oldVnode, vnode, renderer);\n    }\n    patchProps(oldVnode, vnode, renderer);\n}\nfunction applyStyleScoping(elm, owner, renderer) {\n    // Set the class name for `*.scoped.css` style scoping.\n    const scopeToken = getScopeTokenClass(owner);\n    if (!isNull(scopeToken)) {\n        const { getClassList } = renderer;\n        // TODO [#2762]: this dot notation with add is probably problematic\n        // probably we should have a renderer api for just the add operation\n        getClassList(elm).add(scopeToken);\n    }\n    // Set property element for synthetic shadow DOM style scoping.\n    const { stylesheetToken: syntheticToken } = owner.context;\n    if (owner.shadowMode === 1 /* ShadowMode.Synthetic */ && !isUndefined$1(syntheticToken)) {\n        elm.$shadowToken$ = syntheticToken;\n    }\n}\nfunction applyDomManual(elm, vnode) {\n    var _a;\n    const { owner, data: { context }, } = vnode;\n    if (owner.shadowMode === 1 /* ShadowMode.Synthetic */ && ((_a = context === null || context === void 0 ? void 0 : context.lwc) === null || _a === void 0 ? void 0 : _a.dom) === \"manual\" /* LwcDomMode.Manual */) {\n        elm.$domManual$ = true;\n    }\n}\nfunction applyElementRestrictions(elm, vnode) {\n    var _a, _b;\n    if (process.env.NODE_ENV !== 'production') {\n        const isSynthetic = vnode.owner.shadowMode === 1 /* ShadowMode.Synthetic */;\n        const isPortal = vnode.type === 2 /* VNodeType.Element */ && ((_b = (_a = vnode.data.context) === null || _a === void 0 ? void 0 : _a.lwc) === null || _b === void 0 ? void 0 : _b.dom) === \"manual\" /* LwcDomMode.Manual */;\n        const isLight = vnode.owner.renderMode === 0 /* RenderMode.Light */;\n        patchElementWithRestrictions(elm, {\n            isPortal,\n            isLight,\n            isSynthetic,\n        });\n    }\n}\nfunction allocateChildren(vnode, vm) {\n    // A component with slots will re-render because:\n    // 1- There is a change of the internal state.\n    // 2- There is a change on the external api (ex: slots)\n    //\n    // In case #1, the vnodes in the cmpSlots will be reused since they didn't changed. This routine emptied the\n    // slotted children when those VCustomElement were rendered and therefore in subsequent calls to allocate children\n    // in a reused VCustomElement, there won't be any slotted children.\n    // For those cases, we will use the reference for allocated children stored when rendering the fresh VCustomElement.\n    //\n    // In case #2, we will always get a fresh VCustomElement.\n    const children = vnode.aChildren || vnode.children;\n    const { renderMode, shadowMode } = vm;\n    if (process.env.NODE_ENV !== 'production') {\n        // If any of the children being allocated is a scoped slot fragment, make sure the receiving\n        // component is a light DOM component. This is mainly to validate light dom parent running\n        // in native shadow mode.\n        if (renderMode !== 0 /* RenderMode.Light */ &&\n            ArraySome.call(children, (child) => !isNull(child) && isVScopedSlotFragment(child))) {\n            logError(`Invalid usage of 'lwc:slot-data' on ${getComponentTag(vm)} tag. Scoped slot content can only be passed to a light dom child.`);\n        }\n    }\n    // If any of the children being allocated are VFragments, we remove the text delimiters and flatten all immediate\n    // children VFragments to avoid them interfering with default slot behavior.\n    const allocatedChildren = flattenFragmentsInChildren(children);\n    vnode.children = allocatedChildren;\n    vm.aChildren = allocatedChildren;\n    if (shadowMode === 1 /* ShadowMode.Synthetic */ || renderMode === 0 /* RenderMode.Light */) {\n        // slow path\n        allocateInSlot(vm, allocatedChildren, vnode.owner);\n        // save the allocated children in case this vnode is reused.\n        vnode.aChildren = allocatedChildren;\n        // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!\n        vnode.children = EmptyArray;\n    }\n}\n/**\n * Flattens the contents of all VFragments in an array of VNodes, removes the text delimiters on those VFragments, and\n * marks the resulting children array as dynamic. Uses a stack (array) to iteratively traverse the nested VFragments\n * and avoid the perf overhead of creating/destroying throwaway arrays/objects in a recursive approach.\n *\n * With the delimiters removed, the contents are marked dynamic so they are diffed correctly.\n *\n * This function is used for slotted VFragments to avoid the text delimiters interfering with slotting functionality.\n */\nfunction flattenFragmentsInChildren(children) {\n    const flattenedChildren = [];\n    // Initialize our stack with the direct children of the custom component and check whether we have a VFragment.\n    // If no VFragment is found in children, we don't need to traverse anything or mark the children dynamic and can return early.\n    const nodeStack = [];\n    let fragmentFound = false;\n    for (let i = children.length - 1; i > -1; i -= 1) {\n        const child = children[i];\n        ArrayPush$1.call(nodeStack, child);\n        fragmentFound = fragmentFound || !!(child && isVFragment(child));\n    }\n    if (!fragmentFound) {\n        return children;\n    }\n    let currentNode;\n    while (!isUndefined$1((currentNode = ArrayPop.call(nodeStack)))) {\n        if (!isNull(currentNode) && isVFragment(currentNode)) {\n            const fChildren = currentNode.children;\n            // Ignore the start and end text node delimiters\n            for (let i = fChildren.length - 2; i > 0; i -= 1) {\n                ArrayPush$1.call(nodeStack, fChildren[i]);\n            }\n        }\n        else {\n            ArrayPush$1.call(flattenedChildren, currentNode);\n        }\n    }\n    // We always mark the children as dynamic because nothing generates stable VFragments yet.\n    // If/when stable VFragments are generated by the compiler, this code should be updated to\n    // not mark dynamic if all flattened VFragments were stable.\n    markAsDynamicChildren(flattenedChildren);\n    return flattenedChildren;\n}\nfunction createViewModelHook(elm, vnode, renderer) {\n    let vm = getAssociatedVMIfPresent(elm);\n    // There is a possibility that a custom element is registered under tagName, in which case, the\n    // initialization is already carry on, and there is nothing else to do here since this hook is\n    // called right after invoking `document.createElement`.\n    if (!isUndefined$1(vm)) {\n        return vm;\n    }\n    const { sel, mode, ctor, owner } = vnode;\n    vm = createVM(elm, ctor, renderer, {\n        mode,\n        owner,\n        tagName: sel,\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isArray$1(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n    }\n    return vm;\n}\nfunction allocateInSlot(vm, children, owner) {\n    var _a, _b;\n    const { cmpSlots: { slotAssignments: oldSlotsMapping }, } = vm;\n    const cmpSlotsMapping = create(null);\n    // Collect all slots into cmpSlotsMapping\n    for (let i = 0, len = children.length; i < len; i += 1) {\n        const vnode = children[i];\n        if (isNull(vnode)) {\n            continue;\n        }\n        let slotName = '';\n        if (isVBaseElement(vnode)) {\n            slotName = (_b = (_a = vnode.data.attrs) === null || _a === void 0 ? void 0 : _a.slot) !== null && _b !== void 0 ? _b : '';\n        }\n        else if (isVScopedSlotFragment(vnode)) {\n            slotName = vnode.slotName;\n        }\n        // Can't use toString here because Symbol(1).toString() is 'Symbol(1)'\n        // but elm.setAttribute('slot', Symbol(1)) is an error.\n        // the following line also throws same error for symbols\n        // Similar for Object.create(null)\n        const normalizedSlotName = '' + slotName;\n        const vnodes = (cmpSlotsMapping[normalizedSlotName] =\n            cmpSlotsMapping[normalizedSlotName] || []);\n        ArrayPush$1.call(vnodes, vnode);\n    }\n    vm.cmpSlots = { owner, slotAssignments: cmpSlotsMapping };\n    if (isFalse(vm.isDirty)) {\n        // We need to determine if the old allocation is really different from the new one\n        // and mark the vm as dirty\n        const oldKeys = keys(oldSlotsMapping);\n        if (oldKeys.length !== keys(cmpSlotsMapping).length) {\n            markComponentAsDirty(vm);\n            return;\n        }\n        for (let i = 0, len = oldKeys.length; i < len; i += 1) {\n            const key = oldKeys[i];\n            if (isUndefined$1(cmpSlotsMapping[key]) ||\n                oldSlotsMapping[key].length !== cmpSlotsMapping[key].length) {\n                markComponentAsDirty(vm);\n                return;\n            }\n            const oldVNodes = oldSlotsMapping[key];\n            const vnodes = cmpSlotsMapping[key];\n            for (let j = 0, a = cmpSlotsMapping[key].length; j < a; j += 1) {\n                if (oldVNodes[j] !== vnodes[j]) {\n                    markComponentAsDirty(vm);\n                    return;\n                }\n            }\n        }\n    }\n}\n// Using a WeakMap instead of a WeakSet because this one works in IE11 :(\nconst DynamicChildren = new WeakMap();\n// dynamic children means it was either generated by an iteration in a template\n// or part of an unstable fragment, and will require a more complex diffing algo.\nfunction markAsDynamicChildren(children) {\n    DynamicChildren.set(children, 1);\n}\nfunction hasDynamicChildren(children) {\n    return DynamicChildren.has(children);\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    const map = {};\n    // TODO [#1637]: simplify this by assuming that all vnodes has keys\n    for (let j = beginIdx; j <= endIdx; ++j) {\n        const ch = children[j];\n        if (isVNode(ch)) {\n            const { key } = ch;\n            if (key !== undefined) {\n                map[key] = j;\n            }\n        }\n    }\n    return map;\n}\nfunction updateDynamicChildren(oldCh, newCh, parent, renderer) {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    const newChEnd = newCh.length - 1;\n    let newEndIdx = newChEnd;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let oldKeyToIdx;\n    let idxInOld;\n    let elmToMove;\n    let before;\n    let clonedOldCh = false;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (!isVNode(oldStartVnode)) {\n            oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n        }\n        else if (!isVNode(oldEndVnode)) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (!isVNode(newStartVnode)) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (!isVNode(newEndVnode)) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            patch(oldStartVnode, newStartVnode, parent, renderer);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            patch(oldEndVnode, newEndVnode, parent, renderer);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            patch(oldStartVnode, newEndVnode, parent, renderer);\n            insertNode(oldStartVnode.elm, parent, renderer.nextSibling(oldEndVnode.elm), renderer);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            patch(oldEndVnode, newStartVnode, parent, renderer);\n            insertNode(newStartVnode.elm, parent, oldStartVnode.elm, renderer);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            if (oldKeyToIdx === undefined) {\n                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n            }\n            idxInOld = oldKeyToIdx[newStartVnode.key];\n            if (isUndefined$1(idxInOld)) {\n                // New element\n                mount(newStartVnode, parent, renderer, oldStartVnode.elm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                elmToMove = oldCh[idxInOld];\n                if (isVNode(elmToMove)) {\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        // New element\n                        mount(newStartVnode, parent, renderer, oldStartVnode.elm);\n                    }\n                    else {\n                        patch(elmToMove, newStartVnode, parent, renderer);\n                        // Delete the old child, but copy the array since it is read-only.\n                        // The `oldCh` will be GC'ed after `updateDynamicChildren` is complete,\n                        // so we only care about the `oldCh` object inside this function.\n                        // To avoid cloning over and over again, we check `clonedOldCh`\n                        // and only clone once.\n                        if (!clonedOldCh) {\n                            clonedOldCh = true;\n                            oldCh = [...oldCh];\n                        }\n                        // We've already cloned at least once, so it's no longer read-only\n                        oldCh[idxInOld] = undefined;\n                        insertNode(elmToMove.elm, parent, oldStartVnode.elm, renderer);\n                    }\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n        }\n    }\n    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n        if (oldStartIdx > oldEndIdx) {\n            // There's some cases in which the sub array of vnodes to be inserted is followed by null(s) and an\n            // already processed vnode, in such cases the vnodes to be inserted should be before that processed vnode.\n            let i = newEndIdx;\n            let n;\n            do {\n                n = newCh[++i];\n            } while (!isVNode(n) && i < newChEnd);\n            before = isVNode(n) ? n.elm : null;\n            mountVNodes(newCh, parent, renderer, before, newStartIdx, newEndIdx + 1);\n        }\n        else {\n            unmountVNodes(oldCh, parent, renderer, true, oldStartIdx, oldEndIdx + 1);\n        }\n    }\n}\nfunction updateStaticChildren(c1, c2, parent, renderer) {\n    const c1Length = c1.length;\n    const c2Length = c2.length;\n    if (c1Length === 0) {\n        // the old list is empty, we can directly insert anything new\n        mountVNodes(c2, parent, renderer, null);\n        return;\n    }\n    if (c2Length === 0) {\n        // the old list is nonempty and the new list is empty so we can directly remove all old nodes\n        // this is the case in which the dynamic children of an if-directive should be removed\n        unmountVNodes(c1, parent, renderer, true);\n        return;\n    }\n    // if the old list is not empty, the new list MUST have the same\n    // amount of nodes, that's why we call this static children\n    let anchor = null;\n    for (let i = c2Length - 1; i >= 0; i -= 1) {\n        const n1 = c1[i];\n        const n2 = c2[i];\n        if (n2 !== n1) {\n            if (isVNode(n1)) {\n                if (isVNode(n2)) {\n                    // both vnodes are equivalent, and we just need to patch them\n                    patch(n1, n2, parent, renderer);\n                    anchor = n2.elm;\n                }\n                else {\n                    // removing the old vnode since the new one is null\n                    unmount(n1, parent, renderer, true);\n                }\n            }\n            else if (isVNode(n2)) {\n                mount(n2, parent, renderer, anchor);\n                anchor = n2.elm;\n            }\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst SymbolIterator = Symbol.iterator;\nfunction addVNodeToChildLWC(vnode) {\n    ArrayPush$1.call(getVMBeingRendered().velements, vnode);\n}\n// [s]coped [s]lot [f]actory\nfunction ssf(slotName, factory) {\n    return {\n        type: 6 /* VNodeType.ScopedSlotFragment */,\n        factory,\n        owner: getVMBeingRendered(),\n        elm: undefined,\n        sel: undefined,\n        key: undefined,\n        slotName,\n    };\n}\n// [st]atic node\nfunction st(fragment, key) {\n    return {\n        type: 4 /* VNodeType.Static */,\n        sel: undefined,\n        key,\n        elm: undefined,\n        fragment,\n        owner: getVMBeingRendered(),\n    };\n}\n// [fr]agment node\nfunction fr(key, children, stable) {\n    return {\n        type: 5 /* VNodeType.Fragment */,\n        sel: undefined,\n        key,\n        elm: undefined,\n        children: [t(''), ...children, t('')],\n        stable,\n        owner: getVMBeingRendered(),\n    };\n}\n// [h]tml node\nfunction h(sel, data, children = EmptyArray) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isString(sel), `h() 1st argument sel must be a string.`);\n        assert.isTrue(isObject(data), `h() 2nd argument data must be an object.`);\n        assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);\n        assert.isTrue('key' in data, ` <${sel}> \"key\" attribute is invalid or missing for ${vmBeingRendered}. Key inside iterator is either undefined or null.`);\n        // checking reserved internal data properties\n        assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n        assert.isFalse(data.styleDecls && data.style, `vnode.data.styleDecls and vnode.data.style ambiguous declaration.`);\n        if (data.style && !isString(data.style)) {\n            logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);\n        }\n        forEach.call(children, (childVnode) => {\n            if (childVnode != null) {\n                assert.isTrue('type' in childVnode &&\n                    'sel' in childVnode &&\n                    'elm' in childVnode &&\n                    'key' in childVnode, `${childVnode} is not a vnode.`);\n            }\n        });\n    }\n    const { key, ref } = data;\n    const vnode = {\n        type: 2 /* VNodeType.Element */,\n        sel,\n        data,\n        children,\n        elm: undefined,\n        key,\n        owner: vmBeingRendered,\n    };\n    if (!isUndefined$1(ref)) {\n        setRefVNode(vmBeingRendered, ref, vnode);\n    }\n    return vnode;\n}\n// [t]ab[i]ndex function\nfunction ti(value) {\n    // if value is greater than 0, we normalize to 0\n    // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through\n    // If value is less than -1, we don't care\n    const shouldNormalize = value > 0 && !(isTrue(value) || isFalse(value));\n    if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        if (shouldNormalize) {\n            logError(`Invalid tabindex value \\`${toString$1(value)}\\` in template for ${vmBeingRendered}. This attribute must be set to 0 or -1.`, vmBeingRendered);\n        }\n    }\n    return shouldNormalize ? 0 : value;\n}\n// [s]lot element node\nfunction s(slotName, data, children, slotset) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isString(slotName), `s() 1st argument slotName must be a string.`);\n        assert.isTrue(isObject(data), `s() 2nd argument data must be an object.`);\n        assert.isTrue(isArray$1(children), `h() 3rd argument children must be an array.`);\n    }\n    if (!isUndefined$1(slotset) &&\n        !isUndefined$1(slotset.slotAssignments) &&\n        !isUndefined$1(slotset.slotAssignments[slotName]) &&\n        slotset.slotAssignments[slotName].length !== 0) {\n        const newChildren = [];\n        const slotAssignments = slotset.slotAssignments[slotName];\n        for (let i = 0; i < slotAssignments.length; i++) {\n            const vnode = slotAssignments[i];\n            if (!isNull(vnode)) {\n                const assignedNodeIsScopedSlot = isVScopedSlotFragment(vnode);\n                // The only sniff test for a scoped <slot> element is the presence of `slotData`\n                const isScopedSlotElement = !isUndefined$1(data.slotData);\n                // Check if slot types of parent and child are matching\n                if (assignedNodeIsScopedSlot !== isScopedSlotElement) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logError(`Mismatched slot types for ${slotName === '' ? '(default)' : slotName} slot. Both parent and child component must use standard type or scoped type for a given slot.`, slotset.owner);\n                    }\n                    // Ignore slot content from parent\n                    continue;\n                }\n                // If the passed slot content is factory, evaluate it and add the produced vnodes\n                if (assignedNodeIsScopedSlot) {\n                    const vmBeingRenderedInception = getVMBeingRendered();\n                    // Evaluate in the scope of the slot content's owner\n                    // if a slotset is provided, there will always be an owner. The only case where owner is\n                    // undefined is for root components, but root components cannot accept slotted content\n                    setVMBeingRendered(slotset.owner);\n                    try {\n                        ArrayPush$1.call(newChildren, vnode.factory(data.slotData, data.key));\n                    }\n                    finally {\n                        setVMBeingRendered(vmBeingRenderedInception);\n                    }\n                }\n                else {\n                    // If the slot content is standard type, the content is static, no additional\n                    // processing needed on the vnode\n                    ArrayPush$1.call(newChildren, vnode);\n                }\n            }\n        }\n        children = newChildren;\n    }\n    const vmBeingRendered = getVMBeingRendered();\n    const { renderMode, shadowMode } = vmBeingRendered;\n    if (renderMode === 0 /* RenderMode.Light */) {\n        sc(children);\n        return children;\n    }\n    if (shadowMode === 1 /* ShadowMode.Synthetic */) {\n        // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n        sc(children);\n    }\n    return h('slot', data, children);\n}\n// [c]ustom element node\nfunction c(sel, Ctor, data, children = EmptyArray) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isString(sel), `c() 1st argument sel must be a string.`);\n        assert.isTrue(isFunction$1(Ctor), `c() 2nd argument Ctor must be a function.`);\n        assert.isTrue(isObject(data), `c() 3nd argument data must be an object.`);\n        assert.isTrue(arguments.length === 3 || isArray$1(children), `c() 4nd argument data must be an array.`);\n        // checking reserved internal data properties\n        assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n        assert.isFalse(data.styleDecls && data.style, `vnode.data.styleDecls and vnode.data.style ambiguous declaration.`);\n        if (data.style && !isString(data.style)) {\n            logError(`Invalid 'style' attribute passed to <${sel}> is ignored. This attribute must be a string value.`, vmBeingRendered);\n        }\n        if (arguments.length === 4) {\n            forEach.call(children, (childVnode) => {\n                if (childVnode != null) {\n                    assert.isTrue('type' in childVnode &&\n                        'sel' in childVnode &&\n                        'elm' in childVnode &&\n                        'key' in childVnode, `${childVnode} is not a vnode.`);\n                }\n            });\n        }\n    }\n    const { key, ref } = data;\n    let elm, aChildren, vm;\n    const vnode = {\n        type: 3 /* VNodeType.CustomElement */,\n        sel,\n        data,\n        children,\n        elm,\n        key,\n        ctor: Ctor,\n        owner: vmBeingRendered,\n        mode: 'open',\n        aChildren,\n        vm,\n    };\n    addVNodeToChildLWC(vnode);\n    if (!isUndefined$1(ref)) {\n        setRefVNode(vmBeingRendered, ref, vnode);\n    }\n    return vnode;\n}\n// [i]terable node\nfunction i(iterable, factory) {\n    const list = [];\n    // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n    sc(list);\n    const vmBeingRendered = getVMBeingRendered();\n    if (isUndefined$1(iterable) || iterable === null) {\n        if (process.env.NODE_ENV !== 'production') {\n            logError(`Invalid template iteration for value \"${toString$1(iterable)}\" in ${vmBeingRendered}. It must be an Array or an iterable Object.`, vmBeingRendered);\n        }\n        return list;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isFalse(isUndefined$1(iterable[SymbolIterator]), `Invalid template iteration for value \\`${toString$1(iterable)}\\` in ${vmBeingRendered}. It must be an array-like object and not \\`null\\` nor \\`undefined\\`.`);\n    }\n    const iterator = iterable[SymbolIterator]();\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(iterator && isFunction$1(iterator.next), `Invalid iterator function for \"${toString$1(iterable)}\" in ${vmBeingRendered}.`);\n    }\n    let next = iterator.next();\n    let j = 0;\n    let { value, done: last } = next;\n    let keyMap;\n    let iterationError;\n    if (process.env.NODE_ENV !== 'production') {\n        keyMap = create(null);\n    }\n    while (last === false) {\n        // implementing a look-back-approach because we need to know if the element is the last\n        next = iterator.next();\n        last = next.done;\n        // template factory logic based on the previous collected value\n        const vnode = factory(value, j, j === 0, last === true);\n        if (isArray$1(vnode)) {\n            ArrayPush$1.apply(list, vnode);\n        }\n        else {\n            ArrayPush$1.call(list, vnode);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            const vnodes = isArray$1(vnode) ? vnode : [vnode];\n            forEach.call(vnodes, (childVnode) => {\n                if (!isNull(childVnode) && isObject(childVnode) && !isUndefined$1(childVnode.sel)) {\n                    const { key } = childVnode;\n                    if (isString(key) || isNumber(key)) {\n                        if (keyMap[key] === 1 && isUndefined$1(iterationError)) {\n                            iterationError = `Duplicated \"key\" attribute value for \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. A key with value \"${childVnode.key}\" appears more than once in the iteration. Key values must be unique numbers or strings.`;\n                        }\n                        keyMap[key] = 1;\n                    }\n                    else if (isUndefined$1(iterationError)) {\n                        iterationError = `Invalid \"key\" attribute value in \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. Set a unique \"key\" value on all iterated child elements.`;\n                    }\n                }\n            });\n        }\n        // preparing next value\n        j += 1;\n        value = next.value;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isUndefined$1(iterationError)) {\n            logError(iterationError, vmBeingRendered);\n        }\n    }\n    return list;\n}\n/**\n * [f]lattening\n */\nfunction f(items) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isArray$1(items), 'flattening api can only work with arrays.');\n    }\n    const len = items.length;\n    const flattened = [];\n    // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic\n    sc(flattened);\n    for (let j = 0; j < len; j += 1) {\n        const item = items[j];\n        if (isArray$1(item)) {\n            ArrayPush$1.apply(flattened, item);\n        }\n        else {\n            ArrayPush$1.call(flattened, item);\n        }\n    }\n    return flattened;\n}\n// [t]ext node\nfunction t(text) {\n    let sel, key, elm;\n    return {\n        type: 0 /* VNodeType.Text */,\n        sel,\n        text,\n        elm,\n        key,\n        owner: getVMBeingRendered(),\n    };\n}\n// [co]mment node\nfunction co(text) {\n    let sel, elm;\n    return {\n        type: 1 /* VNodeType.Comment */,\n        sel,\n        text,\n        elm,\n        key: 'c',\n        owner: getVMBeingRendered(),\n    };\n}\n// [d]ynamic text\nfunction d(value) {\n    return value == null ? '' : String(value);\n}\n// [b]ind function\nfunction b(fn) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (isNull(vmBeingRendered)) {\n        throw new Error();\n    }\n    const vm = vmBeingRendered;\n    return function (event) {\n        invokeEventListener(vm, fn, vm.component, event);\n    };\n}\n// [k]ey function\nfunction k(compilerKey, obj) {\n    switch (typeof obj) {\n        case 'number':\n        case 'string':\n            return compilerKey + ':' + obj;\n        case 'object':\n            if (process.env.NODE_ENV !== 'production') {\n                assert.fail(`Invalid key value \"${obj}\" in ${getVMBeingRendered()}. Key must be a string or number.`);\n            }\n    }\n}\n// [g]lobal [id] function\nfunction gid(id) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (isUndefined$1(id) || id === '') {\n        if (process.env.NODE_ENV !== 'production') {\n            logError(`Invalid id value \"${id}\". The id attribute must contain a non-empty string.`, vmBeingRendered);\n        }\n        return id;\n    }\n    // We remove attributes when they are assigned a value of null\n    if (isNull(id)) {\n        return null;\n    }\n    const { idx, shadowMode } = vmBeingRendered;\n    if (shadowMode === 1 /* ShadowMode.Synthetic */) {\n        return StringReplace.call(id, /\\S+/g, (id) => `${id}-${idx}`);\n    }\n    return id;\n}\n// [f]ragment [id] function\nfunction fid(url) {\n    const vmBeingRendered = getVMBeingRendered();\n    if (isUndefined$1(url) || url === '') {\n        if (process.env.NODE_ENV !== 'production') {\n            if (isUndefined$1(url)) {\n                logError(`Undefined url value for \"href\" or \"xlink:href\" attribute. Expected a non-empty string.`, vmBeingRendered);\n            }\n        }\n        return url;\n    }\n    // We remove attributes when they are assigned a value of null\n    if (isNull(url)) {\n        return null;\n    }\n    const { idx, shadowMode } = vmBeingRendered;\n    // Apply transformation only for fragment-only-urls, and only in shadow DOM\n    if (shadowMode === 1 /* ShadowMode.Synthetic */ && /^#/.test(url)) {\n        return `${url}-${idx}`;\n    }\n    return url;\n}\n/**\n * create a dynamic component via `<x-foo lwc:dynamic={Ctor}>`\n */\nfunction dc(sel, Ctor, data, children = EmptyArray) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isString(sel), `dc() 1st argument sel must be a string.`);\n        assert.isTrue(isObject(data), `dc() 3nd argument data must be an object.`);\n        assert.isTrue(arguments.length === 3 || isArray$1(children), `dc() 4nd argument data must be an array.`);\n    }\n    // null or undefined values should produce a null value in the VNodes\n    if (Ctor == null) {\n        return null;\n    }\n    if (!isComponentConstructor(Ctor)) {\n        throw new Error(`Invalid LWC Constructor ${toString$1(Ctor)} for custom element <${sel}>.`);\n    }\n    return c(sel, Ctor, data, children);\n}\n/**\n * slow children collection marking mechanism. this API allows the compiler to signal\n * to the engine that a particular collection of children must be diffed using the slow\n * algo based on keys due to the nature of the list. E.g.:\n *\n *   - slot element's children: the content of the slot has to be dynamic when in synthetic\n *                              shadow mode because the `vnode.children` might be the slotted\n *                              content vs default content, in which case the size and the\n *                              keys are not matching.\n *   - children that contain dynamic components\n *   - children that are produced by iteration\n *\n */\nfunction sc(vnodes) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isArray$1(vnodes), 'sc() api can only work with arrays.');\n    }\n    // We have to mark the vnodes collection as dynamic so we can later on\n    // choose to use the snabbdom virtual dom diffing algo instead of our\n    // static dummy algo.\n    markAsDynamicChildren(vnodes);\n    return vnodes;\n}\n/**\n * EXPERIMENTAL: This function acts like a hook for Lightning Locker Service and other similar\n * libraries to sanitize HTML content. This hook process the content passed via the template to\n * lwc:inner-html directive.\n * It is meant to be overridden with setSanitizeHtmlContentHook, it throws an error by default.\n */\nlet sanitizeHtmlContentHook = () => {\n    // locker-service patches this function during runtime to sanitize HTML content.\n    throw new Error('sanitizeHtmlContent hook must be implemented.');\n};\n/**\n * Sets the sanitizeHtmlContentHook.\n */\nfunction setSanitizeHtmlContentHook(newHookImpl) {\n    sanitizeHtmlContentHook = newHookImpl;\n}\n// [s]anitize [h]tml [c]ontent\nfunction shc(content) {\n    return sanitizeHtmlContentHook(content);\n}\nconst api = freeze({\n    s,\n    h,\n    c,\n    i,\n    f,\n    t,\n    d,\n    b,\n    k,\n    co,\n    dc,\n    fr,\n    ti,\n    st,\n    gid,\n    fid,\n    shc,\n    ssf,\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst operationIdNameMapping = [\n    'constructor',\n    'render',\n    'patch',\n    'connectedCallback',\n    'renderedCallback',\n    'disconnectedCallback',\n    'errorCallback',\n    'lwc-hydrate',\n    'lwc-rehydrate',\n];\n// Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.\n// JSDom (used in Jest) for example doesn't implement the UserTiming APIs.\nconst isUserTimingSupported = typeof performance !== 'undefined' &&\n    typeof performance.mark === 'function' &&\n    typeof performance.clearMarks === 'function' &&\n    typeof performance.measure === 'function' &&\n    typeof performance.clearMeasures === 'function';\nconst start = !isUserTimingSupported\n    ? noop\n    : (markName) => {\n        performance.mark(markName);\n    };\nconst end = !isUserTimingSupported\n    ? noop\n    : (measureName, markName) => {\n        performance.measure(measureName, markName);\n        // Clear the created marks and measure to avoid filling the performance entries buffer.\n        // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.\n        performance.clearMarks(markName);\n        performance.clearMeasures(measureName);\n    };\nfunction getOperationName(opId) {\n    return operationIdNameMapping[opId];\n}\nfunction getMeasureName(opId, vm) {\n    return `${getComponentTag(vm)} - ${getOperationName(opId)}`;\n}\nfunction getMarkName(opId, vm) {\n    // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce\n    // the right measures for components that are recursive.\n    return `${getMeasureName(opId, vm)} - ${vm.idx}`;\n}\n/** Indicates if operations should be logged via the User Timing API. */\nconst isMeasureEnabled = process.env.NODE_ENV !== 'production';\n/** Indicates if operations should be logged by the profiler. */\nlet isProfilerEnabled = false;\n/** The currently assigned profiler dispatcher. */\nlet currentDispatcher = noop;\nconst profilerControl = {\n    enableProfiler() {\n        isProfilerEnabled = true;\n    },\n    disableProfiler() {\n        isProfilerEnabled = false;\n    },\n    attachDispatcher(dispatcher) {\n        currentDispatcher = dispatcher;\n        this.enableProfiler();\n    },\n    detachDispatcher() {\n        const dispatcher = currentDispatcher;\n        currentDispatcher = noop;\n        this.disableProfiler();\n        return dispatcher;\n    },\n};\nfunction logOperationStart(opId, vm) {\n    if (isMeasureEnabled) {\n        const markName = getMarkName(opId, vm);\n        start(markName);\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 0 /* Phase.Start */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);\n    }\n}\nfunction logOperationEnd(opId, vm) {\n    if (isMeasureEnabled) {\n        const markName = getMarkName(opId, vm);\n        const measureName = getMeasureName(opId, vm);\n        end(measureName, markName);\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 1 /* Phase.Stop */, vm.tagName, vm.idx, vm.renderMode, vm.shadowMode);\n    }\n}\nfunction logGlobalOperationStart(opId, vm) {\n    if (isMeasureEnabled) {\n        const opName = getOperationName(opId);\n        const markName = isUndefined$1(vm) ? opName : getMarkName(opId, vm);\n        start(markName);\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 0 /* Phase.Start */, vm === null || vm === void 0 ? void 0 : vm.tagName, vm === null || vm === void 0 ? void 0 : vm.idx, vm === null || vm === void 0 ? void 0 : vm.renderMode, vm === null || vm === void 0 ? void 0 : vm.shadowMode);\n    }\n}\nfunction logGlobalOperationEnd(opId, vm) {\n    if (isMeasureEnabled) {\n        const opName = getOperationName(opId);\n        const markName = isUndefined$1(vm) ? opName : getMarkName(opId, vm);\n        end(opName, markName);\n    }\n    if (isProfilerEnabled) {\n        currentDispatcher(opId, 1 /* Phase.Stop */, vm === null || vm === void 0 ? void 0 : vm.tagName, vm === null || vm === void 0 ? void 0 : vm.idx, vm === null || vm === void 0 ? void 0 : vm.renderMode, vm === null || vm === void 0 ? void 0 : vm.shadowMode);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isUpdatingTemplate = false;\nlet vmBeingRendered = null;\nfunction getVMBeingRendered() {\n    return vmBeingRendered;\n}\nfunction setVMBeingRendered(vm) {\n    vmBeingRendered = vm;\n}\nfunction validateSlots(vm, html) {\n    assertNotProd(); // this method should never leak to prod\n    const { cmpSlots } = vm;\n    const { slots = EmptyArray } = html;\n    for (const slotName in cmpSlots.slotAssignments) {\n        // eslint-disable-next-line @lwc/lwc-internal/no-production-assert\n        assert.isTrue(isArray$1(cmpSlots.slotAssignments[slotName]), `Slots can only be set to an array, instead received ${toString$1(cmpSlots.slotAssignments[slotName])} for slot \"${slotName}\" in ${vm}.`);\n        if (slotName !== '' && ArrayIndexOf.call(slots, slotName) === -1) {\n            // TODO [#1297]: this should never really happen because the compiler should always validate\n            // eslint-disable-next-line @lwc/lwc-internal/no-production-assert\n            logError(`Ignoring unknown provided slot name \"${slotName}\" in ${vm}. Check for a typo on the slot attribute.`, vm);\n        }\n    }\n}\nfunction validateLightDomTemplate(template, vm) {\n    if (template === defaultEmptyTemplate)\n        return;\n    if (vm.renderMode === 0 /* RenderMode.Light */) {\n        assert.isTrue(template.renderMode === 'light', `Light DOM components can't render shadow DOM templates. Add an 'lwc:render-mode=\"light\"' directive to the root template tag of ${getComponentTag(vm)}.`);\n    }\n    else {\n        assert.isTrue(isUndefined$1(template.renderMode), `Shadow DOM components template can't render light DOM templates. Either remove the 'lwc:render-mode' directive from ${getComponentTag(vm)} or set it to 'lwc:render-mode=\"shadow\"`);\n    }\n}\nfunction buildParseFragmentFn(createFragmentFn) {\n    return (strings, ...keys) => {\n        const cache = create(null);\n        return function () {\n            const { context: { hasScopedStyles, stylesheetToken }, shadowMode, renderer, } = getVMBeingRendered();\n            const hasStyleToken = !isUndefined$1(stylesheetToken);\n            const isSyntheticShadow = shadowMode === 1 /* ShadowMode.Synthetic */;\n            let cacheKey = 0;\n            if (hasStyleToken && hasScopedStyles) {\n                cacheKey |= 1 /* FragmentCache.HAS_SCOPED_STYLE */;\n            }\n            if (hasStyleToken && isSyntheticShadow) {\n                cacheKey |= 2 /* FragmentCache.SHADOW_MODE_SYNTHETIC */;\n            }\n            if (!isUndefined$1(cache[cacheKey])) {\n                return cache[cacheKey];\n            }\n            const classToken = hasScopedStyles && hasStyleToken ? ' ' + stylesheetToken : '';\n            const classAttrToken = hasScopedStyles && hasStyleToken ? ` class=\"${stylesheetToken}\"` : '';\n            const attrToken = hasStyleToken && isSyntheticShadow ? ' ' + stylesheetToken : '';\n            let htmlFragment = '';\n            for (let i = 0, n = keys.length; i < n; i++) {\n                switch (keys[i]) {\n                    case 0: // styleToken in existing class attr\n                        htmlFragment += strings[i] + classToken;\n                        break;\n                    case 1: // styleToken for added class attr\n                        htmlFragment += strings[i] + classAttrToken;\n                        break;\n                    case 2: // styleToken as attr\n                        htmlFragment += strings[i] + attrToken;\n                        break;\n                    case 3: // ${1}${2}\n                        htmlFragment += strings[i] + classAttrToken + attrToken;\n                        break;\n                }\n            }\n            htmlFragment += strings[strings.length - 1];\n            cache[cacheKey] = createFragmentFn(htmlFragment, renderer);\n            return cache[cacheKey];\n        };\n    };\n}\n// Note: at the moment this code executes, we don't have a renderer yet.\nconst parseFragment = buildParseFragmentFn((html, renderer) => {\n    const { createFragment } = renderer;\n    return createFragment(html);\n});\nconst parseSVGFragment = buildParseFragmentFn((html, renderer) => {\n    const { createFragment, getFirstChild } = renderer;\n    const fragment = createFragment('<svg>' + html + '</svg>');\n    return getFirstChild(fragment);\n});\nfunction evaluateTemplate(vm, html) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isFunction$1(html), `evaluateTemplate() second argument must be an imported template instead of ${toString$1(html)}`);\n        // in dev-mode, we support hot swapping of templates, which means that\n        // the component instance might be attempting to use an old version of\n        // the template, while internally, we have a replacement for it.\n        html = getTemplateOrSwappedTemplate(html);\n    }\n    const isUpdatingTemplateInception = isUpdatingTemplate;\n    const vmOfTemplateBeingUpdatedInception = vmBeingRendered;\n    let vnodes = [];\n    runWithBoundaryProtection(vm, vm.owner, () => {\n        // pre\n        vmBeingRendered = vm;\n        logOperationStart(1 /* OperationId.Render */, vm);\n    }, () => {\n        // job\n        const { component, context, cmpSlots, cmpTemplate, tro } = vm;\n        tro.observe(() => {\n            // Reset the cache memoizer for template when needed.\n            if (html !== cmpTemplate) {\n                if (process.env.NODE_ENV !== 'production') {\n                    validateLightDomTemplate(html, vm);\n                }\n                // Perf opt: do not reset the shadow root during the first rendering (there is\n                // nothing to reset).\n                if (!isNull(cmpTemplate)) {\n                    // It is important to reset the content to avoid reusing similar elements\n                    // generated from a different template, because they could have similar IDs,\n                    // and snabbdom just rely on the IDs.\n                    resetComponentRoot(vm);\n                }\n                // Check that the template was built by the compiler.\n                if (!isTemplateRegistered(html)) {\n                    throw new TypeError(`Invalid template returned by the render() method on ${vm}. It must return an imported template (e.g.: \\`import html from \"./${vm.def.name}.html\"\\`), instead, it has returned: ${toString$1(html)}.`);\n                }\n                vm.cmpTemplate = html;\n                // Create a brand new template cache for the swapped templated.\n                context.tplCache = create(null);\n                // Set the computeHasScopedStyles property in the context, to avoid recomputing it repeatedly.\n                context.hasScopedStyles = computeHasScopedStyles(html, vm);\n                // Update the scoping token on the host element.\n                updateStylesheetToken(vm, html);\n                // Evaluate, create stylesheet and cache the produced VNode for future\n                // re-rendering.\n                const stylesheetsContent = getStylesheetsContent(vm, html);\n                context.styleVNodes =\n                    stylesheetsContent.length === 0\n                        ? null\n                        : createStylesheet(vm, stylesheetsContent);\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                // validating slots in every rendering since the allocated content might change over time\n                validateSlots(vm, html);\n                // add the VM to the list of host VMs that can be re-rendered if html is swapped\n                setActiveVM(vm);\n            }\n            // reset the refs; they will be set during the tmpl() instantiation\n            vm.refVNodes = html.hasRefs ? create(null) : null;\n            // right before producing the vnodes, we clear up all internal references\n            // to custom elements from the template.\n            vm.velements = [];\n            // Set the global flag that template is being updated\n            isUpdatingTemplate = true;\n            vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);\n            const { styleVNodes } = context;\n            if (!isNull(styleVNodes)) {\n                ArrayUnshift.apply(vnodes, styleVNodes);\n            }\n        });\n    }, () => {\n        // post\n        isUpdatingTemplate = isUpdatingTemplateInception;\n        vmBeingRendered = vmOfTemplateBeingUpdatedInception;\n        logOperationEnd(1 /* OperationId.Render */, vm);\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        assert.invariant(isArray$1(vnodes), `Compiler should produce html functions that always return an array.`);\n    }\n    return vnodes;\n}\nfunction computeHasScopedStylesInStylesheets(stylesheets) {\n    if (hasStyles(stylesheets)) {\n        for (let i = 0; i < stylesheets.length; i++) {\n            if (isTrue(stylesheets[i][KEY__SCOPED_CSS])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction computeHasScopedStyles(template, vm) {\n    const { stylesheets } = template;\n    const vmStylesheets = !isUndefined$1(vm) ? vm.stylesheets : null;\n    return (computeHasScopedStylesInStylesheets(stylesheets) ||\n        computeHasScopedStylesInStylesheets(vmStylesheets));\n}\nfunction hasStyles(stylesheets) {\n    return !isUndefined$1(stylesheets) && !isNull(stylesheets) && stylesheets.length > 0;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isInvokingRender = false;\nlet vmBeingConstructed = null;\nfunction isBeingConstructed(vm) {\n    return vmBeingConstructed === vm;\n}\nfunction invokeComponentCallback(vm, fn, args) {\n    const { component, callHook, owner } = vm;\n    runWithBoundaryProtection(vm, owner, noop, () => {\n        callHook(component, fn, args);\n    }, noop);\n}\nfunction invokeComponentConstructor(vm, Ctor) {\n    const vmBeingConstructedInception = vmBeingConstructed;\n    let error;\n    logOperationStart(0 /* OperationId.Constructor */, vm);\n    vmBeingConstructed = vm;\n    /**\n     * Constructors don't need to be wrapped with a boundary because for root elements\n     * it should throw, while elements from template are already wrapped by a boundary\n     * associated to the diffing algo.\n     */\n    try {\n        // job\n        const result = new Ctor();\n        // Check indirectly if the constructor result is an instance of LightningElement. Using\n        // the \"instanceof\" operator would not work here since Locker Service provides its own\n        // implementation of LightningElement, so we indirectly check if the base constructor is\n        // invoked by accessing the component on the vm.\n        if (vmBeingConstructed.component !== result) {\n            throw new TypeError('Invalid component constructor, the class should extend LightningElement.');\n        }\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        logOperationEnd(0 /* OperationId.Constructor */, vm);\n        vmBeingConstructed = vmBeingConstructedInception;\n        if (!isUndefined$1(error)) {\n            addErrorComponentStack(vm, error);\n            // re-throwing the original error annotated after restoring the context\n            throw error; // eslint-disable-line no-unsafe-finally\n        }\n    }\n}\nfunction invokeComponentRenderMethod(vm) {\n    const { def: { render }, callHook, component, owner, } = vm;\n    const isRenderBeingInvokedInception = isInvokingRender;\n    const vmBeingRenderedInception = getVMBeingRendered();\n    let html;\n    let renderInvocationSuccessful = false;\n    runWithBoundaryProtection(vm, owner, () => {\n        // pre\n        isInvokingRender = true;\n        setVMBeingRendered(vm);\n    }, () => {\n        // job\n        vm.tro.observe(() => {\n            html = callHook(component, render);\n            renderInvocationSuccessful = true;\n        });\n    }, () => {\n        // post\n        isInvokingRender = isRenderBeingInvokedInception;\n        setVMBeingRendered(vmBeingRenderedInception);\n    });\n    // If render() invocation failed, process errorCallback in boundary and return an empty template\n    return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];\n}\nfunction invokeEventListener(vm, fn, thisValue, event) {\n    const { callHook, owner } = vm;\n    runWithBoundaryProtection(vm, owner, noop, () => {\n        // job\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isTrue(isFunction$1(fn), `Invalid event handler for event '${event.type}' on ${vm}.`);\n        }\n        callHook(thisValue, fn, [event]);\n    }, noop);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst signedTemplateMap = new Map();\n/**\n * INTERNAL: This function can only be invoked by compiled code. The compiler\n * will prevent this function from being imported by userland code.\n */\nfunction registerComponent(\n// We typically expect a LightningElementConstructor, but technically you can call this with anything\nCtor, { tmpl }) {\n    if (isFunction$1(Ctor)) {\n        if (process.env.NODE_ENV !== 'production') {\n            // There is no point in running this in production, because the version mismatch check relies\n            // on code comments which are stripped out in production by minifiers\n            checkVersionMismatch(Ctor, 'component');\n        }\n        signedTemplateMap.set(Ctor, tmpl);\n    }\n    // chaining this method as a way to wrap existing assignment of component constructor easily,\n    // without too much transformation\n    return Ctor;\n}\nfunction getComponentRegisteredTemplate(Ctor) {\n    return signedTemplateMap.get(Ctor);\n}\nfunction getTemplateReactiveObserver(vm) {\n    return createReactiveObserver(() => {\n        const { isDirty } = vm;\n        if (isFalse(isDirty)) {\n            markComponentAsDirty(vm);\n            scheduleRehydration(vm);\n        }\n    });\n}\nfunction renderComponent(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.invariant(vm.isDirty, `${vm} is not dirty.`);\n    }\n    vm.tro.reset();\n    const vnodes = invokeComponentRenderMethod(vm);\n    vm.isDirty = false;\n    vm.isScheduled = false;\n    return vnodes;\n}\nfunction markComponentAsDirty(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        const vmBeingRendered = getVMBeingRendered();\n        assert.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the component is already dirty.`);\n        assert.isFalse(isInvokingRender, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${vmBeingRendered}.`);\n        assert.isFalse(isUpdatingTemplate, `markComponentAsDirty() for ${vm} cannot be called while updating template of ${vmBeingRendered}.`);\n    }\n    vm.isDirty = true;\n}\nconst cmpEventListenerMap = new WeakMap();\nfunction getWrappedComponentsListener(vm, listener) {\n    if (!isFunction$1(listener)) {\n        throw new TypeError('Expected an EventListener but received ' + typeof listener); // avoiding problems with non-valid listeners\n    }\n    let wrappedListener = cmpEventListenerMap.get(listener);\n    if (isUndefined$1(wrappedListener)) {\n        wrappedListener = function (event) {\n            invokeEventListener(vm, listener, undefined, event);\n        };\n        cmpEventListenerMap.set(listener, wrappedListener);\n    }\n    return wrappedListener;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst Services = create(null);\nconst hooks = ['rendered', 'connected', 'disconnected'];\n/**\n * EXPERIMENTAL: This function allows for the registration of \"services\"\n * in LWC by exposing hooks into the component life-cycle. This API is\n * subject to change or being removed.\n */\nfunction register(service) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isObject(service), `Invalid service declaration, ${service}: service must be an object`);\n    }\n    for (let i = 0; i < hooks.length; ++i) {\n        const hookName = hooks[i];\n        if (hookName in service) {\n            let l = Services[hookName];\n            if (isUndefined$1(l)) {\n                Services[hookName] = l = [];\n            }\n            ArrayPush$1.call(l, service[hookName]);\n        }\n    }\n}\nfunction invokeServiceHook(vm, cbs) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(isArray$1(cbs) && cbs.length > 0, `Optimize invokeServiceHook() to be invoked only when needed`);\n    }\n    const { component, def, context } = vm;\n    for (let i = 0, len = cbs.length; i < len; ++i) {\n        cbs[i].call(undefined, component, {}, def, context);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet idx = 0;\n/** The internal slot used to associate different objects the engine manipulates with the VM */\nconst ViewModelReflection = new WeakMap();\nfunction callHook(cmp, fn, args = []) {\n    return fn.apply(cmp, args);\n}\nfunction setHook(cmp, prop, newValue) {\n    cmp[prop] = newValue;\n}\nfunction getHook(cmp, prop) {\n    return cmp[prop];\n}\nfunction rerenderVM(vm) {\n    rehydrate(vm);\n}\nfunction connectRootElement(elm) {\n    const vm = getAssociatedVM(elm);\n    logGlobalOperationStart(7 /* OperationId.GlobalHydrate */, vm);\n    // Usually means moving the element from one place to another, which is observable via\n    // life-cycle hooks.\n    if (vm.state === 1 /* VMState.connected */) {\n        disconnectRootElement(elm);\n    }\n    runConnectedCallback(vm);\n    rehydrate(vm);\n    logGlobalOperationEnd(7 /* OperationId.GlobalHydrate */, vm);\n}\nfunction disconnectRootElement(elm) {\n    const vm = getAssociatedVM(elm);\n    resetComponentStateWhenRemoved(vm);\n}\nfunction appendVM(vm) {\n    rehydrate(vm);\n}\n// just in case the component comes back, with this we guarantee re-rendering it\n// while preventing any attempt to rehydration until after reinsertion.\nfunction resetComponentStateWhenRemoved(vm) {\n    const { state } = vm;\n    if (state !== 2 /* VMState.disconnected */) {\n        const { tro } = vm;\n        // Making sure that any observing record will not trigger the rehydrated on this vm\n        tro.reset();\n        runDisconnectedCallback(vm);\n        // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)\n        runChildNodesDisconnectedCallback(vm);\n        runLightChildNodesDisconnectedCallback(vm);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        removeActiveVM(vm);\n    }\n}\n// this method is triggered by the diffing algo only when a vnode from the\n// old vnode.children is removed from the DOM.\nfunction removeVM(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(vm.state === 1 /* VMState.connected */ || vm.state === 2 /* VMState.disconnected */, `${vm} must have been connected.`);\n    }\n    resetComponentStateWhenRemoved(vm);\n}\nfunction getNearestShadowAncestor(vm) {\n    let ancestor = vm.owner;\n    while (!isNull(ancestor) && ancestor.renderMode === 0 /* RenderMode.Light */) {\n        ancestor = ancestor.owner;\n    }\n    return ancestor;\n}\nfunction createVM(elm, ctor, renderer, options) {\n    const { mode, owner, tagName, hydrated } = options;\n    const def = getComponentInternalDef(ctor);\n    const vm = {\n        elm,\n        def,\n        idx: idx++,\n        state: 0 /* VMState.created */,\n        isScheduled: false,\n        isDirty: true,\n        tagName,\n        mode,\n        owner,\n        refVNodes: null,\n        children: EmptyArray,\n        aChildren: EmptyArray,\n        velements: EmptyArray,\n        cmpProps: create(null),\n        cmpFields: create(null),\n        cmpSlots: { slotAssignments: create(null) },\n        cmpTemplate: null,\n        hydrated: Boolean(hydrated),\n        renderMode: def.renderMode,\n        context: {\n            stylesheetToken: undefined,\n            hasTokenInClass: undefined,\n            hasTokenInAttribute: undefined,\n            hasScopedStyles: undefined,\n            styleVNodes: null,\n            tplCache: EmptyObject,\n            wiredConnecting: EmptyArray,\n            wiredDisconnecting: EmptyArray,\n        },\n        // Properties set right after VM creation.\n        tro: null,\n        shadowMode: null,\n        stylesheets: null,\n        // Properties set by the LightningElement constructor.\n        component: null,\n        shadowRoot: null,\n        renderRoot: null,\n        callHook,\n        setHook,\n        getHook,\n        renderer,\n    };\n    if (process.env.NODE_ENV !== 'production') {\n        vm.debugInfo = create(null);\n    }\n    vm.stylesheets = computeStylesheets(vm, def.ctor);\n    vm.shadowMode = computeShadowMode(vm, renderer);\n    vm.tro = getTemplateReactiveObserver(vm);\n    if (process.env.NODE_ENV !== 'production') {\n        vm.toString = () => {\n            return `[object:vm ${def.name} (${vm.idx})]`;\n        };\n        if (lwcRuntimeFlags.ENABLE_FORCE_NATIVE_SHADOW_MODE_FOR_TEST) {\n            vm.shadowMode = 0 /* ShadowMode.Native */;\n        }\n    }\n    // Create component instance associated to the vm and the element.\n    invokeComponentConstructor(vm, def.ctor);\n    // Initializing the wire decorator per instance only when really needed\n    if (hasWireAdapters(vm)) {\n        installWireAdapters(vm);\n    }\n    return vm;\n}\nfunction validateComponentStylesheets(vm, stylesheets) {\n    let valid = true;\n    const validate = (arrayOrStylesheet) => {\n        if (isArray$1(arrayOrStylesheet)) {\n            for (let i = 0; i < arrayOrStylesheet.length; i++) {\n                validate(arrayOrStylesheet[i]);\n            }\n        }\n        else if (!isFunction$1(arrayOrStylesheet)) {\n            // function assumed to be a stylesheet factory\n            valid = false;\n        }\n    };\n    if (!isArray$1(stylesheets)) {\n        valid = false;\n    }\n    else {\n        validate(stylesheets);\n    }\n    return valid;\n}\n// Validate and flatten any stylesheets defined as `static stylesheets`\nfunction computeStylesheets(vm, ctor) {\n    warnOnStylesheetsMutation(ctor);\n    const { stylesheets } = ctor;\n    if (!isUndefined$1(stylesheets)) {\n        const valid = validateComponentStylesheets(vm, stylesheets);\n        if (valid) {\n            return flattenStylesheets(stylesheets);\n        }\n        else if (process.env.NODE_ENV !== 'production') {\n            logError(`static stylesheets must be an array of CSS stylesheets. Found invalid stylesheets on <${vm.tagName}>`, vm);\n        }\n    }\n    return null;\n}\nfunction warnOnStylesheetsMutation(ctor) {\n    if (process.env.NODE_ENV !== 'production') {\n        let { stylesheets } = ctor;\n        defineProperty(ctor, 'stylesheets', {\n            enumerable: true,\n            configurable: true,\n            get() {\n                return stylesheets;\n            },\n            set(newValue) {\n                logWarnOnce(`Dynamically setting the \"stylesheets\" static property on ${ctor.name} ` +\n                    'will not affect the stylesheets injected.');\n                stylesheets = newValue;\n            },\n        });\n    }\n}\nfunction computeShadowMode(vm, renderer) {\n    const { def } = vm;\n    const { isSyntheticShadowDefined, isNativeShadowDefined } = renderer;\n    let shadowMode;\n    if (isSyntheticShadowDefined) {\n        if (def.renderMode === 0 /* RenderMode.Light */) {\n            // ShadowMode.Native implies \"not synthetic shadow\" which is consistent with how\n            // everything defaults to native when the synthetic shadow polyfill is unavailable.\n            shadowMode = 0 /* ShadowMode.Native */;\n        }\n        else if (isNativeShadowDefined) {\n            // Not combined with above condition because @lwc/features only supports identifiers in\n            // the if-condition.\n            if (lwcRuntimeFlags.ENABLE_MIXED_SHADOW_MODE) {\n                if (def.shadowSupportMode === \"any\" /* ShadowSupportMode.Any */) {\n                    shadowMode = 0 /* ShadowMode.Native */;\n                }\n                else {\n                    const shadowAncestor = getNearestShadowAncestor(vm);\n                    if (!isNull(shadowAncestor) &&\n                        shadowAncestor.shadowMode === 0 /* ShadowMode.Native */) {\n                        // Transitive support for native Shadow DOM. A component in native mode\n                        // transitively opts all of its descendants into native.\n                        shadowMode = 0 /* ShadowMode.Native */;\n                    }\n                    else {\n                        // Synthetic if neither this component nor any of its ancestors are configured\n                        // to be native.\n                        shadowMode = 1 /* ShadowMode.Synthetic */;\n                    }\n                }\n            }\n            else {\n                shadowMode = 1 /* ShadowMode.Synthetic */;\n            }\n        }\n        else {\n            // Synthetic if there is no native Shadow DOM support.\n            shadowMode = 1 /* ShadowMode.Synthetic */;\n        }\n    }\n    else {\n        // Native if the synthetic shadow polyfill is unavailable.\n        shadowMode = 0 /* ShadowMode.Native */;\n    }\n    return shadowMode;\n}\nfunction assertIsVM(obj) {\n    if (isNull(obj) || !isObject(obj) || !('renderRoot' in obj)) {\n        throw new TypeError(`${obj} is not a VM.`);\n    }\n}\nfunction associateVM(obj, vm) {\n    ViewModelReflection.set(obj, vm);\n}\nfunction getAssociatedVM(obj) {\n    const vm = ViewModelReflection.get(obj);\n    if (process.env.NODE_ENV !== 'production') {\n        assertIsVM(vm);\n    }\n    return vm;\n}\nfunction getAssociatedVMIfPresent(obj) {\n    const maybeVm = ViewModelReflection.get(obj);\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isUndefined$1(maybeVm)) {\n            assertIsVM(maybeVm);\n        }\n    }\n    return maybeVm;\n}\nfunction rehydrate(vm) {\n    if (isTrue(vm.isDirty)) {\n        const children = renderComponent(vm);\n        patchShadowRoot(vm, children);\n    }\n}\nfunction patchShadowRoot(vm, newCh) {\n    const { renderRoot, children: oldCh, renderer } = vm;\n    // caching the new children collection\n    vm.children = newCh;\n    if (newCh.length > 0 || oldCh.length > 0) {\n        // patch function mutates vnodes by adding the element reference,\n        // however, if patching fails it contains partial changes.\n        if (oldCh !== newCh) {\n            runWithBoundaryProtection(vm, vm, () => {\n                // pre\n                logOperationStart(2 /* OperationId.Patch */, vm);\n            }, () => {\n                // job\n                patchChildren(oldCh, newCh, renderRoot, renderer);\n            }, () => {\n                // post\n                logOperationEnd(2 /* OperationId.Patch */, vm);\n            });\n        }\n    }\n    if (vm.state === 1 /* VMState.connected */) {\n        // If the element is connected, that means connectedCallback was already issued, and\n        // any successive rendering should finish with the call to renderedCallback, otherwise\n        // the connectedCallback will take care of calling it in the right order at the end of\n        // the current rehydration process.\n        runRenderedCallback(vm);\n    }\n}\nfunction runRenderedCallback(vm) {\n    const { def: { renderedCallback }, } = vm;\n    const { rendered } = Services;\n    if (rendered) {\n        invokeServiceHook(vm, rendered);\n    }\n    if (!isUndefined$1(renderedCallback)) {\n        logOperationStart(4 /* OperationId.RenderedCallback */, vm);\n        invokeComponentCallback(vm, renderedCallback);\n        logOperationEnd(4 /* OperationId.RenderedCallback */, vm);\n    }\n}\nlet rehydrateQueue = [];\nfunction flushRehydrationQueue() {\n    logGlobalOperationStart(8 /* OperationId.GlobalRehydrate */);\n    if (process.env.NODE_ENV !== 'production') {\n        assert.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);\n    }\n    const vms = rehydrateQueue.sort((a, b) => a.idx - b.idx);\n    rehydrateQueue = []; // reset to a new queue\n    for (let i = 0, len = vms.length; i < len; i += 1) {\n        const vm = vms[i];\n        try {\n            rehydrate(vm);\n        }\n        catch (error) {\n            if (i + 1 < len) {\n                // pieces of the queue are still pending to be rehydrated, those should have priority\n                if (rehydrateQueue.length === 0) {\n                    addCallbackToNextTick(flushRehydrationQueue);\n                }\n                ArrayUnshift.apply(rehydrateQueue, ArraySlice.call(vms, i + 1));\n            }\n            // we need to end the measure before throwing.\n            logGlobalOperationEnd(8 /* OperationId.GlobalRehydrate */);\n            // re-throwing the original error will break the current tick, but since the next tick is\n            // already scheduled, it should continue patching the rest.\n            throw error; // eslint-disable-line no-unsafe-finally\n        }\n    }\n    logGlobalOperationEnd(8 /* OperationId.GlobalRehydrate */);\n}\nfunction runConnectedCallback(vm) {\n    const { state } = vm;\n    if (state === 1 /* VMState.connected */) {\n        return; // nothing to do since it was already connected\n    }\n    vm.state = 1 /* VMState.connected */;\n    // reporting connection\n    const { connected } = Services;\n    if (connected) {\n        invokeServiceHook(vm, connected);\n    }\n    if (hasWireAdapters(vm)) {\n        connectWireAdapters(vm);\n    }\n    const { connectedCallback } = vm.def;\n    if (!isUndefined$1(connectedCallback)) {\n        logOperationStart(3 /* OperationId.ConnectedCallback */, vm);\n        invokeComponentCallback(vm, connectedCallback);\n        logOperationEnd(3 /* OperationId.ConnectedCallback */, vm);\n    }\n}\nfunction hasWireAdapters(vm) {\n    return getOwnPropertyNames$1(vm.def.wire).length > 0;\n}\nfunction runDisconnectedCallback(vm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(vm.state !== 2 /* VMState.disconnected */, `${vm} must be inserted.`);\n    }\n    if (isFalse(vm.isDirty)) {\n        // this guarantees that if the component is reused/reinserted,\n        // it will be re-rendered because we are disconnecting the reactivity\n        // linking, so mutations are not automatically reflected on the state\n        // of disconnected components.\n        vm.isDirty = true;\n    }\n    vm.state = 2 /* VMState.disconnected */;\n    // reporting disconnection\n    const { disconnected } = Services;\n    if (disconnected) {\n        invokeServiceHook(vm, disconnected);\n    }\n    if (hasWireAdapters(vm)) {\n        disconnectWireAdapters(vm);\n    }\n    const { disconnectedCallback } = vm.def;\n    if (!isUndefined$1(disconnectedCallback)) {\n        logOperationStart(5 /* OperationId.DisconnectedCallback */, vm);\n        invokeComponentCallback(vm, disconnectedCallback);\n        logOperationEnd(5 /* OperationId.DisconnectedCallback */, vm);\n    }\n}\nfunction runChildNodesDisconnectedCallback(vm) {\n    const { velements: vCustomElementCollection } = vm;\n    // Reporting disconnection for every child in inverse order since they are\n    // inserted in reserved order.\n    for (let i = vCustomElementCollection.length - 1; i >= 0; i -= 1) {\n        const { elm } = vCustomElementCollection[i];\n        // There are two cases where the element could be undefined:\n        // * when there is an error during the construction phase, and an error\n        //   boundary picks it, there is a possibility that the VCustomElement\n        //   is not properly initialized, and therefore is should be ignored.\n        // * when slotted custom element is not used by the element where it is\n        //   slotted into it, as  a result, the custom element was never\n        //   initialized.\n        if (!isUndefined$1(elm)) {\n            const childVM = getAssociatedVMIfPresent(elm);\n            // The VM associated with the element might be associated undefined\n            // in the case where the VM failed in the middle of its creation,\n            // eg: constructor throwing before invoking super().\n            if (!isUndefined$1(childVM)) {\n                resetComponentStateWhenRemoved(childVM);\n            }\n        }\n    }\n}\nfunction runLightChildNodesDisconnectedCallback(vm) {\n    const { aChildren: adoptedChildren } = vm;\n    recursivelyDisconnectChildren(adoptedChildren);\n}\n/**\n * The recursion doesn't need to be a complete traversal of the vnode graph,\n * instead it can be partial, when a custom element vnode is found, we don't\n * need to continue into its children because by attempting to disconnect the\n * custom element itself will trigger the removal of anything slotted or anything\n * defined on its shadow.\n */\nfunction recursivelyDisconnectChildren(vnodes) {\n    for (let i = 0, len = vnodes.length; i < len; i += 1) {\n        const vnode = vnodes[i];\n        if (!isNull(vnode) && !isUndefined$1(vnode.elm)) {\n            switch (vnode.type) {\n                case 2 /* VNodeType.Element */:\n                    recursivelyDisconnectChildren(vnode.children);\n                    break;\n                case 3 /* VNodeType.CustomElement */: {\n                    const vm = getAssociatedVM(vnode.elm);\n                    resetComponentStateWhenRemoved(vm);\n                    break;\n                }\n            }\n        }\n    }\n}\n// This is a super optimized mechanism to remove the content of the root node (shadow root\n// for shadow DOM components and the root element itself for light DOM) without having to go\n// into snabbdom. Especially useful when the reset is a consequence of an error, in which case the\n// children VNodes might not be representing the current state of the DOM.\nfunction resetComponentRoot(vm) {\n    const { children, renderRoot, renderer: { remove }, } = vm;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        if (!isNull(child) && !isUndefined$1(child.elm)) {\n            remove(child.elm, renderRoot);\n        }\n    }\n    vm.children = EmptyArray;\n    runChildNodesDisconnectedCallback(vm);\n    vm.velements = EmptyArray;\n}\nfunction scheduleRehydration(vm) {\n    if (isTrue(vm.isScheduled)) {\n        return;\n    }\n    vm.isScheduled = true;\n    if (rehydrateQueue.length === 0) {\n        addCallbackToNextTick(flushRehydrationQueue);\n    }\n    ArrayPush$1.call(rehydrateQueue, vm);\n}\nfunction getErrorBoundaryVM(vm) {\n    let currentVm = vm;\n    while (!isNull(currentVm)) {\n        if (!isUndefined$1(currentVm.def.errorCallback)) {\n            return currentVm;\n        }\n        currentVm = currentVm.owner;\n    }\n}\nfunction runWithBoundaryProtection(vm, owner, pre, job, post) {\n    let error;\n    pre();\n    try {\n        job();\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        post();\n        if (!isUndefined$1(error)) {\n            addErrorComponentStack(vm, error);\n            const errorBoundaryVm = isNull(owner) ? undefined : getErrorBoundaryVM(owner);\n            if (isUndefined$1(errorBoundaryVm)) {\n                throw error; // eslint-disable-line no-unsafe-finally\n            }\n            resetComponentRoot(vm); // remove offenders\n            logOperationStart(6 /* OperationId.ErrorCallback */, vm);\n            // error boundaries must have an ErrorCallback\n            const errorCallback = errorBoundaryVm.def.errorCallback;\n            invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);\n            logOperationEnd(6 /* OperationId.ErrorCallback */, vm);\n        }\n    }\n}\nfunction forceRehydration(vm) {\n    // if we must reset the shadowRoot content and render the template\n    // from scratch on an active instance, the way to force the reset\n    // is by replacing the value of old template, which is used during\n    // to determine if the template has changed or not during the rendering\n    // process. If the template returned by render() is different from the\n    // previous stored template, the styles will be reset, along with the\n    // content of the shadowRoot, this way we can guarantee that all children\n    // elements will be throw away, and new instances will be created.\n    vm.cmpTemplate = () => [];\n    if (isFalse(vm.isDirty)) {\n        // forcing the vm to rehydrate in the next tick\n        markComponentAsDirty(vm);\n        scheduleRehydration(vm);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n//\n// The goal of this code is to detect invalid cross-root ARIA references in synthetic shadow DOM.\n// These invalid references should be fixed before the offending components can be migrated to native shadow DOM.\n// When invalid usage is detected, we warn in dev mode and call the reporting API if enabled.\n// See: https://sfdc.co/synthetic-aria\n//\n// Use the unpatched native getElementById/querySelectorAll rather than the synthetic one\nconst getElementById = _globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID];\nconst querySelectorAll = _globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL];\nfunction isSyntheticShadowRootInstance(rootNode) {\n    return rootNode !== document && isTrue(rootNode.synthetic);\n}\nfunction reportViolation$1(source, target, attrName) {\n    // The vm is either for the source, the target, or both. Either one or both must be using synthetic\n    // shadow for a violation to be detected.\n    let vm = getAssociatedVMIfPresent(source.getRootNode().host);\n    if (isUndefined$1(vm)) {\n        vm = getAssociatedVMIfPresent(target.getRootNode().host);\n    }\n    if (isUndefined$1(vm)) {\n        // vm should never be undefined here, but just to be safe, bail out and don't report\n        return;\n    }\n    report(\"CrossRootAriaInSyntheticShadow\" /* ReportingEventId.CrossRootAriaInSyntheticShadow */, {\n        tagName: vm.tagName,\n        attributeName: attrName,\n    });\n    if (process.env.NODE_ENV !== 'production') {\n        // Avoid excessively logging to the console in the case of duplicates.\n        logWarnOnce(`Element <${source.tagName.toLowerCase()}> uses attribute \"${attrName}\" to reference element ` +\n            `<${target.tagName.toLowerCase()}>, which is not in the same shadow root. This will break in native shadow DOM. ` +\n            `For details, see: https://sfdc.co/synthetic-aria`, vm);\n    }\n}\nfunction parseIdRefAttributeValue(attrValue) {\n    // split on whitespace and skip empty strings after splitting\n    return isString(attrValue) ? ArrayFilter.call(StringSplit.call(attrValue, /\\s+/), Boolean) : [];\n}\nfunction detectSyntheticCrossRootAria(elm, attrName, attrValue) {\n    const root = elm.getRootNode();\n    if (!isSyntheticShadowRootInstance(root)) {\n        return;\n    }\n    if (attrName === 'id') {\n        // elm is the target, find the source\n        if (!isString(attrValue) || attrValue.length === 0) {\n            // if our id is null or empty, nobody can reference us\n            return;\n        }\n        for (const idRefAttrName of ID_REFERENCING_ATTRIBUTES_SET) {\n            // Query all global elements with this attribute. The attribute selector syntax `~=` is for values\n            // that reference multiple IDs, separated by whitespace.\n            const query = `[${idRefAttrName}~=\"${CSS.escape(attrValue)}\"]`;\n            const sourceElements = querySelectorAll.call(document, query);\n            for (let i = 0; i < sourceElements.length; i++) {\n                const sourceElement = sourceElements[i];\n                const sourceRoot = sourceElement.getRootNode();\n                if (sourceRoot !== root) {\n                    reportViolation$1(sourceElement, elm, idRefAttrName);\n                    break;\n                }\n            }\n        }\n    }\n    else {\n        // elm is the source, find the target\n        const ids = parseIdRefAttributeValue(attrValue);\n        for (const id of ids) {\n            const target = getElementById.call(document, id);\n            if (!isNull(target)) {\n                const targetRoot = target.getRootNode();\n                if (targetRoot !== root) {\n                    // target element's shadow root is not the same as ours\n                    reportViolation$1(elm, target, attrName);\n                }\n            }\n        }\n    }\n}\nlet enabled = false;\n// We want to avoid patching globals whenever possible, so this should be tree-shaken out in prod-mode and if\n// reporting is not enabled. It should also only run once\nfunction enableDetection$1() {\n    if (enabled) {\n        return; // don't double-apply the patches\n    }\n    enabled = true;\n    const { setAttribute } = Element.prototype;\n    // Detect calling `setAttribute` to set an idref or an id\n    assign(Element.prototype, {\n        setAttribute(attrName, attrValue) {\n            setAttribute.call(this, attrName, attrValue);\n            if (attrName === 'id' || ID_REFERENCING_ATTRIBUTES_SET.has(attrName)) {\n                detectSyntheticCrossRootAria(this, attrName, attrValue);\n            }\n        },\n    });\n    // Detect `elm.id = 'foo'`\n    const idDescriptor = getOwnPropertyDescriptor$1(Element.prototype, 'id');\n    if (!isUndefined$1(idDescriptor)) {\n        const { get, set } = idDescriptor;\n        // These should always be a getter and a setter, but if someone is monkeying with the global descriptor, ignore it\n        if (isFunction$1(get) && isFunction$1(set)) {\n            defineProperty(Element.prototype, 'id', {\n                get() {\n                    return get.call(this);\n                },\n                set(value) {\n                    set.call(this, value);\n                    detectSyntheticCrossRootAria(this, 'id', value);\n                },\n                // On the default descriptor for 'id', enumerable and configurable are true\n                enumerable: true,\n                configurable: true,\n            });\n        }\n    }\n}\n// Our detection logic relies on some modern browser features. We can just skip reporting the data\n// for unsupported browsers\nfunction supportsCssEscape() {\n    return typeof CSS !== 'undefined' && isFunction$1(CSS.escape);\n}\n// If this page is not using synthetic shadow, then we don't need to install detection. Note\n// that we are assuming synthetic shadow is loaded before LWC.\nfunction isSyntheticShadowLoaded() {\n    // We should probably be calling `renderer.isSyntheticShadowDefined`, but 1) we don't have access to the renderer,\n    // and 2) this code needs to run in @lwc/engine-core, so it can access `logWarn()` and `report()`.\n    return hasOwnProperty$1.call(Element.prototype, KEY__SHADOW_TOKEN);\n}\n// Detecting cross-root ARIA in synthetic shadow only makes sense for the browser\nif (supportsCssEscape() && isSyntheticShadowLoaded()) {\n    // Always run detection in dev mode, so we can at least print to the console\n    if (process.env.NODE_ENV !== 'production') {\n        enableDetection$1();\n    }\n    else {\n        // In prod mode, only enable detection if reporting is enabled\n        onReportingEnabled(enableDetection$1);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n//\n// The goal of this code is to detect usages of non-standard reflected ARIA properties. These are caused by\n// legacy non-standard Element.prototype extensions added by the @lwc/aria-reflection package.\n//\n// See the README for @lwc/aria-reflection\nconst NON_STANDARD_ARIA_PROPS = [\n    'ariaActiveDescendant',\n    'ariaControls',\n    'ariaDescribedBy',\n    'ariaDetails',\n    'ariaErrorMessage',\n    'ariaFlowTo',\n    'ariaLabelledBy',\n    'ariaOwns',\n];\nfunction isLightningElement(elm) {\n    // The former case is for `this.prop` (inside component) and the latter is for `element.prop` (outside component).\n    // In both cases, we apply the non-standard prop even when the global polyfill is disabled, so this is kosher.\n    return elm instanceof LightningElement || elm instanceof BaseBridgeElement;\n}\nfunction findVM(elm) {\n    // If it's a shadow DOM component, then it has a host\n    const { host } = elm.getRootNode();\n    const vm = isUndefined$1(host) ? undefined : getAssociatedVMIfPresent(host);\n    if (!isUndefined$1(vm)) {\n        return vm;\n    }\n    // Else it might be a light DOM component. Walk up the tree trying to find the owner\n    let parentElement = elm;\n    while (!isNull((parentElement = parentElement.parentElement))) {\n        if (isLightningElement(parentElement)) {\n            const vm = getAssociatedVMIfPresent(parentElement);\n            if (!isUndefined$1(vm)) {\n                return vm;\n            }\n        }\n    }\n    // If we return undefined, it's because the element was rendered wholly outside a LightningElement\n}\nfunction checkAndReportViolation(elm, prop, isSetter, setValue) {\n    if (!isLightningElement(elm)) {\n        const vm = findVM(elm);\n        if (process.env.NODE_ENV !== 'production') {\n            logWarnOnce(`Element <${elm.tagName.toLowerCase()}> ` +\n                (isUndefined$1(vm) ? '' : `owned by <${vm.elm.tagName.toLowerCase()}> `) +\n                `uses non-standard property \"${prop}\". This will be removed in a future version of LWC. ` +\n                `See https://sfdc.co/deprecated-aria`);\n        }\n        let setValueType;\n        if (isSetter) {\n            // `typeof null` is \"object\" which is not very useful for detecting null.\n            // We mostly want to know null vs undefined vs other types here, due to\n            // https://github.com/salesforce/lwc/issues/3284\n            setValueType = isNull(setValue) ? 'null' : typeof setValue;\n        }\n        report(\"NonStandardAriaReflection\" /* ReportingEventId.NonStandardAriaReflection */, {\n            tagName: vm === null || vm === void 0 ? void 0 : vm.tagName,\n            propertyName: prop,\n            isSetter,\n            setValueType,\n        });\n    }\n}\nfunction enableDetection() {\n    const { prototype } = Element;\n    for (const prop of NON_STANDARD_ARIA_PROPS) {\n        const descriptor = getOwnPropertyDescriptor$1(prototype, prop);\n        // The descriptor should exist because the @lwc/aria-reflection polyfill has run by now.\n        // This happens automatically because of the ordering of imports.\n        if (process.env.NODE_ENV !== 'production') {\n            /* istanbul ignore if */\n            if (isUndefined$1(descriptor) ||\n                isUndefined$1(descriptor.get) ||\n                isUndefined$1(descriptor.set)) {\n                // should never happen\n                throw new Error('detect-non-standard-aria.ts loaded before @lwc/aria-reflection');\n            }\n        }\n        // @ts-ignore\n        const { get, set } = descriptor;\n        defineProperty(prototype, prop, {\n            get() {\n                checkAndReportViolation(this, prop, false, undefined);\n                return get.call(this);\n            },\n            set(val) {\n                checkAndReportViolation(this, prop, true, val);\n                return set.call(this, val);\n            },\n            configurable: true,\n            enumerable: true,\n        });\n    }\n}\n// No point in running this code if we're not in a browser, or if the global polyfill is not loaded\n{\n    if (!lwcRuntimeFlags.DISABLE_ARIA_REFLECTION_POLYFILL) {\n        // Always run detection in dev mode, so we can at least print to the console\n        if (process.env.NODE_ENV !== 'production') {\n            enableDetection();\n        }\n        else {\n            // In prod mode, only enable detection if reporting is enabled\n            onReportingEnabled(enableDetection);\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// this is lwc internal implementation\nfunction createContextProvider(adapter) {\n    let adapterContextToken = getAdapterToken(adapter);\n    if (!isUndefined$1(adapterContextToken)) {\n        throw new Error(`Adapter already has a context provider.`);\n    }\n    adapterContextToken = guid();\n    setAdapterToken(adapter, adapterContextToken);\n    const providers = new WeakSet();\n    return (elm, options) => {\n        if (providers.has(elm)) {\n            throw new Error(`Adapter was already installed on ${elm}.`);\n        }\n        providers.add(elm);\n        const { consumerConnectedCallback, consumerDisconnectedCallback } = options;\n        elm.addEventListener(adapterContextToken, ((evt) => {\n            const { setNewContext, setDisconnectedCallback } = evt;\n            const consumer = {\n                provide(newContext) {\n                    setNewContext(newContext);\n                },\n            };\n            const disconnectCallback = () => {\n                if (!isUndefined$1(consumerDisconnectedCallback)) {\n                    consumerDisconnectedCallback(consumer);\n                }\n            };\n            setDisconnectedCallback(disconnectCallback);\n            consumerConnectedCallback(consumer);\n            evt.stopImmediatePropagation();\n        }));\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function allows you to create a reactive readonly\n * membrane around any object value. This API is subject to change or\n * being removed.\n */\nfunction readonly(obj) {\n    if (process.env.NODE_ENV !== 'production') {\n        // TODO [#1292]: Remove the readonly decorator\n        if (arguments.length !== 1) {\n            assert.fail('@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.');\n        }\n    }\n    return getReadOnlyProxy(obj);\n}\n\n/*\n * Copyright (c) 2022, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// flag indicating if the hydration recovered from the DOM mismatch\nlet hasMismatch = false;\nfunction hydrateRoot(vm) {\n    hasMismatch = false;\n    runConnectedCallback(vm);\n    hydrateVM(vm);\n    if (hasMismatch) {\n        logError('Hydration completed with errors.', vm);\n    }\n}\nfunction hydrateVM(vm) {\n    const children = renderComponent(vm);\n    vm.children = children;\n    const { renderRoot: parentNode, renderer: { getFirstChild }, } = vm;\n    hydrateChildren(getFirstChild(parentNode), children, parentNode, vm);\n    runRenderedCallback(vm);\n}\nfunction hydrateNode(node, vnode, renderer) {\n    var _a, _b;\n    let hydratedNode;\n    switch (vnode.type) {\n        case 0 /* VNodeType.Text */:\n            // VText has no special capability, fallback to the owner's renderer\n            hydratedNode = hydrateText(node, vnode, renderer);\n            break;\n        case 1 /* VNodeType.Comment */:\n            // VComment has no special capability, fallback to the owner's renderer\n            hydratedNode = hydrateComment(node, vnode, renderer);\n            break;\n        case 4 /* VNodeType.Static */:\n            // VStatic are cacheable and cannot have custom renderer associated to them\n            hydratedNode = hydrateStaticElement(node, vnode, renderer);\n            break;\n        case 5 /* VNodeType.Fragment */:\n            // a fragment does not represent any element, therefore there is no need to use a custom renderer.\n            hydratedNode = hydrateFragment(node, vnode, renderer);\n            break;\n        case 2 /* VNodeType.Element */:\n            hydratedNode = hydrateElement(node, vnode, (_a = vnode.data.renderer) !== null && _a !== void 0 ? _a : renderer);\n            break;\n        case 3 /* VNodeType.CustomElement */:\n            hydratedNode = hydrateCustomElement(node, vnode, (_b = vnode.data.renderer) !== null && _b !== void 0 ? _b : renderer);\n            break;\n    }\n    return renderer.nextSibling(hydratedNode);\n}\nconst NODE_VALUE_PROP = 'nodeValue';\nconst PARENT_NODE_PROP = 'parentNode';\nconst TAG_NAME_PROP = 'tagName';\nfunction textNodeContentsAreEqual(node, vnode, renderer) {\n    const { getProperty } = renderer;\n    const nodeValue = getProperty(node, NODE_VALUE_PROP);\n    if (nodeValue === vnode.text) {\n        return true;\n    }\n    // Special case for empty text nodes – these are serialized differently on the server\n    // See https://github.com/salesforce/lwc/pull/2656\n    if (nodeValue === '\\u200D' && vnode.text === '') {\n        return true;\n    }\n    // Special case for text nodes inside `<style>` tags – these are escaped when rendered server-size,\n    // but not when generated by the engine client-side.\n    const parentNode = getProperty(node, PARENT_NODE_PROP);\n    // Should never be null, but just to be safe, we check.\n    /* istanbul ignore else */\n    if (!isNull(parentNode)) {\n        const tagName = getProperty(parentNode, TAG_NAME_PROP);\n        // If the tagName is STYLE, then the following condition should always be true.\n        // The LWC compiler blocks using `<style>`s inside of templates, so it should be impossible\n        // for component authors to render different `<style>` text content on the client and server.\n        // But just to be safe, we check.\n        /* istanbul ignore next */\n        if (tagName === 'STYLE' && htmlEscape(vnode.text) === nodeValue) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction hydrateText(node, vnode, renderer) {\n    var _a;\n    if (!hasCorrectNodeType(vnode, node, 3 /* EnvNodeTypes.TEXT */, renderer)) {\n        return handleMismatch(node, vnode, renderer);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        if (!textNodeContentsAreEqual(node, vnode, renderer)) {\n            logWarn('Hydration mismatch: text values do not match, will recover from the difference', vnode.owner);\n        }\n    }\n    const { setText } = renderer;\n    setText(node, (_a = vnode.text) !== null && _a !== void 0 ? _a : null);\n    vnode.elm = node;\n    return node;\n}\nfunction hydrateComment(node, vnode, renderer) {\n    var _a;\n    if (!hasCorrectNodeType(vnode, node, 8 /* EnvNodeTypes.COMMENT */, renderer)) {\n        return handleMismatch(node, vnode, renderer);\n    }\n    if (process.env.NODE_ENV !== 'production') {\n        const { getProperty } = renderer;\n        const nodeValue = getProperty(node, NODE_VALUE_PROP);\n        if (nodeValue !== vnode.text) {\n            logWarn('Hydration mismatch: comment values do not match, will recover from the difference', vnode.owner);\n        }\n    }\n    const { setProperty } = renderer;\n    setProperty(node, NODE_VALUE_PROP, (_a = vnode.text) !== null && _a !== void 0 ? _a : null);\n    vnode.elm = node;\n    return node;\n}\nfunction hydrateStaticElement(elm, vnode, renderer) {\n    if (!areCompatibleNodes(vnode.fragment, elm, vnode, renderer)) {\n        return handleMismatch(elm, vnode, renderer);\n    }\n    vnode.elm = elm;\n    return elm;\n}\nfunction hydrateFragment(elm, vnode, renderer) {\n    const { children, owner } = vnode;\n    hydrateChildren(elm, children, renderer.getProperty(elm, 'parentNode'), owner);\n    return (vnode.elm = children[children.length - 1].elm);\n}\nfunction hydrateElement(elm, vnode, renderer) {\n    if (!hasCorrectNodeType(vnode, elm, 1 /* EnvNodeTypes.ELEMENT */, renderer) ||\n        !isMatchingElement(vnode, elm, renderer)) {\n        return handleMismatch(elm, vnode, renderer);\n    }\n    vnode.elm = elm;\n    const { owner } = vnode;\n    const { context } = vnode.data;\n    const isDomManual = Boolean(!isUndefined$1(context) && !isUndefined$1(context.lwc) && context.lwc.dom === \"manual\" /* LwcDomMode.Manual */);\n    if (isDomManual) {\n        // it may be that this element has lwc:inner-html, we need to diff and in case are the same,\n        // remove the innerHTML from props so it reuses the existing dom elements.\n        const { data: { props }, } = vnode;\n        const { getProperty } = renderer;\n        if (!isUndefined$1(props) && !isUndefined$1(props.innerHTML)) {\n            if (getProperty(elm, 'innerHTML') === props.innerHTML) {\n                // Do a shallow clone since VNodeData may be shared across VNodes due to hoist optimization\n                vnode.data = Object.assign(Object.assign({}, vnode.data), { props: cloneAndOmitKey(props, 'innerHTML') });\n            }\n            else {\n                if (process.env.NODE_ENV !== 'production') {\n                    logWarn(`Mismatch hydrating element <${getProperty(elm, 'tagName').toLowerCase()}>: innerHTML values do not match for element, will recover from the difference`, owner);\n                }\n            }\n        }\n    }\n    patchElementPropsAndAttrs(vnode, renderer);\n    if (!isDomManual) {\n        const { getFirstChild } = renderer;\n        hydrateChildren(getFirstChild(elm), vnode.children, elm, owner);\n    }\n    return elm;\n}\nfunction hydrateCustomElement(elm, vnode, renderer) {\n    if (!hasCorrectNodeType(vnode, elm, 1 /* EnvNodeTypes.ELEMENT */, renderer) ||\n        !isMatchingElement(vnode, elm, renderer)) {\n        return handleMismatch(elm, vnode, renderer);\n    }\n    const { sel, mode, ctor, owner } = vnode;\n    const vm = createVM(elm, ctor, renderer, {\n        mode,\n        owner,\n        tagName: sel,\n        hydrated: true,\n    });\n    vnode.elm = elm;\n    vnode.vm = vm;\n    allocateChildren(vnode, vm);\n    patchElementPropsAndAttrs(vnode, renderer);\n    // Insert hook section:\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(vm.state === 0 /* VMState.created */, `${vm} cannot be recycled.`);\n    }\n    runConnectedCallback(vm);\n    if (vm.renderMode !== 0 /* RenderMode.Light */) {\n        const { getFirstChild } = renderer;\n        // VM is not rendering in Light DOM, we can proceed and hydrate the slotted content.\n        // Note: for Light DOM, this is handled while hydrating the VM\n        hydrateChildren(getFirstChild(elm), vnode.children, elm, vm);\n    }\n    hydrateVM(vm);\n    return elm;\n}\nfunction hydrateChildren(node, children, parentNode, owner) {\n    let hasWarned = false;\n    let nextNode = node;\n    let anchor = null;\n    const { renderer } = owner;\n    for (let i = 0; i < children.length; i++) {\n        const childVnode = children[i];\n        if (!isNull(childVnode)) {\n            if (nextNode) {\n                nextNode = hydrateNode(nextNode, childVnode, renderer);\n                anchor = childVnode.elm;\n            }\n            else {\n                hasMismatch = true;\n                if (process.env.NODE_ENV !== 'production') {\n                    if (!hasWarned) {\n                        hasWarned = true;\n                        logError(`Hydration mismatch: incorrect number of rendered nodes. Client produced more nodes than the server.`, owner);\n                    }\n                }\n                mount(childVnode, parentNode, renderer, anchor);\n                anchor = childVnode.elm;\n            }\n        }\n    }\n    if (nextNode) {\n        hasMismatch = true;\n        if (process.env.NODE_ENV !== 'production') {\n            if (!hasWarned) {\n                logError(`Hydration mismatch: incorrect number of rendered nodes. Server rendered more nodes than the client.`, owner);\n            }\n        }\n        // nextSibling is mostly harmless, and since we don't have\n        // a good reference to what element to act upon, we instead\n        // rely on the vm's associated renderer for navigating to the\n        // next node in the list to be hydrated.\n        const { nextSibling } = renderer;\n        do {\n            const current = nextNode;\n            nextNode = nextSibling(nextNode);\n            removeNode(current, parentNode, renderer);\n        } while (nextNode);\n    }\n}\nfunction handleMismatch(node, vnode, renderer) {\n    hasMismatch = true;\n    const { getProperty } = renderer;\n    const parentNode = getProperty(node, 'parentNode');\n    mount(vnode, parentNode, renderer, node);\n    removeNode(node, parentNode, renderer);\n    return vnode.elm;\n}\nfunction patchElementPropsAndAttrs(vnode, renderer) {\n    applyEventListeners(vnode, renderer);\n    patchProps(null, vnode, renderer);\n}\nfunction hasCorrectNodeType(vnode, node, nodeType, renderer) {\n    const { getProperty } = renderer;\n    if (getProperty(node, 'nodeType') !== nodeType) {\n        if (process.env.NODE_ENV !== 'production') {\n            logError('Hydration mismatch: incorrect node type received', vnode.owner);\n        }\n        return false;\n    }\n    return true;\n}\nfunction isMatchingElement(vnode, elm, renderer) {\n    const { getProperty } = renderer;\n    if (vnode.sel.toLowerCase() !== getProperty(elm, 'tagName').toLowerCase()) {\n        if (process.env.NODE_ENV !== 'production') {\n            logError(`Hydration mismatch: expecting element with tag \"${vnode.sel.toLowerCase()}\" but found \"${getProperty(elm, 'tagName').toLowerCase()}\".`, vnode.owner);\n        }\n        return false;\n    }\n    const hasIncompatibleAttrs = validateAttrs(vnode, elm, renderer);\n    const hasIncompatibleClass = validateClassAttr(vnode, elm, renderer);\n    const hasIncompatibleStyle = validateStyleAttr(vnode, elm, renderer);\n    return hasIncompatibleAttrs && hasIncompatibleClass && hasIncompatibleStyle;\n}\nfunction attributeValuesAreEqual(vnodeValue, value) {\n    const vnodeValueAsString = String(vnodeValue);\n    if (vnodeValueAsString === value) {\n        return true;\n    }\n    // If the expected value is null, this means that the attribute does not exist. In that case,\n    // we accept any nullish value (undefined or null).\n    if (isNull(value) && (isUndefined$1(vnodeValue) || isNull(vnodeValue))) {\n        return true;\n    }\n    // In all other cases, the two values are not considered equal\n    return false;\n}\nfunction validateAttrs(vnode, elm, renderer) {\n    const { data: { attrs = {} }, } = vnode;\n    let nodesAreCompatible = true;\n    // Validate attributes, though we could always recovery from those by running the update mods.\n    // Note: intentionally ONLY matching vnodes.attrs to elm.attrs, in case SSR is adding extra attributes.\n    for (const [attrName, attrValue] of Object.entries(attrs)) {\n        const { owner } = vnode;\n        const { getAttribute } = renderer;\n        const elmAttrValue = getAttribute(elm, attrName);\n        if (!attributeValuesAreEqual(attrValue, elmAttrValue)) {\n            if (process.env.NODE_ENV !== 'production') {\n                const { getProperty } = renderer;\n                logError(`Mismatch hydrating element <${getProperty(elm, 'tagName').toLowerCase()}>: attribute \"${attrName}\" has different values, expected \"${attrValue}\" but found ${isNull(elmAttrValue) ? 'null' : `\"${elmAttrValue}\"`}`, owner);\n            }\n            nodesAreCompatible = false;\n        }\n    }\n    return nodesAreCompatible;\n}\nfunction validateClassAttr(vnode, elm, renderer) {\n    const { data, owner } = vnode;\n    let { className, classMap } = data;\n    const { getProperty, getClassList } = renderer;\n    const scopedToken = getScopeTokenClass(owner);\n    const stylesheetTokenHost = isVCustomElement(vnode) ? getStylesheetTokenHost(vnode) : null;\n    // Classnames for scoped CSS are added directly to the DOM during rendering,\n    // or to the VDOM on the server in the case of SSR. As such, these classnames\n    // are never present in VDOM nodes in the browser.\n    //\n    // Consequently, hydration mismatches will occur if scoped CSS token classnames\n    // are rendered during SSR. This needs to be accounted for when validating.\n    if (!isNull(scopedToken) || !isNull(stylesheetTokenHost)) {\n        if (!isUndefined$1(className)) {\n            // The order of the className should be scopedToken className stylesheetTokenHost\n            const classTokens = [scopedToken, className, stylesheetTokenHost];\n            const classNames = ArrayFilter.call(classTokens, (token) => !isNull(token));\n            className = ArrayJoin.call(classNames, ' ');\n        }\n        else if (!isUndefined$1(classMap)) {\n            classMap = Object.assign(Object.assign(Object.assign({}, classMap), (!isNull(scopedToken) ? { [scopedToken]: true } : {})), (!isNull(stylesheetTokenHost) ? { [stylesheetTokenHost]: true } : {}));\n        }\n        else {\n            // The order of the className should be scopedToken stylesheetTokenHost\n            const classTokens = [scopedToken, stylesheetTokenHost];\n            const classNames = ArrayFilter.call(classTokens, (token) => !isNull(token));\n            if (classNames.length) {\n                className = ArrayJoin.call(classNames, ' ');\n            }\n        }\n    }\n    let nodesAreCompatible = true;\n    let readableVnodeClassname;\n    const elmClassName = getProperty(elm, 'className');\n    if (!isUndefined$1(className) && String(className) !== elmClassName) {\n        // className is used when class is bound to an expr.\n        nodesAreCompatible = false;\n        readableVnodeClassname = className;\n    }\n    else if (!isUndefined$1(classMap)) {\n        // classMap is used when class is set to static value.\n        const classList = getClassList(elm);\n        let computedClassName = '';\n        // all classes from the vnode should be in the element.classList\n        for (const name in classMap) {\n            computedClassName += ' ' + name;\n            if (!classList.contains(name)) {\n                nodesAreCompatible = false;\n            }\n        }\n        readableVnodeClassname = computedClassName.trim();\n        if (classList.length > keys(classMap).length) {\n            nodesAreCompatible = false;\n        }\n    }\n    else if (isUndefined$1(className) && elmClassName !== '') {\n        // SSR contains a className but client-side VDOM does not\n        nodesAreCompatible = false;\n        readableVnodeClassname = '';\n    }\n    if (!nodesAreCompatible) {\n        if (process.env.NODE_ENV !== 'production') {\n            logError(`Mismatch hydrating element <${getProperty(elm, 'tagName').toLowerCase()}>: attribute \"class\" has different values, expected \"${readableVnodeClassname}\" but found \"${elmClassName}\"`, vnode.owner);\n        }\n    }\n    return nodesAreCompatible;\n}\nfunction validateStyleAttr(vnode, elm, renderer) {\n    const { data: { style, styleDecls }, } = vnode;\n    const { getAttribute } = renderer;\n    const elmStyle = getAttribute(elm, 'style') || '';\n    let vnodeStyle;\n    let nodesAreCompatible = true;\n    if (!isUndefined$1(style) && style !== elmStyle) {\n        nodesAreCompatible = false;\n        vnodeStyle = style;\n    }\n    else if (!isUndefined$1(styleDecls)) {\n        const parsedVnodeStyle = parseStyleText(elmStyle);\n        const expectedStyle = [];\n        // styleMap is used when style is set to static value.\n        for (let i = 0, n = styleDecls.length; i < n; i++) {\n            const [prop, value, important] = styleDecls[i];\n            expectedStyle.push(`${prop}: ${value + (important ? ' important!' : '')}`);\n            const parsedPropValue = parsedVnodeStyle[prop];\n            if (isUndefined$1(parsedPropValue)) {\n                nodesAreCompatible = false;\n            }\n            else if (!parsedPropValue.startsWith(value)) {\n                nodesAreCompatible = false;\n            }\n            else if (important && !parsedPropValue.endsWith('!important')) {\n                nodesAreCompatible = false;\n            }\n        }\n        if (keys(parsedVnodeStyle).length > styleDecls.length) {\n            nodesAreCompatible = false;\n        }\n        vnodeStyle = ArrayJoin.call(expectedStyle, ';');\n    }\n    if (!nodesAreCompatible) {\n        if (process.env.NODE_ENV !== 'production') {\n            const { getProperty } = renderer;\n            logError(`Mismatch hydrating element <${getProperty(elm, 'tagName').toLowerCase()}>: attribute \"style\" has different values, expected \"${vnodeStyle}\" but found \"${elmStyle}\".`, vnode.owner);\n        }\n    }\n    return nodesAreCompatible;\n}\nfunction areCompatibleNodes(client, ssr, vnode, renderer) {\n    const { getProperty, getAttribute } = renderer;\n    if (getProperty(client, 'nodeType') === 3 /* EnvNodeTypes.TEXT */) {\n        if (!hasCorrectNodeType(vnode, ssr, 3 /* EnvNodeTypes.TEXT */, renderer)) {\n            return false;\n        }\n        return getProperty(client, NODE_VALUE_PROP) === getProperty(ssr, NODE_VALUE_PROP);\n    }\n    if (getProperty(client, 'nodeType') === 8 /* EnvNodeTypes.COMMENT */) {\n        if (!hasCorrectNodeType(vnode, ssr, 8 /* EnvNodeTypes.COMMENT */, renderer)) {\n            return false;\n        }\n        return getProperty(client, NODE_VALUE_PROP) === getProperty(ssr, NODE_VALUE_PROP);\n    }\n    if (!hasCorrectNodeType(vnode, ssr, 1 /* EnvNodeTypes.ELEMENT */, renderer)) {\n        return false;\n    }\n    let isCompatibleElements = true;\n    if (getProperty(client, 'tagName') !== getProperty(ssr, 'tagName')) {\n        if (process.env.NODE_ENV !== 'production') {\n            logError(`Hydration mismatch: expecting element with tag \"${getProperty(client, 'tagName').toLowerCase()}\" but found \"${getProperty(ssr, 'tagName').toLowerCase()}\".`, vnode.owner);\n        }\n        return false;\n    }\n    const clientAttrsNames = getProperty(client, 'getAttributeNames').call(client);\n    clientAttrsNames.forEach((attrName) => {\n        if (getAttribute(client, attrName) !== getAttribute(ssr, attrName)) {\n            logError(`Mismatch hydrating element <${getProperty(client, 'tagName').toLowerCase()}>: attribute \"${attrName}\" has different values, expected \"${getAttribute(client, attrName)}\" but found \"${getAttribute(ssr, attrName)}\"`, vnode.owner);\n            isCompatibleElements = false;\n        }\n    });\n    return isCompatibleElements;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet hooksAreSet = false;\nfunction setHooks(hooks) {\n    assert.isFalse(hooksAreSet, 'Hooks are already overridden, only one definition is allowed.');\n    hooksAreSet = true;\n    setSanitizeHtmlContentHook(hooks.sanitizeHtmlContent);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// See @lwc/engine-core/src/framework/template.ts\nconst TEMPLATE_PROPS = ['slots', 'stylesheetToken', 'stylesheets', 'renderMode'];\n// Expandos that may be placed on a stylesheet factory function, and which are meaningful to LWC at runtime\nconst STYLESHEET_PROPS = [\n    // SEE `KEY__SCOPED_CSS` in @lwc/style-compiler\n    '$scoped$',\n];\n// Via https://www.npmjs.com/package/object-observer\nconst ARRAY_MUTATION_METHODS = [\n    'pop',\n    'push',\n    'shift',\n    'unshift',\n    'reverse',\n    'sort',\n    'fill',\n    'splice',\n    'copyWithin',\n];\nlet mutationTrackingDisabled = false;\nfunction getOriginalArrayMethod(prop) {\n    switch (prop) {\n        case 'pop':\n            return ArrayPop;\n        case 'push':\n            return ArrayPush$1;\n        case 'shift':\n            return ArrayShift;\n        case 'unshift':\n            return ArrayUnshift;\n        case 'reverse':\n            return ArrayReverse;\n        case 'sort':\n            return ArraySort;\n        case 'fill':\n            return ArrayFill;\n        case 'splice':\n            return ArraySplice;\n        case 'copyWithin':\n            return ArrayCopyWithin;\n    }\n}\nfunction reportViolation(type, eventId, prop) {\n    if (process.env.NODE_ENV !== 'production') {\n        logWarnOnce(`Mutating the \"${prop}\" property on a ${type} ` +\n            `is deprecated and will be removed in a future version of LWC. ` +\n            `See: https://sfdc.co/template-mutation`);\n    }\n    report(eventId, { propertyName: prop });\n}\nfunction reportTemplateViolation(prop) {\n    reportViolation('template', \"TemplateMutation\" /* ReportingEventId.TemplateMutation */, prop);\n}\nfunction reportStylesheetViolation(prop) {\n    reportViolation('stylesheet', \"StylesheetMutation\" /* ReportingEventId.StylesheetMutation */, prop);\n}\n// Warn if the user tries to mutate a stylesheets array, e.g.:\n// `tmpl.stylesheets.push(someStylesheetFunction)`\nfunction warnOnArrayMutation(stylesheets) {\n    // We can't handle users calling Array.prototype.slice.call(tmpl.stylesheets), but\n    // we can at least warn when they use the most common mutation methods.\n    for (const prop of ARRAY_MUTATION_METHODS) {\n        const originalArrayMethod = getOriginalArrayMethod(prop);\n        stylesheets[prop] = function arrayMutationWarningWrapper() {\n            reportTemplateViolation('stylesheets');\n            // @ts-ignore\n            return originalArrayMethod.apply(this, arguments);\n        };\n    }\n}\n// Warn if the user tries to mutate a stylesheet factory function, e.g.:\n// `stylesheet.$scoped$ = true`\nfunction warnOnStylesheetFunctionMutation(stylesheet) {\n    for (const prop of STYLESHEET_PROPS) {\n        let value = stylesheet[prop];\n        defineProperty(stylesheet, prop, {\n            enumerable: true,\n            configurable: true,\n            get() {\n                return value;\n            },\n            set(newValue) {\n                reportStylesheetViolation(prop);\n                value = newValue;\n            },\n        });\n    }\n}\n// Warn on either array or stylesheet (function) mutation, in a deeply-nested array\nfunction trackStylesheetsMutation(stylesheets) {\n    traverseStylesheets(stylesheets, (subStylesheets) => {\n        if (isArray$1(subStylesheets)) {\n            warnOnArrayMutation(subStylesheets);\n        }\n        else {\n            warnOnStylesheetFunctionMutation(subStylesheets);\n        }\n    });\n}\n// Deeply freeze the entire array (of arrays) of stylesheet factory functions\nfunction deepFreeze(stylesheets) {\n    traverseStylesheets(stylesheets, (subStylesheets) => {\n        freeze(subStylesheets);\n    });\n}\n// Deep-traverse an array (of arrays) of stylesheet factory functions, and call the callback for every array/function\nfunction traverseStylesheets(stylesheets, callback) {\n    callback(stylesheets);\n    for (let i = 0; i < stylesheets.length; i++) {\n        const stylesheet = stylesheets[i];\n        if (isArray$1(stylesheet)) {\n            traverseStylesheets(stylesheet, callback);\n        }\n        else {\n            callback(stylesheet);\n        }\n    }\n}\nfunction trackMutations(tmpl) {\n    if (!isUndefined$1(tmpl.stylesheets)) {\n        trackStylesheetsMutation(tmpl.stylesheets);\n    }\n    for (const prop of TEMPLATE_PROPS) {\n        let value = tmpl[prop];\n        defineProperty(tmpl, prop, {\n            enumerable: true,\n            configurable: true,\n            get() {\n                return value;\n            },\n            set(newValue) {\n                if (!mutationTrackingDisabled) {\n                    reportTemplateViolation(prop);\n                }\n                value = newValue;\n            },\n        });\n    }\n    const originalDescriptor = getOwnPropertyDescriptor$1(tmpl, 'stylesheetTokens');\n    defineProperty(tmpl, 'stylesheetTokens', {\n        enumerable: true,\n        configurable: true,\n        get: originalDescriptor.get,\n        set(value) {\n            reportTemplateViolation('stylesheetTokens');\n            // Avoid logging/reporting twice (for both stylesheetToken and stylesheetTokens)\n            mutationTrackingDisabled = true;\n            originalDescriptor.set.call(this, value);\n            mutationTrackingDisabled = false;\n        },\n    });\n}\nfunction addLegacyStylesheetTokensShim(tmpl) {\n    // When ENABLE_FROZEN_TEMPLATE is false, then we shim stylesheetTokens on top of stylesheetToken for anyone who\n    // is accessing the old internal API (backwards compat). Details: https://salesforce.quip.com/v1rmAFu2cKAr\n    defineProperty(tmpl, 'stylesheetTokens', {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const { stylesheetToken } = this;\n            if (isUndefined$1(stylesheetToken)) {\n                return stylesheetToken;\n            }\n            // Shim for the old `stylesheetTokens` property\n            // See https://github.com/salesforce/lwc/pull/2332/files#diff-7901555acef29969adaa6583185b3e9bce475cdc6f23e799a54e0018cb18abaa\n            return {\n                hostAttribute: `${stylesheetToken}-host`,\n                shadowAttribute: stylesheetToken,\n            };\n        },\n        set(value) {\n            // If the value is null or some other exotic object, you would be broken anyway in the past\n            // because the engine would try to access hostAttribute/shadowAttribute, which would throw an error.\n            // However it may be undefined in newer versions of LWC, so we need to guard against that case.\n            this.stylesheetToken = isUndefined$1(value) ? undefined : value.shadowAttribute;\n        },\n    });\n}\nfunction freezeTemplate(tmpl) {\n    // TODO [#2782]: remove this flag and delete the legacy behavior\n    if (lwcRuntimeFlags.ENABLE_FROZEN_TEMPLATE) {\n        // Deep freeze the template\n        freeze(tmpl);\n        if (!isUndefined$1(tmpl.stylesheets)) {\n            deepFreeze(tmpl.stylesheets);\n        }\n    }\n    else {\n        // template is not frozen - shim, report, and warn\n        // this shim should be applied in both dev and prod\n        addLegacyStylesheetTokensShim(tmpl);\n        // When ENABLE_FROZEN_TEMPLATE is false, we want to warn in dev mode whenever someone is mutating the template\n        if (process.env.NODE_ENV !== 'production') {\n            trackMutations(tmpl);\n        }\n        else {\n            // In prod mode, we only track mutations if reporting is enabled\n            onReportingEnabled(() => {\n                trackMutations(tmpl);\n            });\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * EXPERIMENTAL: This function provides access to the component constructor, given an HTMLElement.\n * This API is subject to change or being removed.\n */\nfunction getComponentConstructor(elm) {\n    let ctor = null;\n    // intentionally checking for undefined due to some funky libraries patching weakmap.get\n    // to throw when undefined.\n    if (!isUndefined$1(elm)) {\n        const vm = getAssociatedVMIfPresent(elm);\n        if (!isUndefined$1(vm)) {\n            ctor = vm.def.ctor;\n        }\n    }\n    return ctor;\n}\n/* version: 2.37.3 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * Displays the header for a custom element.\n *\n * @param ce the custom element\n * @param componentInstance component instance associated with the custom element.\n */\nfunction getHeaderForCustomElement(ce, componentInstance) {\n    // [element]\n    // LWC component instance: [vm.component]\n    return [\n        'div',\n        {},\n        ['object', { object: ce, config: { skip: true } }],\n        [\n            'div',\n            {},\n            ['span', { style: 'margin: 0 5px; color: red' }, 'LWC:'],\n            ['object', { object: componentInstance }],\n        ],\n    ];\n}\nfunction getHeaderForComponentInstance(componentInstance, debugInfo) {\n    if (keys(debugInfo).length === 0) {\n        // there is no debug information, no need to customize this component instance\n        return null;\n    }\n    // [component]\n    // Debug information: [vm.debugInfo]\n    return [\n        'div',\n        {},\n        ['object', { object: componentInstance, config: { skip: true } }],\n        [\n            'div',\n            {},\n            ['span', { style: 'margin: 0 5px; color: red' }, 'Debug:'],\n            ['object', { object: debugInfo }],\n        ],\n    ];\n}\nconst LightningElementFormatter = {\n    name: 'LightningElementFormatter',\n    header(obj, config) {\n        const vm = getAssociatedVMIfPresent(obj);\n        if (!isUndefined$1(vm) && (isUndefined$1(config) || !config.skip)) {\n            if (obj instanceof HTMLElement) {\n                return getHeaderForCustomElement(obj, vm.component);\n            }\n            else {\n                return getHeaderForComponentInstance(obj, vm.debugInfo);\n            }\n        }\n        return null;\n    },\n    hasBody() {\n        return false;\n    },\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction init() {\n    const devtoolsFormatters = _globalThis.devtoolsFormatters || [];\n    ArrayPush$1.call(devtoolsFormatters, LightningElementFormatter);\n    _globalThis.devtoolsFormatters = devtoolsFormatters;\n}\nif (process.env.NODE_ENV !== 'production') {\n    init();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n//\n// Feature detection\n//\n// This check for constructable style sheets is similar to Fast's:\n// https://github.com/microsoft/fast/blob/d49d1ec/packages/web-components/fast-element/src/dom.ts#L51-L53\n// See also: https://github.com/whatwg/webidl/issues/1027#issuecomment-934510070\nconst supportsConstructableStylesheets = isFunction$1(CSSStyleSheet.prototype.replaceSync) && isArray$1(document.adoptedStyleSheets);\n// The original adoptedStylesheet proposal used a frozen array. A follow-up proposal made the array mutable.\n// Chromium 99+ and Firefox 101+ support mutable arrays. We check if the array is mutable, to ensure backward compat.\n// (If the length is writable, then the array is mutable.) See: https://chromestatus.com/feature/5638996492288000\n// TODO [#2828]: Re-evaluate this in the future once we drop support for older browser versions.\nconst supportsMutableAdoptedStyleSheets = supportsConstructableStylesheets &&\n    getOwnPropertyDescriptor$1(document.adoptedStyleSheets, 'length').writable;\n// Detect IE, via https://stackoverflow.com/a/9851769\nconst isIE11 = !isUndefined$1(document.documentMode);\nconst stylesheetCache = new Map();\n//\n// Test utilities\n//\n// Only used in LWC's Karma tests\nif (process.env.NODE_ENV === 'test-karma-lwc') {\n    // @ts-ignore\n    window.__lwcResetGlobalStylesheets = () => {\n        stylesheetCache.clear();\n    };\n}\nfunction createFreshStyleElement(content) {\n    const elm = document.createElement('style');\n    elm.type = 'text/css';\n    elm.textContent = content;\n    return elm;\n}\nfunction createStyleElement(content, cacheData) {\n    const { element, usedElement } = cacheData;\n    // If the <style> was already used, then we should clone it. We cannot insert\n    // the same <style> in two places in the DOM.\n    if (usedElement) {\n        // For a mysterious reason, IE11 doesn't like the way we clone <style> nodes\n        // and will render the incorrect styles if we do things that way. It's just\n        // a perf optimization, so we can skip it for IE11.\n        if (isIE11) {\n            return createFreshStyleElement(content);\n        }\n        // This `<style>` may be repeated multiple times in the DOM, so cache it. It's a bit\n        // faster to call `cloneNode()` on an existing node than to recreate it every time.\n        return element.cloneNode(true);\n    }\n    // We don't clone every time, because that would be a perf tax on the first time\n    cacheData.usedElement = true;\n    return element;\n}\nfunction createConstructableStylesheet(content) {\n    const stylesheet = new CSSStyleSheet();\n    stylesheet.replaceSync(content);\n    return stylesheet;\n}\nfunction insertConstructableStylesheet(content, target, cacheData) {\n    const { adoptedStyleSheets } = target;\n    const { stylesheet } = cacheData;\n    // Mutable adopted stylesheets are only supported in certain browsers.\n    // The reason we use it is for perf: https://github.com/salesforce/lwc/pull/2683\n    if (supportsMutableAdoptedStyleSheets) {\n        adoptedStyleSheets.push(stylesheet);\n    }\n    else {\n        target.adoptedStyleSheets = [...adoptedStyleSheets, stylesheet];\n    }\n}\nfunction insertStyleElement(content, target, cacheData) {\n    const elm = createStyleElement(content, cacheData);\n    target.appendChild(elm);\n}\nfunction getCacheData(content, useConstructableStylesheet) {\n    let cacheData = stylesheetCache.get(content);\n    if (isUndefined$1(cacheData)) {\n        cacheData = {\n            stylesheet: undefined,\n            element: undefined,\n            roots: undefined,\n            global: false,\n            usedElement: false,\n        };\n        stylesheetCache.set(content, cacheData);\n    }\n    // Create <style> elements or CSSStyleSheets on-demand, as needed\n    if (useConstructableStylesheet && isUndefined$1(cacheData.stylesheet)) {\n        cacheData.stylesheet = createConstructableStylesheet(content);\n    }\n    else if (!useConstructableStylesheet && isUndefined$1(cacheData.element)) {\n        cacheData.element = createFreshStyleElement(content);\n    }\n    return cacheData;\n}\nfunction insertGlobalStylesheet(content) {\n    // Force a <style> element for global stylesheets. See comment below.\n    const cacheData = getCacheData(content, false);\n    if (cacheData.global) {\n        // already inserted\n        return;\n    }\n    cacheData.global = true; // mark inserted\n    // TODO [#2922]: use document.adoptedStyleSheets in supported browsers. Currently we can't, due to backwards compat.\n    insertStyleElement(content, document.head, cacheData);\n}\nfunction insertLocalStylesheet(content, target) {\n    const cacheData = getCacheData(content, supportsConstructableStylesheets);\n    let { roots } = cacheData;\n    if (isUndefined$1(roots)) {\n        roots = cacheData.roots = new WeakSet(); // lazily initialize (not needed for global styles)\n    }\n    else if (roots.has(target)) {\n        // already inserted\n        return;\n    }\n    roots.add(target); // mark inserted\n    // Constructable stylesheets are only supported in certain browsers:\n    // https://caniuse.com/mdn-api_document_adoptedstylesheets\n    // The reason we use it is for perf: https://github.com/salesforce/lwc/pull/2460\n    if (supportsConstructableStylesheets) {\n        insertConstructableStylesheet(content, target, cacheData);\n    }\n    else {\n        // Fall back to <style> element\n        insertStyleElement(content, target, cacheData);\n    }\n}\nfunction insertStylesheet(content, target) {\n    if (isUndefined$1(target)) {\n        // global\n        insertGlobalStylesheet(content);\n    }\n    else {\n        // local\n        insertLocalStylesheet(content, target);\n    }\n}\n\n/*\n * Copyright (c) 2020, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction isCustomElementRegistryAvailable() {\n    if (typeof customElements === 'undefined') {\n        return false;\n    }\n    try {\n        // dereference HTMLElement global because babel wraps globals in compat mode with a\n        // _wrapNativeSuper()\n        // This is a problem because LWCUpgradableElement extends renderer.HTMLElement which does not\n        // get wrapped by babel.\n        const HTMLElementAlias = HTMLElement;\n        // In case we use compat mode with a modern browser, the compat mode transformation\n        // invokes the DOM api with an .apply() or .call() to initialize any DOM api sub-classing,\n        // which are not equipped to be initialized that way.\n        class clazz extends HTMLElementAlias {\n        }\n        customElements.define('lwc-test-' + Math.floor(Math.random() * 1000000), clazz);\n        new clazz();\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nconst hasCustomElements = isCustomElementRegistryAvailable();\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Creates a custom element for compat (legacy) browser environments\nconst createCustomElementCompat = (tagName, upgradeCallback) => {\n    const elm = document.createElement(tagName);\n    upgradeCallback(elm); // nothing to do with the result for now\n    return elm;\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst cachedConstructors = new Map();\nconst elementsUpgradedOutsideLWC = new WeakSet();\nlet elementBeingUpgradedByLWC = false;\n// Creates a constructor that is intended to be used directly as a custom element, except that the upgradeCallback is\n// passed in to the constructor so LWC can reuse the same custom element constructor for multiple components.\n// Another benefit is that only LWC can create components that actually do anything – if you do\n// `customElements.define('x-foo')`, then you don't have access to the upgradeCallback, so it's a dummy custom element.\n// This class should be created once per tag name.\nconst createUpgradableConstructor = (connectedCallback, disconnectedCallback) => {\n    const hasConnectedCallback = !isUndefined$1(connectedCallback);\n    const hasDisconnectedCallback = !isUndefined$1(disconnectedCallback);\n    // TODO [#2972]: this class should expose observedAttributes as necessary\n    class UpgradableConstructor extends HTMLElement {\n        constructor(upgradeCallback) {\n            super();\n            // If the element is not created using lwc.createElement(), e.g. `document.createElement('x-foo')`,\n            // then elementBeingUpgraded will be false\n            if (elementBeingUpgradedByLWC) {\n                upgradeCallback(this);\n            }\n            else if (hasConnectedCallback || hasDisconnectedCallback) {\n                // If this element has connected or disconnected callbacks, then we need to keep track of\n                // instances that were created outside LWC (i.e. not created by `lwc.createElement()`).\n                // If the element has no connected or disconnected callbacks, then we don't need to track this.\n                elementsUpgradedOutsideLWC.add(this);\n                // TODO [#2970]: LWC elements cannot be upgraded via new Ctor()\n                // Do we want to support this? Throw an error? Currently for backwards compat it's a no-op.\n            }\n        }\n    }\n    // Do not unnecessarily add a connectedCallback/disconnectedCallback, as it introduces perf overhead\n    // See: https://github.com/salesforce/lwc/pull/3162#issuecomment-1311851174\n    if (hasConnectedCallback) {\n        UpgradableConstructor.prototype.connectedCallback = function () {\n            if (!elementsUpgradedOutsideLWC.has(this)) {\n                connectedCallback(this);\n            }\n        };\n    }\n    if (hasDisconnectedCallback) {\n        UpgradableConstructor.prototype.disconnectedCallback = function () {\n            if (!elementsUpgradedOutsideLWC.has(this)) {\n                disconnectedCallback(this);\n            }\n        };\n    }\n    return UpgradableConstructor;\n};\nconst createCustomElementUsingUpgradableConstructor = (tagName, upgradeCallback, connectedCallback, disconnectedCallback) => {\n    // use global custom elements registry\n    let UpgradableConstructor = cachedConstructors.get(tagName);\n    if (isUndefined$1(UpgradableConstructor)) {\n        if (!isUndefined$1(customElements.get(tagName))) {\n            throw new Error(`Unexpected tag name \"${tagName}\". This name is a registered custom element, preventing LWC to upgrade the element.`);\n        }\n        UpgradableConstructor = createUpgradableConstructor(connectedCallback, disconnectedCallback);\n        customElements.define(tagName, UpgradableConstructor);\n        cachedConstructors.set(tagName, UpgradableConstructor);\n    }\n    elementBeingUpgradedByLWC = true;\n    try {\n        return new UpgradableConstructor(upgradeCallback);\n    }\n    finally {\n        elementBeingUpgradedByLWC = false;\n    }\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * We have two modes for creating custom elements:\n *\n * 1. Compat (legacy) browser support (e.g. IE11). Totally custom, doesn't rely on native browser APIs.\n * 2. \"Upgradable constructor\" custom element. This allows us to have two LWC components with the same tag name,\n *    via a trick: every custom element constructor we define in the registry is basically the same. It's essentially\n *    a dummy `class extends HTMLElement` that accepts an `upgradeCallback` in its constructor (\"upgradable\n *    constructor\"), which allows us to have completely customized functionality for different components.\n */\nlet createCustomElement;\nif (hasCustomElements) {\n    // use the global registry, with an upgradable constructor for the defined custom element\n    createCustomElement = createCustomElementUsingUpgradableConstructor;\n}\nelse {\n    // no registry available here\n    createCustomElement = createCustomElementCompat;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * A factory function that produces a renderer.\n * Renderer encapsulates operations that are required to render an LWC component into the underlying\n * runtime environment. In the case of @lwc/enigne-dom, it is meant to be used in a DOM environment.\n * Example usage:\n * import { renderer, rendererFactory } from 'lwc';\n * const customRenderer = rendererFactory(renderer);\n *\n * @param baseRenderer Either null or the base renderer imported from 'lwc'.\n */\nfunction rendererFactory(baseRenderer) {\n    const renderer = (function (exports) {\n\n    /**\n     * Copyright (C) 2018 salesforce.com, inc.\n     */\n    /*\n     * Copyright (c) 2018, salesforce.com, inc.\n     * All rights reserved.\n     * SPDX-License-Identifier: MIT\n     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n     */\n    function invariant(value, msg) {\n        if (!value) {\n            throw new Error(`Invariant Violation: ${msg}`);\n        }\n    }\n    function isTrue$1(value, msg) {\n        if (!value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    }\n    function isFalse$1(value, msg) {\n        if (value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    }\n    function fail(msg) {\n        throw new Error(msg);\n    }\n\n    var assert = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        fail: fail,\n        invariant: invariant,\n        isFalse: isFalse$1,\n        isTrue: isTrue$1\n    });\n    function isUndefined(obj) {\n        return obj === undefined;\n    }\n    function isNull(obj) {\n        return obj === null;\n    }\n    /** version: 2.37.3 */\n\n    /*\n     * Copyright (c) 2018, salesforce.com, inc.\n     * All rights reserved.\n     * SPDX-License-Identifier: MIT\n     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n     */\n    function cloneNode(node, deep) {\n        return node.cloneNode(deep);\n    }\n    function createElement(tagName, namespace) {\n        return isUndefined(namespace)\n            ? document.createElement(tagName)\n            : document.createElementNS(namespace, tagName);\n    }\n    function createText(content) {\n        return document.createTextNode(content);\n    }\n    function createComment(content) {\n        return document.createComment(content);\n    }\n    exports.createFragment = void 0;\n    // IE11 lacks support for this feature\n    const SUPPORTS_TEMPLATE = typeof HTMLTemplateElement === 'function';\n    if (SUPPORTS_TEMPLATE) {\n        // Parse the fragment HTML string into DOM\n        exports.createFragment = function (html) {\n            const template = document.createElement('template');\n            template.innerHTML = html;\n            return template.content.firstChild;\n        };\n    }\n    else {\n        // In browsers that don't support <template> (e.g. IE11), we need to be careful to wrap elements like\n        // <td> in the proper container elements (e.g. <tbody>), because otherwise they will be parsed as null.\n        // Via https://github.com/webcomponents/polyfills/blob/ee1db33/packages/template/template.js#L273-L280\n        // With other elements added from:\n        // https://github.com/sindresorhus/html-tags/blob/95dcdd5/index.js\n        // Using the test:\n        // document.createRange().createContextualFragment(`<${tag}></${tag}>`).firstChild === null\n        // And omitting <html>, <head>, and <body> as these are not practical in an LWC component.\n        const topLevelWrappingMap = {\n            caption: ['table'],\n            col: ['colgroup', 'table'],\n            colgroup: ['table'],\n            option: ['select'],\n            tbody: ['table'],\n            td: ['tr', 'tbody', 'table'],\n            th: ['tr', 'tbody', 'table'],\n            thead: ['table'],\n            tfoot: ['table'],\n            tr: ['tbody', 'table'],\n        };\n        // Via https://github.com/webcomponents/polyfills/blob/ee1db33/packages/template/template.js#L282-L288\n        const getTagName = function (text) {\n            return (/<([a-z][^/\\0>\\x20\\t\\r\\n\\f]+)/i.exec(text) || ['', ''])[1].toLowerCase();\n        };\n        // Via https://github.com/webcomponents/polyfills/blob/ee1db33/packages/template/template.js#L295-L320\n        exports.createFragment = function (html) {\n            const wrapperTags = topLevelWrappingMap[getTagName(html)];\n            if (!isUndefined(wrapperTags)) {\n                for (const wrapperTag of wrapperTags) {\n                    html = `<${wrapperTag}>${html}</${wrapperTag}>`;\n                }\n            }\n            // For IE11, the document title must not be undefined, but it can be an empty string\n            // https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createHTMLDocument#browser_compatibility\n            const doc = document.implementation.createHTMLDocument('');\n            doc.body.innerHTML = html;\n            let content = doc.body;\n            if (!isUndefined(wrapperTags)) {\n                for (let i = 0; i < wrapperTags.length; i++) {\n                    content = content.firstChild;\n                }\n            }\n            return content.firstChild;\n        };\n    }\n    function insert(node, parent, anchor) {\n        parent.insertBefore(node, anchor);\n    }\n    function remove(node, parent) {\n        parent.removeChild(node);\n    }\n    function nextSibling(node) {\n        return node.nextSibling;\n    }\n    function attachShadow(element, options) {\n        // `shadowRoot` will be non-null in two cases:\n        //   1. upon initial load with an SSR-generated DOM, while in Shadow render mode\n        //   2. when a webapp author places <c-app> in their static HTML and mounts their\n        //      root component with customElement.define('c-app', Ctor)\n        if (!isNull(element.shadowRoot)) {\n            return element.shadowRoot;\n        }\n        return element.attachShadow(options);\n    }\n    function setText(node, content) {\n        node.nodeValue = content;\n    }\n    function getProperty(node, key) {\n        return node[key];\n    }\n    function setProperty(node, key, value) {\n        node[key] = value;\n    }\n    function getAttribute(element, name, namespace) {\n        return isUndefined(namespace)\n            ? element.getAttribute(name)\n            : element.getAttributeNS(namespace, name);\n    }\n    function setAttribute(element, name, value, namespace) {\n        return isUndefined(namespace)\n            ? element.setAttribute(name, value)\n            : element.setAttributeNS(namespace, name, value);\n    }\n    function removeAttribute(element, name, namespace) {\n        if (isUndefined(namespace)) {\n            element.removeAttribute(name);\n        }\n        else {\n            element.removeAttributeNS(namespace, name);\n        }\n    }\n    function addEventListener(target, type, callback, options) {\n        target.addEventListener(type, callback, options);\n    }\n    function removeEventListener(target, type, callback, options) {\n        target.removeEventListener(type, callback, options);\n    }\n    function dispatchEvent(target, event) {\n        return target.dispatchEvent(event);\n    }\n    function getClassList(element) {\n        return element.classList;\n    }\n    function setCSSStyleProperty(element, name, value, important) {\n        // TODO [#0]: How to avoid this type casting? Shall we use a different type interface to\n        // represent elements in the engine?\n        element.style.setProperty(name, value, important ? 'important' : '');\n    }\n    function getBoundingClientRect(element) {\n        return element.getBoundingClientRect();\n    }\n    function querySelector(element, selectors) {\n        return element.querySelector(selectors);\n    }\n    function querySelectorAll(element, selectors) {\n        return element.querySelectorAll(selectors);\n    }\n    function getElementsByTagName(element, tagNameOrWildCard) {\n        return element.getElementsByTagName(tagNameOrWildCard);\n    }\n    function getElementsByClassName(element, names) {\n        return element.getElementsByClassName(names);\n    }\n    function getChildren(element) {\n        return element.children;\n    }\n    function getChildNodes(element) {\n        return element.childNodes;\n    }\n    function getFirstChild(element) {\n        return element.firstChild;\n    }\n    function getFirstElementChild(element) {\n        return element.firstElementChild;\n    }\n    function getLastChild(element) {\n        return element.lastChild;\n    }\n    function getLastElementChild(element) {\n        return element.lastElementChild;\n    }\n    function isConnected(node) {\n        return node.isConnected;\n    }\n    function assertInstanceOfHTMLElement(elm, msg) {\n        assert.invariant(elm instanceof HTMLElement, msg);\n    }\n\n    exports.addEventListener = addEventListener;\n    exports.assertInstanceOfHTMLElement = assertInstanceOfHTMLElement;\n    exports.attachShadow = attachShadow;\n    exports.cloneNode = cloneNode;\n    exports.createComment = createComment;\n    exports.createElement = createElement;\n    exports.createText = createText;\n    exports.dispatchEvent = dispatchEvent;\n    exports.getAttribute = getAttribute;\n    exports.getBoundingClientRect = getBoundingClientRect;\n    exports.getChildNodes = getChildNodes;\n    exports.getChildren = getChildren;\n    exports.getClassList = getClassList;\n    exports.getElementsByClassName = getElementsByClassName;\n    exports.getElementsByTagName = getElementsByTagName;\n    exports.getFirstChild = getFirstChild;\n    exports.getFirstElementChild = getFirstElementChild;\n    exports.getLastChild = getLastChild;\n    exports.getLastElementChild = getLastElementChild;\n    exports.getProperty = getProperty;\n    exports.insert = insert;\n    exports.isConnected = isConnected;\n    exports.nextSibling = nextSibling;\n    exports.querySelector = querySelector;\n    exports.querySelectorAll = querySelectorAll;\n    exports.remove = remove;\n    exports.removeAttribute = removeAttribute;\n    exports.removeEventListener = removeEventListener;\n    exports.setAttribute = setAttribute;\n    exports.setCSSStyleProperty = setCSSStyleProperty;\n    exports.setProperty = setProperty;\n    exports.setText = setText;\n\n    return exports;\n\n})({});\n    // Meant to inherit any properties passed via the base renderer as the argument to the factory.\n    Object.setPrototypeOf(renderer, baseRenderer);\n    return renderer;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * The base renderer that will be used by engine-core.\n * This will be used for DOM operations when lwc is running in a browser environment.\n */\nconst renderer = assign(\n// The base renderer will invoke the factory with null and assign additional properties that are\n// shared across renderers\nrendererFactory(null), \n// Properties that are either not required to be sandboxed or rely on a globally shared information\n{\n    // insertStyleSheet implementation shares a global cache of stylesheet data\n    insertStylesheet,\n    // relies on a shared global cache\n    createCustomElement,\n    isNativeShadowDefined: _globalThis[KEY__IS_NATIVE_SHADOW_ROOT_DEFINED],\n    isSyntheticShadowDefined: hasOwnProperty$1.call(Element.prototype, KEY__SHADOW_TOKEN),\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction resetShadowRootAndLightDom(element, Ctor) {\n    if (element.shadowRoot) {\n        const shadowRoot = element.shadowRoot;\n        while (!isNull(shadowRoot.firstChild)) {\n            shadowRoot.removeChild(shadowRoot.firstChild);\n        }\n    }\n    if (Ctor.renderMode === 'light') {\n        while (!isNull(element.firstChild)) {\n            element.removeChild(element.firstChild);\n        }\n    }\n}\nfunction createVMWithProps(element, Ctor, props) {\n    const vm = createVM(element, Ctor, renderer, {\n        mode: 'open',\n        owner: null,\n        tagName: element.tagName.toLowerCase(),\n        hydrated: true,\n    });\n    for (const [key, value] of Object.entries(props)) {\n        element[key] = value;\n    }\n    return vm;\n}\nfunction hydrateComponent(element, Ctor, props = {}) {\n    if (!(element instanceof Element)) {\n        throw new TypeError(`\"hydrateComponent\" expects a valid DOM element as the first parameter but instead received ${element}.`);\n    }\n    if (!isFunction$1(Ctor)) {\n        throw new TypeError(`\"hydrateComponent\" expects a valid component constructor as the second parameter but instead received ${Ctor}.`);\n    }\n    if (!isObject(props) || isNull(props)) {\n        throw new TypeError(`\"hydrateComponent\" expects an object as the third parameter but instead received ${props}.`);\n    }\n    if (getAssociatedVMIfPresent(element)) {\n        /* eslint-disable-next-line no-console */\n        console.warn(`\"hydrateComponent\" expects an element that is not hydrated.`, element);\n        return;\n    }\n    try {\n        const vm = createVMWithProps(element, Ctor, props);\n        hydrateRoot(vm);\n    }\n    catch (e) {\n        // Fallback: In case there's an error while hydrating, let's log the error, and replace the element content\n        //           with the client generated DOM.\n        /* eslint-disable-next-line no-console */\n        console.error('Recovering from error while hydrating: ', e);\n        // We want to preserve the element, so we need to reset the shadowRoot and light dom.\n        resetShadowRootAndLightDom(element, Ctor);\n        // we need to recreate the vm with the hydration flag on, so it re-uses the existing shadowRoot.\n        createVMWithProps(element, Ctor, props);\n        connectRootElement(element);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This function builds a Web Component class from a LWC constructor so it can be\n * registered as a new element via customElements.define() at any given time.\n *\n * @deprecated since version 1.3.11\n *\n * @example\n * ```\n * import { buildCustomElementConstructor } from 'lwc';\n * import Foo from 'ns/foo';\n * const WC = buildCustomElementConstructor(Foo);\n * customElements.define('x-foo', WC);\n * const elm = document.createElement('x-foo');\n * ```\n */\nfunction deprecatedBuildCustomElementConstructor(Ctor) {\n    if (process.env.NODE_ENV !== 'production') {\n        /* eslint-disable-next-line no-console */\n        console.warn('Deprecated function called: \"buildCustomElementConstructor\" function is deprecated and it will be removed.' +\n            `Use \"${Ctor.name}.CustomElementConstructor\" static property of the component constructor to access the corresponding custom element constructor instead.`);\n    }\n    return Ctor.CustomElementConstructor;\n}\n// Note: WeakSet is not supported in IE11, and the polyfill is not performant enough.\n//       This WeakSet usage is valid because this functionality is not meant to run in IE11.\nconst hydratedCustomElements = new WeakSet();\nfunction buildCustomElementConstructor(Ctor) {\n    var _a;\n    const HtmlPrototype = getComponentHtmlPrototype(Ctor);\n    const { observedAttributes } = HtmlPrototype;\n    const { attributeChangedCallback } = HtmlPrototype.prototype;\n    return _a = class extends HTMLElement {\n            constructor() {\n                super();\n                if (this.isConnected) {\n                    // this if block is hit when there's already an un-upgraded element in the DOM with the same tag name.\n                    hydrateComponent(this, Ctor, {});\n                    hydratedCustomElements.add(this);\n                }\n                else {\n                    createVM(this, Ctor, renderer, {\n                        mode: 'open',\n                        owner: null,\n                        tagName: this.tagName,\n                    });\n                }\n            }\n            connectedCallback() {\n                if (hydratedCustomElements.has(this)) {\n                    // This is an un-upgraded element that was hydrated in the constructor.\n                    hydratedCustomElements.delete(this);\n                }\n                else {\n                    connectRootElement(this);\n                }\n            }\n            disconnectedCallback() {\n                disconnectRootElement(this);\n            }\n            attributeChangedCallback(name, oldValue, newValue) {\n                attributeChangedCallback.call(this, name, oldValue, newValue);\n            }\n        },\n        _a.observedAttributes = observedAttributes,\n        _a;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// TODO [#2472]: Remove this workaround when appropriate.\n// eslint-disable-next-line @lwc/lwc-internal/no-global-node\nconst _Node$1 = Node;\nconst ConnectingSlot = new WeakMap();\nconst DisconnectingSlot = new WeakMap();\nfunction callNodeSlot(node, slot) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.isTrue(node, `callNodeSlot() should not be called for a non-object`);\n    }\n    const fn = slot.get(node);\n    if (!isUndefined$1(fn)) {\n        fn(node);\n    }\n    return node; // for convenience\n}\nif (!lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {\n    // Monkey patching Node methods to be able to detect the insertions and removal of root elements\n    // created via createElement.\n    const { appendChild, insertBefore, removeChild, replaceChild } = _Node$1.prototype;\n    assign(_Node$1.prototype, {\n        appendChild(newChild) {\n            const appendedNode = appendChild.call(this, newChild);\n            return callNodeSlot(appendedNode, ConnectingSlot);\n        },\n        insertBefore(newChild, referenceNode) {\n            const insertedNode = insertBefore.call(this, newChild, referenceNode);\n            return callNodeSlot(insertedNode, ConnectingSlot);\n        },\n        removeChild(oldChild) {\n            const removedNode = removeChild.call(this, oldChild);\n            return callNodeSlot(removedNode, DisconnectingSlot);\n        },\n        replaceChild(newChild, oldChild) {\n            const replacedNode = replaceChild.call(this, newChild, oldChild);\n            callNodeSlot(replacedNode, DisconnectingSlot);\n            callNodeSlot(newChild, ConnectingSlot);\n            return replacedNode;\n        },\n    });\n}\n/**\n * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly\n * difference that in the options, you can pass the `is` property set to a Constructor instead of\n * just a string value. The intent is to allow the creation of an element controlled by LWC without\n * having to register the element as a custom element.\n *\n * @example\n * ```\n * const el = createElement('x-foo', { is: FooCtor });\n * ```\n */\nfunction createElement(sel, options) {\n    if (!isObject(options) || isNull(options)) {\n        throw new TypeError(`\"createElement\" function expects an object as second parameter but received \"${toString$1(options)}\".`);\n    }\n    const Ctor = options.is;\n    if (!isFunction$1(Ctor)) {\n        throw new TypeError(`\"createElement\" function expects an \"is\" option with a valid component constructor.`);\n    }\n    const { createCustomElement } = renderer;\n    // tagName must be all lowercase, unfortunately, we have legacy code that is\n    // passing `sel` as a camel-case, which makes them invalid custom elements name\n    // the following line guarantees that this does not leaks beyond this point.\n    const tagName = StringToLowerCase.call(sel);\n    // the custom element from the registry is expecting an upgrade callback\n    /**\n     * Note: if the upgradable constructor does not expect, or throw when we new it\n     * with a callback as the first argument, we could implement a more advanced\n     * mechanism that only passes that argument if the constructor is known to be\n     * an upgradable custom element.\n     */\n    const upgradeCallback = (elm) => {\n        createVM(elm, Ctor, renderer, {\n            tagName,\n            mode: options.mode !== 'closed' ? 'open' : 'closed',\n            owner: null,\n        });\n        if (!lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {\n            ConnectingSlot.set(elm, connectRootElement);\n            DisconnectingSlot.set(elm, disconnectRootElement);\n        }\n    };\n    let connectedCallback;\n    let disconnectedCallback;\n    if (lwcRuntimeFlags.ENABLE_NATIVE_CUSTOM_ELEMENT_LIFECYCLE) {\n        connectedCallback = (elm) => {\n            connectRootElement(elm);\n        };\n        disconnectedCallback = (elm) => {\n            disconnectRootElement(elm);\n        };\n    }\n    const element = createCustomElement(tagName, upgradeCallback, connectedCallback, disconnectedCallback);\n    return element;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// TODO [#2472]: Remove this workaround when appropriate.\n// eslint-disable-next-line @lwc/lwc-internal/no-global-node\nconst _Node = Node;\n/**\n * EXPERIMENTAL: The purpose of this function is to detect shadowed nodes. THIS API WILL BE REMOVED\n * ONCE LOCKER V1 IS NO LONGER SUPPORTED.\n */\nfunction isNodeShadowed(node) {\n    if (isFalse(node instanceof _Node)) {\n        return false;\n    }\n    // It's debatable whether shadow root instances should be considered as shadowed, but we keep\n    // this unchanged for legacy reasons (#1250).\n    if (node instanceof ShadowRoot) {\n        return false;\n    }\n    const rootNode = node.getRootNode();\n    // Handle the native case. We can return early here because an invariant of LWC is that\n    // synthetic roots cannot be descendants of native roots.\n    if (rootNode instanceof ShadowRoot &&\n        isFalse(hasOwnProperty$1.call(getPrototypeOf$1(rootNode), 'synthetic'))) {\n        return true;\n    }\n    // TODO [#1252]: Old behavior that is still used by some pieces of the platform. Manually\n    // inserted nodes without the `lwc:dom=manual` directive will be considered as global elements.\n    return renderer.isSyntheticShadowDefined && !isUndefined$1(node[KEY__SHADOW_RESOLVER]);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ComponentConstructorToCustomElementConstructorMap = new Map();\nfunction getCustomElementConstructor(Ctor) {\n    if (Ctor === LightningElement) {\n        throw new TypeError(`Invalid Constructor. LightningElement base class can't be claimed as a custom element.`);\n    }\n    let ce = ComponentConstructorToCustomElementConstructorMap.get(Ctor);\n    if (isUndefined$1(ce)) {\n        ce = buildCustomElementConstructor(Ctor);\n        ComponentConstructorToCustomElementConstructorMap.set(Ctor, ce);\n    }\n    return ce;\n}\n/**\n * This static getter builds a Web Component class from a LWC constructor so it can be registered\n * as a new element via customElements.define() at any given time. E.g.:\n *\n *      import Foo from 'ns/foo';\n *      customElements.define('x-foo', Foo.CustomElementConstructor);\n *      const elm = document.createElement('x-foo');\n *\n */\ndefineProperty(LightningElement, 'CustomElementConstructor', {\n    get() {\n        return getCustomElementConstructor(this);\n    },\n});\nfreeze(LightningElement);\nseal(LightningElement.prototype);\n\nexports.LightningElement = LightningElement;\nexports.__unstable__ProfilerControl = profilerControl;\nexports.__unstable__ReportingControl = reportingControl;\nexports.api = api$1;\nexports.buildCustomElementConstructor = deprecatedBuildCustomElementConstructor;\nexports.createContextProvider = createContextProvider;\nexports.createElement = createElement;\nexports.freezeTemplate = freezeTemplate;\nexports.getComponentConstructor = getComponentConstructor;\nexports.getComponentDef = getComponentDef;\nexports.hydrateComponent = hydrateComponent;\nexports.isComponentConstructor = isComponentConstructor;\nexports.isNodeFromTemplate = isNodeShadowed;\nexports.parseFragment = parseFragment;\nexports.parseSVGFragment = parseSVGFragment;\nexports.readonly = readonly;\nexports.register = register;\nexports.registerComponent = registerComponent;\nexports.registerDecorators = registerDecorators;\nexports.registerTemplate = registerTemplate;\nexports.renderer = renderer;\nexports.rendererFactory = rendererFactory;\nexports.sanitizeAttribute = sanitizeAttribute;\nexports.setFeatureFlag = setFeatureFlag;\nexports.setFeatureFlagForTest = setFeatureFlagForTest;\nexports.setHooks = setHooks;\nexports.swapComponent = swapComponent;\nexports.swapStyle = swapStyle;\nexports.swapTemplate = swapTemplate;\nexports.track = track;\nexports.unwrap = unwrap;\nexports.wire = wire;\n/* version: 2.37.3 */\n","/* proxy-compat-disable */\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction invariant(value, msg) {\n    if (!value) {\n        throw new Error(`Invariant Violation: ${msg}`);\n    }\n}\nfunction isTrue$1(value, msg) {\n    if (!value) {\n        throw new Error(`Assert Violation: ${msg}`);\n    }\n}\nfunction isFalse$1(value, msg) {\n    if (value) {\n        throw new Error(`Assert Violation: ${msg}`);\n    }\n}\nfunction fail(msg) {\n    throw new Error(msg);\n}\n\nvar assert = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    fail: fail,\n    invariant: invariant,\n    isFalse: isFalse$1,\n    isTrue: isTrue$1\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { assign, create, defineProperties, defineProperty, freeze, getOwnPropertyDescriptor, getOwnPropertyNames, getPrototypeOf, hasOwnProperty, isFrozen, keys, seal, setPrototypeOf, } = Object;\nconst { isArray } = Array;\nconst { concat: ArrayConcat, copyWithin: ArrayCopyWithin, fill: ArrayFill, filter: ArrayFilter, find: ArrayFind, indexOf: ArrayIndexOf, join: ArrayJoin, map: ArrayMap, pop: ArrayPop, push: ArrayPush, reduce: ArrayReduce, reverse: ArrayReverse, shift: ArrayShift, slice: ArraySlice, some: ArraySome, sort: ArraySort, splice: ArraySplice, unshift: ArrayUnshift, forEach, } = Array.prototype;\nconst { charCodeAt: StringCharCodeAt, replace: StringReplace, split: StringSplit, slice: StringSlice, toLowerCase: StringToLowerCase, } = String.prototype;\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isNull(obj) {\n    return obj === null;\n}\nfunction isTrue(obj) {\n    return obj === true;\n}\nfunction isFalse(obj) {\n    return obj === false;\n}\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\nfunction isObject(obj) {\n    return typeof obj === 'object';\n}\nconst OtS = {}.toString;\nfunction toString(obj) {\n    if (obj && obj.toString) {\n        // Arrays might hold objects with \"null\" prototype So using\n        // Array.prototype.toString directly will cause an error Iterate through\n        // all the items and handle individually.\n        if (isArray(obj)) {\n            return ArrayJoin.call(ArrayMap.call(obj, toString), ',');\n        }\n        return obj.toString();\n    }\n    else if (typeof obj === 'object') {\n        return OtS.call(obj);\n    }\n    else {\n        return obj + '';\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// See browser support for globalThis:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility\n/* istanbul ignore next */\n// @ts-ignore\nconst _globalThis = typeof globalThis === 'object' ? globalThis : window;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst KEY__IS_NATIVE_SHADOW_ROOT_DEFINED = '$isNativeShadowRootDefined$';\nconst KEY__SHADOW_RESOLVER = '$shadowResolver$';\nconst KEY__SHADOW_RESOLVER_PRIVATE = '$$ShadowResolverKey$$';\nconst KEY__SHADOW_STATIC = '$shadowStaticNode$';\nconst KEY__SHADOW_STATIC_PRIVATE = '$shadowStaticNodeKey$';\nconst KEY__SHADOW_TOKEN = '$shadowToken$';\nconst KEY__SHADOW_TOKEN_PRIVATE = '$$ShadowTokenKey$$';\nconst KEY__SYNTHETIC_MODE = '$$lwc-synthetic-mode';\nconst KEY__NATIVE_GET_ELEMENT_BY_ID = '$nativeGetElementById$';\nconst KEY__NATIVE_QUERY_SELECTOR_ALL = '$nativeQuerySelectorAll$';\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// We use this to detect symbol support in order to avoid the expensive symbol polyfill. Note that\n// we can't use typeof since it will fail when transpiling.\nconst hasNativeSymbolSupport = /*@__PURE__*/ (() => Symbol('x').toString() === 'Symbol(x)')();\n/** version: 2.37.3 */\n\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n// eslint-disable-next-line no-restricted-properties\nif (!_globalThis.lwcRuntimeFlags) {\n    Object.defineProperty(_globalThis, 'lwcRuntimeFlags', { value: create(null) });\n}\n/** version: 2.37.3 */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// TODO [#2472]: Remove this workaround when appropriate.\n// eslint-disable-next-line @lwc/lwc-internal/no-global-node\nconst _Node = Node;\nconst nodePrototype = _Node.prototype;\nconst { DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING, ELEMENT_NODE, TEXT_NODE, CDATA_SECTION_NODE, PROCESSING_INSTRUCTION_NODE, COMMENT_NODE, DOCUMENT_FRAGMENT_NODE, } = _Node;\nconst { appendChild, cloneNode, compareDocumentPosition, insertBefore, removeChild, replaceChild, hasChildNodes, } = nodePrototype;\nconst { contains } = HTMLElement.prototype;\nconst firstChildGetter = getOwnPropertyDescriptor(nodePrototype, 'firstChild').get;\nconst lastChildGetter = getOwnPropertyDescriptor(nodePrototype, 'lastChild').get;\nconst textContentGetter = getOwnPropertyDescriptor(nodePrototype, 'textContent').get;\nconst parentNodeGetter = getOwnPropertyDescriptor(nodePrototype, 'parentNode').get;\nconst ownerDocumentGetter = getOwnPropertyDescriptor(nodePrototype, 'ownerDocument').get;\nconst parentElementGetter = hasOwnProperty.call(nodePrototype, 'parentElement')\n    ? getOwnPropertyDescriptor(nodePrototype, 'parentElement').get\n    : getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get; // IE11\nconst textContextSetter = getOwnPropertyDescriptor(nodePrototype, 'textContent').set;\nconst childNodesGetter = hasOwnProperty.call(nodePrototype, 'childNodes')\n    ? getOwnPropertyDescriptor(nodePrototype, 'childNodes').get\n    : getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get; // IE11\nconst isConnected = hasOwnProperty.call(nodePrototype, 'isConnected')\n    ? getOwnPropertyDescriptor(nodePrototype, 'isConnected').get\n    : function () {\n        const doc = ownerDocumentGetter.call(this);\n        // IE11\n        return (\n        // if doc is null, it means `this` is actually a document instance which\n        // is always connected\n        doc === null ||\n            (compareDocumentPosition.call(doc, this) & DOCUMENT_POSITION_CONTAINED_BY) !== 0);\n    };\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { getAttribute, getBoundingClientRect, getElementsByTagName: getElementsByTagName$1, getElementsByTagNameNS: getElementsByTagNameNS$1, hasAttribute, querySelector, querySelectorAll: querySelectorAll$1, removeAttribute, setAttribute, } = Element.prototype;\nconst attachShadow$1 = hasOwnProperty.call(Element.prototype, 'attachShadow')\n    ? Element.prototype.attachShadow\n    : () => {\n        throw new TypeError('attachShadow() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill and use Lightning Web Components');\n    };\nconst childElementCountGetter = getOwnPropertyDescriptor(Element.prototype, 'childElementCount').get;\nconst firstElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').get;\nconst lastElementChildGetter = getOwnPropertyDescriptor(Element.prototype, 'lastElementChild').get;\nconst innerTextDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'innerText');\nconst innerTextGetter = innerTextDescriptor\n    ? innerTextDescriptor.get\n    : null;\nconst innerTextSetter = innerTextDescriptor\n    ? innerTextDescriptor.set\n    : null;\n// Note: Firefox does not have outerText, https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText\nconst outerTextDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'outerText');\nconst outerTextGetter = outerTextDescriptor\n    ? outerTextDescriptor.get\n    : null;\nconst outerTextSetter = outerTextDescriptor\n    ? outerTextDescriptor.set\n    : null;\nconst innerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'innerHTML')\n    ? getOwnPropertyDescriptor(Element.prototype, 'innerHTML')\n    : getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML'); // IE11\nconst innerHTMLGetter = innerHTMLDescriptor.get;\nconst innerHTMLSetter = innerHTMLDescriptor.set;\nconst outerHTMLDescriptor = hasOwnProperty.call(Element.prototype, 'outerHTML')\n    ? getOwnPropertyDescriptor(Element.prototype, 'outerHTML')\n    : getOwnPropertyDescriptor(HTMLElement.prototype, 'outerHTML'); // IE11\nconst outerHTMLGetter = outerHTMLDescriptor.get;\nconst outerHTMLSetter = outerHTMLDescriptor.set;\nconst tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;\nconst tabIndexDescriptor = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex');\nconst tabIndexGetter = tabIndexDescriptor.get;\nconst tabIndexSetter = tabIndexDescriptor.set;\nconst matches = hasOwnProperty.call(Element.prototype, 'matches')\n    ? Element.prototype.matches\n    : Element.prototype.msMatchesSelector; // IE11\nconst childrenGetter = hasOwnProperty.call(Element.prototype, 'children')\n    ? getOwnPropertyDescriptor(Element.prototype, 'children').get\n    : getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get; // IE11\n// for IE11, access from HTMLElement\n// for all other browsers access the method from the parent Element interface\nconst { getElementsByClassName: getElementsByClassName$1 } = HTMLElement.prototype;\nconst shadowRootGetter = hasOwnProperty.call(Element.prototype, 'shadowRoot')\n    ? getOwnPropertyDescriptor(Element.prototype, 'shadowRoot').get\n    : () => null;\nconst assignedSlotGetter$1 = hasOwnProperty.call(Element.prototype, 'assignedSlot')\n    ? getOwnPropertyDescriptor(Element.prototype, 'assignedSlot').get\n    : () => null;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet assignedNodes, assignedElements;\nif (typeof HTMLSlotElement !== 'undefined') {\n    assignedNodes = HTMLSlotElement.prototype.assignedNodes;\n    assignedElements = HTMLSlotElement.prototype.assignedElements;\n}\nelse {\n    assignedNodes = () => {\n        throw new TypeError(\"assignedNodes() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template\");\n    };\n    assignedElements = () => {\n        throw new TypeError(\"assignedElements() is not supported in current browser. Load the @lwc/synthetic-shadow polyfill to start using <slot> elements in your Lightning Web Component's template\");\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;\nconst eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;\nconst focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;\n// IE does not implement composedPath() but that's ok because we only use this instead of our\n// composedPath() polyfill when dealing with native shadow DOM components in mixed mode. Defaulting\n// to a NOOP just to be safe, even though this is almost guaranteed to be defined such a scenario.\nconst composedPath = hasOwnProperty.call(Event.prototype, 'composedPath')\n    ? Event.prototype.composedPath\n    : () => [];\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;\nconst elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint')\n    ? Document.prototype.elementFromPoint\n    : Document.prototype.msElementFromPoint; // IE11\nconst elementsFromPoint = hasOwnProperty.call(Document.prototype, 'elementsFromPoint')\n    ? Document.prototype.elementsFromPoint\n    : Document.prototype.msElementsFromPoint; // IE11\n// defaultView can be null when a document has no browsing context. For example, the owner document\n// of a node in a template doesn't have a default view: https://jsfiddle.net/hv9z0q5a/\nconst defaultViewGetter = getOwnPropertyDescriptor(Document.prototype, 'defaultView').get;\nconst { createComment, querySelectorAll, getElementById, getElementsByClassName, getElementsByTagName, getElementsByTagNameNS, } = Document.prototype;\n// In Firefox v57 and lower, getElementsByName is defined on HTMLDocument.prototype\n// In all other browsers have the method on Document.prototype\nconst { getElementsByName } = HTMLDocument.prototype;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { addEventListener: windowAddEventListener, removeEventListener: windowRemoveEventListener, getComputedStyle: windowGetComputedStyle, getSelection: windowGetSelection, } = window;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// There is code in the polyfills that requires access to the unpatched\n// Mutation Observer constructor, this the code for that.\n// Eventually, the polyfill should uses the patched version, and this file can be removed.\nconst MO = MutationObserver;\nconst MutationObserverObserve = MO.prototype.observe;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet NativeShadowRoot = null;\nif (typeof ShadowRoot !== 'undefined') {\n    NativeShadowRoot = ShadowRoot;\n}\nconst isNativeShadowRootDefined = !isNull(NativeShadowRoot);\nconst isInstanceOfNativeShadowRoot = isNull(NativeShadowRoot)\n    ? () => false\n    : (node) => node instanceof NativeShadowRoot;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect$4 () {\n    return typeof HTMLSlotElement === 'undefined';\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { createElement } = Document.prototype;\nconst CHAR_S = 115;\nconst CHAR_L = 108;\nconst CHAR_O = 111;\nconst CHAR_T = 116;\nfunction apply$4() {\n    // IE11 does not have this element definition\n    // we don't care much about the construction phase, just the prototype\n    class HTMLSlotElement {\n    }\n    // prototype inheritance dance\n    setPrototypeOf(HTMLSlotElement, HTMLElement.constructor);\n    setPrototypeOf(HTMLSlotElement.prototype, HTMLElement.prototype);\n    Window.prototype.HTMLSlotElement = HTMLSlotElement;\n    // IE11 doesn't have HTMLSlotElement, in which case we\n    // need to patch Document.prototype.createElement to remap `slot`\n    // elements to the right prototype\n    defineProperty(Document.prototype, 'createElement', {\n        value: function (tagName, _options) {\n            const elm = createElement.apply(this, ArraySlice.call(arguments));\n            if (tagName.length === 4 &&\n                StringCharCodeAt.call(tagName, 0) === CHAR_S &&\n                StringCharCodeAt.call(tagName, 1) === CHAR_L &&\n                StringCharCodeAt.call(tagName, 2) === CHAR_O &&\n                StringCharCodeAt.call(tagName, 3) === CHAR_T) {\n                // the new element is the `slot`, resetting the proto chain\n                // the new newly created global HTMLSlotElement.prototype\n                setPrototypeOf(elm, HTMLSlotElement.prototype);\n            }\n            return elm;\n        },\n    });\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (detect$4()) {\n    apply$4();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Helpful for tests running with jsdom\nfunction getOwnerDocument(node) {\n    const doc = ownerDocumentGetter.call(node);\n    // if doc is null, it means `this` is actually a document instance\n    return doc === null ? node : doc;\n}\nfunction getOwnerWindow(node) {\n    const doc = getOwnerDocument(node);\n    const win = defaultViewGetter.call(doc);\n    if (win === null) {\n        // this method should never be called with a node that is not part\n        // of a qualifying connected node.\n        throw new TypeError();\n    }\n    return win;\n}\nlet skipGlobalPatching;\n// Note: we deviate from native shadow here, but are not fixing\n// due to backwards compat: https://github.com/salesforce/lwc/pull/3103\nfunction isGlobalPatchingSkipped(node) {\n    // we lazily compute this value instead of doing it during evaluation, this helps\n    // for apps that are setting this after the engine code is evaluated.\n    if (isUndefined(skipGlobalPatching)) {\n        const ownerDocument = getOwnerDocument(node);\n        skipGlobalPatching =\n            ownerDocument.body &&\n                getAttribute.call(ownerDocument.body, 'data-global-patching-bypass') ===\n                    'temporary-bypass';\n    }\n    return isTrue(skipGlobalPatching);\n}\nfunction arrayFromCollection(collection) {\n    const size = collection.length;\n    const cloned = [];\n    if (size > 0) {\n        for (let i = 0; i < size; i++) {\n            cloned[i] = collection[i];\n        }\n    }\n    return cloned;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst eventTargetPrototype = typeof EventTarget !== 'undefined' ? EventTarget.prototype : _Node.prototype;\nconst { addEventListener, dispatchEvent, removeEventListener } = eventTargetPrototype;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Used as a back reference to identify the host element\nconst HostElementKey = '$$HostElementKey$$';\nconst ShadowedNodeKey = '$$ShadowedNodeKey$$';\nfunction fastDefineProperty(node, propName, config) {\n    const shadowedNode = node;\n    if (process.env.NODE_ENV !== 'production') {\n        // in dev, we are more restrictive\n        defineProperty(shadowedNode, propName, config);\n    }\n    else {\n        const { value } = config;\n        // in prod, we prioritize performance\n        shadowedNode[propName] = value;\n    }\n}\nfunction setNodeOwnerKey(node, value) {\n    fastDefineProperty(node, HostElementKey, { value, configurable: true });\n}\nfunction setNodeKey(node, value) {\n    fastDefineProperty(node, ShadowedNodeKey, { value });\n}\nfunction getNodeOwnerKey(node) {\n    return node[HostElementKey];\n}\nfunction getNodeNearestOwnerKey(node) {\n    let host = node;\n    let hostKey;\n    // search for the first element with owner identity\n    // in case of manually inserted elements and elements slotted from Light DOM\n    while (!isNull(host)) {\n        hostKey = getNodeOwnerKey(host);\n        if (!isUndefined(hostKey)) {\n            return hostKey;\n        }\n        host = parentNodeGetter.call(host);\n        if (lwcRuntimeFlags.ENABLE_LIGHT_GET_ROOT_NODE_PATCH &&\n            !isNull(host) &&\n            isSyntheticSlotElement(host)) {\n            return undefined;\n        }\n    }\n}\nfunction getNodeKey(node) {\n    return node[ShadowedNodeKey];\n}\n/**\n * This function does not traverse up for performance reasons, but is sufficient for most use\n * cases. If we need to traverse up and verify those nodes that don't have owner key, use\n * isNodeDeepShadowed instead.\n */\nfunction isNodeShadowed(node) {\n    return !isUndefined(getNodeOwnerKey(node));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// when finding a slot in the DOM, we can fold it if it is contained\n// inside another slot.\nfunction foldSlotElement(slot) {\n    let parent = parentElementGetter.call(slot);\n    while (!isNull(parent) && isSlotElement(parent)) {\n        slot = parent;\n        parent = parentElementGetter.call(slot);\n    }\n    return slot;\n}\nfunction isNodeSlotted(host, node) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.invariant(host instanceof HTMLElement, `isNodeSlotted() should be called with a host as the first argument instead of ${host}`);\n        assert.invariant(node instanceof _Node, `isNodeSlotted() should be called with a node as the second argument instead of ${node}`);\n        assert.invariant(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, `isNodeSlotted() should never be called with a node that is not a child node of ${host}`);\n    }\n    const hostKey = getNodeKey(host);\n    // this routine assumes that the node is coming from a different shadow (it is not owned by the host)\n    // just in case the provided node is not an element\n    let currentElement = node instanceof Element ? node : parentElementGetter.call(node);\n    while (!isNull(currentElement) && currentElement !== host) {\n        const elmOwnerKey = getNodeNearestOwnerKey(currentElement);\n        const parent = parentElementGetter.call(currentElement);\n        if (elmOwnerKey === hostKey) {\n            // we have reached an element inside the host's template, and only if\n            // that element is an slot, then the node is considered slotted\n            return isSlotElement(currentElement);\n        }\n        else if (parent === host) {\n            return false;\n        }\n        else if (!isNull(parent) && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {\n            // we are crossing a boundary of some sort since the elm and its parent\n            // have different owner key. for slotted elements, this is possible\n            // if the parent happens to be a slot.\n            if (isSlotElement(parent)) {\n                /**\n                 * the slot parent might be allocated inside another slot, think of:\n                 * <x-root> (<--- root element)\n                 *    <x-parent> (<--- own by x-root)\n                 *       <x-child> (<--- own by x-root)\n                 *           <slot> (<--- own by x-child)\n                 *               <slot> (<--- own by x-parent)\n                 *                  <div> (<--- own by x-root)\n                 *\n                 * while checking if x-parent has the div slotted, we need to traverse\n                 * up, but when finding the first slot, we skip that one in favor of the\n                 * most outer slot parent before jumping into its corresponding host.\n                 */\n                currentElement = getNodeOwner(foldSlotElement(parent));\n                if (!isNull(currentElement)) {\n                    if (currentElement === host) {\n                        // the slot element is a top level element inside the shadow\n                        // of a host that was allocated into host in question\n                        return true;\n                    }\n                    else if (getNodeNearestOwnerKey(currentElement) === hostKey) {\n                        // the slot element is an element inside the shadow\n                        // of a host that was allocated into host in question\n                        return true;\n                    }\n                }\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            currentElement = parent;\n        }\n    }\n    return false;\n}\nfunction getNodeOwner(node) {\n    if (!(node instanceof _Node)) {\n        return null;\n    }\n    const ownerKey = getNodeNearestOwnerKey(node);\n    if (isUndefined(ownerKey)) {\n        return null;\n    }\n    let nodeOwner = node;\n    // At this point, node is a valid node with owner identity, now we need to find the owner node\n    // search for a custom element with a VM that owns the first element with owner identity attached to it\n    while (!isNull(nodeOwner) && getNodeKey(nodeOwner) !== ownerKey) {\n        nodeOwner = parentNodeGetter.call(nodeOwner);\n    }\n    if (isNull(nodeOwner)) {\n        return null;\n    }\n    return nodeOwner;\n}\nfunction isSyntheticSlotElement(node) {\n    return isSlotElement(node) && isNodeShadowed(node);\n}\nfunction isSlotElement(node) {\n    return node instanceof HTMLSlotElement;\n}\nfunction isNodeOwnedBy(owner, node) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.invariant(owner instanceof HTMLElement, `isNodeOwnedBy() should be called with an element as the first argument instead of ${owner}`);\n        assert.invariant(node instanceof _Node, `isNodeOwnedBy() should be called with a node as the second argument instead of ${node}`);\n        assert.invariant(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, `isNodeOwnedBy() should never be called with a node that is not a child node of ${owner}`);\n    }\n    const ownerKey = getNodeNearestOwnerKey(node);\n    if (isUndefined(ownerKey)) {\n        if (lwcRuntimeFlags.ENABLE_LIGHT_GET_ROOT_NODE_PATCH) {\n            // in case of root level light DOM element slotting into a synthetic shadow\n            const host = parentNodeGetter.call(node);\n            if (!isNull(host) && isSyntheticSlotElement(host)) {\n                return false;\n            }\n        }\n        // in case of manually inserted elements\n        return true;\n    }\n    return getNodeKey(owner) === ownerKey;\n}\nfunction shadowRootChildNodes(root) {\n    const elm = getHost(root);\n    return getAllMatches(elm, arrayFromCollection(childNodesGetter.call(elm)));\n}\nfunction getAllSlottedMatches(host, nodeList) {\n    const filteredAndPatched = [];\n    for (let i = 0, len = nodeList.length; i < len; i += 1) {\n        const node = nodeList[i];\n        if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {\n            ArrayPush.call(filteredAndPatched, node);\n        }\n    }\n    return filteredAndPatched;\n}\nfunction getFirstSlottedMatch(host, nodeList) {\n    for (let i = 0, len = nodeList.length; i < len; i += 1) {\n        const node = nodeList[i];\n        if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {\n            return node;\n        }\n    }\n    return null;\n}\nfunction getAllMatches(owner, nodeList) {\n    const filteredAndPatched = [];\n    for (let i = 0, len = nodeList.length; i < len; i += 1) {\n        const node = nodeList[i];\n        const isOwned = isNodeOwnedBy(owner, node);\n        if (isOwned) {\n            // Patch querySelector, querySelectorAll, etc\n            // if element is owned by VM\n            ArrayPush.call(filteredAndPatched, node);\n        }\n    }\n    return filteredAndPatched;\n}\nfunction getFirstMatch(owner, nodeList) {\n    for (let i = 0, len = nodeList.length; i < len; i += 1) {\n        if (isNodeOwnedBy(owner, nodeList[i])) {\n            return nodeList[i];\n        }\n    }\n    return null;\n}\nfunction shadowRootQuerySelector(root, selector) {\n    const elm = getHost(root);\n    const nodeList = arrayFromCollection(querySelectorAll$1.call(elm, selector));\n    return getFirstMatch(elm, nodeList);\n}\nfunction shadowRootQuerySelectorAll(root, selector) {\n    const elm = getHost(root);\n    const nodeList = querySelectorAll$1.call(elm, selector);\n    return getAllMatches(elm, arrayFromCollection(nodeList));\n}\nfunction getFilteredChildNodes(node) {\n    if (!isSyntheticShadowHost(node) && !isSlotElement(node)) {\n        // regular element - fast path\n        const children = childNodesGetter.call(node);\n        return arrayFromCollection(children);\n    }\n    if (isSyntheticShadowHost(node)) {\n        // we need to get only the nodes that were slotted\n        const slots = arrayFromCollection(querySelectorAll$1.call(node, 'slot'));\n        const resolver = getShadowRootResolver(getShadowRoot(node));\n        // Typescript is inferring the wrong function type for this particular\n        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n        // @ts-ignore type-mismatch\n        return ArrayReduce.call(slots, (seed, slot) => {\n            if (resolver === getShadowRootResolver(slot)) {\n                ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));\n            }\n            return seed;\n        }, []);\n    }\n    else {\n        // slot element\n        const children = arrayFromCollection(childNodesGetter.call(node));\n        const resolver = getShadowRootResolver(node);\n        return ArrayFilter.call(children, (child) => resolver === getShadowRootResolver(child));\n    }\n}\nfunction getFilteredSlotAssignedNodes(slot) {\n    const owner = getNodeOwner(slot);\n    if (isNull(owner)) {\n        return [];\n    }\n    const childNodes = arrayFromCollection(childNodesGetter.call(slot));\n    return ArrayFilter.call(childNodes, (child) => !isNodeShadowed(child) || !isNodeOwnedBy(owner, child));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getInnerHTML(node) {\n    let s = '';\n    const childNodes = getFilteredChildNodes(node);\n    for (let i = 0, len = childNodes.length; i < len; i += 1) {\n        s += getOuterHTML(childNodes[i]);\n    }\n    return s;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\nconst escapeAttrRegExp = /[&\\u00A0\"]/g;\nconst escapeDataRegExp = /[&\\u00A0<>]/g;\nconst { replace, toLowerCase } = String.prototype;\nfunction escapeReplace(c) {\n    switch (c) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        case '\\u00A0':\n            return '&nbsp;';\n        default:\n            return '';\n    }\n}\nfunction escapeAttr(s) {\n    return replace.call(s, escapeAttrRegExp, escapeReplace);\n}\nfunction escapeData(s) {\n    return replace.call(s, escapeDataRegExp, escapeReplace);\n}\n// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\nconst voidElements = new Set([\n    'AREA',\n    'BASE',\n    'BR',\n    'COL',\n    'COMMAND',\n    'EMBED',\n    'HR',\n    'IMG',\n    'INPUT',\n    'KEYGEN',\n    'LINK',\n    'META',\n    'PARAM',\n    'SOURCE',\n    'TRACK',\n    'WBR',\n]);\nconst plaintextParents = new Set([\n    'STYLE',\n    'SCRIPT',\n    'XMP',\n    'IFRAME',\n    'NOEMBED',\n    'NOFRAMES',\n    'PLAINTEXT',\n    'NOSCRIPT',\n]);\nfunction getOuterHTML(node) {\n    switch (node.nodeType) {\n        case ELEMENT_NODE: {\n            const { attributes: attrs } = node;\n            const tagName = tagNameGetter.call(node);\n            let s = '<' + toLowerCase.call(tagName);\n            for (let i = 0, attr; (attr = attrs[i]); i++) {\n                s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n            }\n            s += '>';\n            if (voidElements.has(tagName)) {\n                return s;\n            }\n            return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';\n        }\n        case TEXT_NODE: {\n            const { data, parentNode } = node;\n            if (parentNode instanceof Element &&\n                plaintextParents.has(tagNameGetter.call(parentNode))) {\n                return data;\n            }\n            return escapeData(data);\n        }\n        case CDATA_SECTION_NODE: {\n            return `<!CDATA[[${node.data}]]>`;\n        }\n        case PROCESSING_INSTRUCTION_NODE: {\n            return `<?${node.target} ${node.data}?>`;\n        }\n        case COMMENT_NODE: {\n            return `<!--${node.data}-->`;\n        }\n        default: {\n            // intentionally ignoring unknown node types\n            // Note: since this routine is always invoked for childNodes\n            // we can safety ignore type 9, 10 and 99 (document, fragment and doctype)\n            return '';\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getTextContent(node) {\n    switch (node.nodeType) {\n        case ELEMENT_NODE: {\n            const childNodes = getFilteredChildNodes(node);\n            let content = '';\n            for (let i = 0, len = childNodes.length; i < len; i += 1) {\n                const currentNode = childNodes[i];\n                if (currentNode.nodeType !== COMMENT_NODE) {\n                    content += getTextContent(currentNode);\n                }\n            }\n            return content;\n        }\n        default:\n            return node.nodeValue;\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst Items$1 = new WeakMap();\nfunction StaticNodeList() {\n    throw new TypeError('Illegal constructor');\n}\nStaticNodeList.prototype = create(NodeList.prototype, {\n    constructor: {\n        writable: true,\n        configurable: true,\n        value: StaticNodeList,\n    },\n    item: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(index) {\n            return this[index];\n        },\n    },\n    length: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return Items$1.get(this).length;\n        },\n    },\n    // Iterator protocol\n    forEach: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(cb, thisArg) {\n            forEach.call(Items$1.get(this), cb, thisArg);\n        },\n    },\n    entries: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            return ArrayMap.call(Items$1.get(this), (v, i) => [i, v]);\n        },\n    },\n    keys: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            return ArrayMap.call(Items$1.get(this), (_v, i) => i);\n        },\n    },\n    values: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            return Items$1.get(this);\n        },\n    },\n    [Symbol.iterator]: {\n        writable: true,\n        configurable: true,\n        value() {\n            let nextIndex = 0;\n            return {\n                next: () => {\n                    const items = Items$1.get(this);\n                    return nextIndex < items.length\n                        ? {\n                            value: items[nextIndex++],\n                            done: false,\n                        }\n                        : {\n                            done: true,\n                        };\n                },\n            };\n        },\n    },\n    [Symbol.toStringTag]: {\n        configurable: true,\n        get() {\n            return 'NodeList';\n        },\n    },\n    // IE11 doesn't support Symbol.toStringTag, in which case we\n    // provide the regular toString method.\n    toString: {\n        writable: true,\n        configurable: true,\n        value() {\n            return '[object NodeList]';\n        },\n    },\n});\n// prototype inheritance dance\nsetPrototypeOf(StaticNodeList, NodeList);\nfunction createStaticNodeList(items) {\n    const nodeList = create(StaticNodeList.prototype);\n    Items$1.set(nodeList, items);\n    // setting static indexes\n    forEach.call(items, (item, index) => {\n        defineProperty(nodeList, index, {\n            value: item,\n            enumerable: true,\n            configurable: true,\n        });\n    });\n    return nodeList;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Walk up the DOM tree, collecting all shadow roots plus the document root\nfunction getAllRootNodes(node) {\n    var _a;\n    const rootNodes = [];\n    let currentRootNode = node.getRootNode();\n    while (!isUndefined(currentRootNode)) {\n        rootNodes.push(currentRootNode);\n        currentRootNode = (_a = currentRootNode.host) === null || _a === void 0 ? void 0 : _a.getRootNode();\n    }\n    return rootNodes;\n}\n// Keep searching up the host tree until we find an element that is within the immediate shadow root\nconst findAncestorHostInImmediateShadowRoot = (rootNode, targetRootNode) => {\n    let host;\n    while (!isUndefined((host = rootNode.host))) {\n        const thisRootNode = host.getRootNode();\n        if (thisRootNode === targetRootNode) {\n            return host;\n        }\n        rootNode = thisRootNode;\n    }\n};\nfunction fauxElementsFromPoint(context, doc, left, top) {\n    const elements = elementsFromPoint.call(doc, left, top);\n    const result = [];\n    const rootNodes = getAllRootNodes(context);\n    // Filter the elements array to only include those elements that are in this shadow root or in one of its\n    // ancestor roots. This matches Chrome and Safari's implementation (but not Firefox's, which only includes\n    // elements in the immediate shadow root: https://crbug.com/1207863#c4).\n    if (!isNull(elements)) {\n        // can be null in IE https://developer.mozilla.org/en-US/docs/Web/API/Document/elementsFromPoint#browser_compatibility\n        for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            if (isSyntheticSlotElement(element)) {\n                continue;\n            }\n            const elementRootNode = element.getRootNode();\n            if (ArrayIndexOf.call(rootNodes, elementRootNode) !== -1) {\n                ArrayPush.call(result, element);\n                continue;\n            }\n            // In cases where the host element is not visible but its shadow descendants are, then\n            // we may get the shadow descendant instead of the host element here. (The\n            // browser doesn't know the difference in synthetic shadow DOM.)\n            // In native shadow DOM, however, elementsFromPoint would return the host but not\n            // the child. So we need to detect if this shadow element's host is accessible from\n            // the context's shadow root. Note we also need to be careful not to add the host\n            // multiple times.\n            const ancestorHost = findAncestorHostInImmediateShadowRoot(elementRootNode, rootNodes[0]);\n            if (!isUndefined(ancestorHost) &&\n                ArrayIndexOf.call(elements, ancestorHost) === -1 &&\n                ArrayIndexOf.call(result, ancestorHost) === -1) {\n                ArrayPush.call(result, ancestorHost);\n            }\n        }\n    }\n    return result;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst Items = new WeakMap();\nfunction StaticHTMLCollection() {\n    throw new TypeError('Illegal constructor');\n}\nStaticHTMLCollection.prototype = create(HTMLCollection.prototype, {\n    constructor: {\n        writable: true,\n        configurable: true,\n        value: StaticHTMLCollection,\n    },\n    item: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(index) {\n            return this[index];\n        },\n    },\n    length: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return Items.get(this).length;\n        },\n    },\n    // https://dom.spec.whatwg.org/#dom-htmlcollection-nameditem-key\n    namedItem: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(name) {\n            if (name === '') {\n                return null;\n            }\n            const items = Items.get(this);\n            for (let i = 0, len = items.length; i < len; i++) {\n                const item = items[len];\n                if (name === getAttribute.call(item, 'id') ||\n                    name === getAttribute.call(item, 'name')) {\n                    return item;\n                }\n            }\n            return null;\n        },\n    },\n    [Symbol.toStringTag]: {\n        configurable: true,\n        get() {\n            return 'HTMLCollection';\n        },\n    },\n    // IE11 doesn't support Symbol.toStringTag, in which case we\n    // provide the regular toString method.\n    toString: {\n        writable: true,\n        configurable: true,\n        value() {\n            return '[object HTMLCollection]';\n        },\n    },\n});\n// prototype inheritance dance\nsetPrototypeOf(StaticHTMLCollection, HTMLCollection);\nfunction createStaticHTMLCollection(items) {\n    const collection = create(StaticHTMLCollection.prototype);\n    Items.set(collection, items);\n    // setting static indexes\n    forEach.call(items, (item, index) => {\n        defineProperty(collection, index, {\n            value: item,\n            enumerable: true,\n            configurable: true,\n        });\n    });\n    return collection;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This method checks whether or not the content of the node is computed\n * based on the light-dom slotting mechanism. This applies to synthetic slot elements\n * and elements with shadow dom attached to them. It doesn't apply to native slot elements\n * because we don't want to patch the children getters for those elements.\n */\nfunction hasMountedChildren(node) {\n    return isSyntheticSlotElement(node) || isSyntheticShadowHost(node);\n}\nfunction getShadowParent(node, value) {\n    const owner = getNodeOwner(node);\n    if (value === owner) {\n        // walking up via parent chain might end up in the shadow root element\n        return getShadowRoot(owner);\n    }\n    else if (value instanceof Element) {\n        if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {\n            // the element and its parent node belong to the same shadow root\n            return value;\n        }\n        else if (!isNull(owner) && isSlotElement(value)) {\n            // slotted elements must be top level childNodes of the slot element\n            // where they slotted into, but its shadowed parent is always the\n            // owner of the slot.\n            const slotOwner = getNodeOwner(value);\n            if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {\n                // it is a slotted element, and therefore its parent is always going to be the host of the slot\n                return slotOwner;\n            }\n        }\n    }\n    return null;\n}\nfunction hasChildNodesPatched() {\n    return getInternalChildNodes(this).length > 0;\n}\nfunction firstChildGetterPatched() {\n    const childNodes = getInternalChildNodes(this);\n    return childNodes[0] || null;\n}\nfunction lastChildGetterPatched() {\n    const childNodes = getInternalChildNodes(this);\n    return childNodes[childNodes.length - 1] || null;\n}\nfunction textContentGetterPatched() {\n    return getTextContent(this);\n}\nfunction textContentSetterPatched(value) {\n    textContextSetter.call(this, value);\n}\nfunction parentNodeGetterPatched() {\n    const value = parentNodeGetter.call(this);\n    if (isNull(value)) {\n        return value;\n    }\n    // TODO [#1635]: this needs optimization, maybe implementing it based on this.assignedSlot\n    return getShadowParent(this, value);\n}\nfunction parentElementGetterPatched() {\n    const value = parentNodeGetter.call(this);\n    if (isNull(value)) {\n        return null;\n    }\n    const parentNode = getShadowParent(this, value);\n    // it could be that the parentNode is the shadowRoot, in which case\n    // we need to return null.\n    // TODO [#1635]: this needs optimization, maybe implementing it based on this.assignedSlot\n    return parentNode instanceof Element ? parentNode : null;\n}\nfunction compareDocumentPositionPatched(otherNode) {\n    if (this === otherNode) {\n        return 0;\n    }\n    else if (this.getRootNode() === otherNode) {\n        // \"this\" is in a shadow tree where the shadow root is the \"otherNode\".\n        return 10; // Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING\n    }\n    else if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {\n        // \"this\" and \"otherNode\" belongs to 2 different shadow tree.\n        return 35; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node.DOCUMENT_POSITION_PRECEDING\n    }\n    // Since \"this\" and \"otherNode\" are part of the same shadow tree we can safely rely to the native\n    // Node.compareDocumentPosition implementation.\n    return compareDocumentPosition.call(this, otherNode);\n}\nfunction containsPatched(otherNode) {\n    if (otherNode == null || getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {\n        // it is from another shadow\n        return false;\n    }\n    return (compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;\n}\nfunction cloneNodePatched(deep) {\n    const clone = cloneNode.call(this, false);\n    // Per spec, browsers only care about truthy values\n    // Not strict true or false\n    if (!deep) {\n        return clone;\n    }\n    const childNodes = getInternalChildNodes(this);\n    for (let i = 0, len = childNodes.length; i < len; i += 1) {\n        clone.appendChild(childNodes[i].cloneNode(true));\n    }\n    return clone;\n}\n/**\n * This method only applies to elements with a shadow or slots\n */\nfunction childNodesGetterPatched() {\n    if (isSyntheticShadowHost(this)) {\n        const owner = getNodeOwner(this);\n        const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));\n        if (process.env.NODE_ENV !== 'production' &&\n            isFalse(hasNativeSymbolSupport) &&\n            isExternalChildNodeAccessorFlagOn()) {\n            // inserting a comment node as the first childNode to trick the IE11\n            // DevTool to show the content of the shadowRoot, this should only happen\n            // in dev-mode and in IE11 (which we detect by looking at the symbol).\n            // Plus it should only be in place if we know it is an external invoker.\n            ArrayUnshift.call(childNodes, getIE11FakeShadowRootPlaceholder(this));\n        }\n        return createStaticNodeList(childNodes);\n    }\n    // nothing to do here since this does not have a synthetic shadow attached to it\n    // TODO [#1636]: what about slot elements?\n    return childNodesGetter.call(this);\n}\nconst nativeGetRootNode = _Node.prototype.getRootNode;\n/**\n * Get the root by climbing up the dom tree, beyond the shadow root\n * If Node.prototype.getRootNode is supported, use it\n * else, assume we are working in non-native shadow mode and climb using parentNode\n */\nconst getDocumentOrRootNode = !isUndefined(nativeGetRootNode)\n    ? nativeGetRootNode\n    : function () {\n        let node = this;\n        let nodeParent;\n        while (!isNull((nodeParent = parentNodeGetter.call(node)))) {\n            node = nodeParent;\n        }\n        return node;\n    };\n/**\n * Get the shadow root\n * getNodeOwner() returns the host element that owns the given node\n * Note: getNodeOwner() returns null when running in native-shadow mode.\n *  Fallback to using the native getRootNode() to discover the root node.\n *  This is because, it is not possible to inspect the node and decide if it is part\n *  of a native shadow or the synthetic shadow.\n * @param {Node} node\n */\nfunction getNearestRoot(node) {\n    const ownerNode = getNodeOwner(node);\n    if (isNull(ownerNode)) {\n        // we hit a wall, either we are in native shadow mode or the node is not in lwc boundary.\n        return getDocumentOrRootNode.call(node);\n    }\n    return getShadowRoot(ownerNode);\n}\n/**\n * If looking for a root node beyond shadow root by calling `node.getRootNode({composed: true})`, use the original `Node.prototype.getRootNode` method\n * to return the root of the dom tree. In IE11 and Edge, Node.prototype.getRootNode is\n * [not supported](https://developer.mozilla.org/en-US/docs/Web/API/Node/getRootNode#Browser_compatibility). The root node is discovered by manually\n * climbing up the dom tree.\n *\n * If looking for a shadow root of a node by calling `node.getRootNode({composed: false})` or `node.getRootNode()`,\n *\n *  1. Try to identify the host element that owns the give node.\n *     i. Identify the shadow tree that the node belongs to\n *     ii. If the node belongs to a shadow tree created by engine, return the shadowRoot of the host element that owns the shadow tree\n *  2. The host identification logic returns null in two cases:\n *     i. The node does not belong to a shadow tree created by engine\n *     ii. The engine is running in native shadow dom mode\n *     If so, use the original Node.prototype.getRootNode to fetch the root node(or manually climb up the dom tree where getRootNode() is unsupported)\n *\n * _Spec_: https://dom.spec.whatwg.org/#dom-node-getrootnode\n *\n **/\nfunction getRootNodePatched(options) {\n    const composed = isUndefined(options) ? false : !!options.composed;\n    return isTrue(composed) ? getDocumentOrRootNode.call(this, options) : getNearestRoot(this);\n}\n// Non-deep-traversing patches: this descriptor map includes all descriptors that\n// do not give access to nodes beyond the immediate children.\ndefineProperties(_Node.prototype, {\n    firstChild: {\n        get() {\n            if (hasMountedChildren(this)) {\n                return firstChildGetterPatched.call(this);\n            }\n            return firstChildGetter.call(this);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    lastChild: {\n        get() {\n            if (hasMountedChildren(this)) {\n                return lastChildGetterPatched.call(this);\n            }\n            return lastChildGetter.call(this);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    textContent: {\n        get() {\n            // Note: we deviate from native shadow here, but are not fixing\n            // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n            if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {\n                return textContentGetterPatched.call(this);\n            }\n            return textContentGetter.call(this);\n        },\n        set: textContentSetterPatched,\n        enumerable: true,\n        configurable: true,\n    },\n    parentNode: {\n        get() {\n            if (isNodeShadowed(this)) {\n                return parentNodeGetterPatched.call(this);\n            }\n            const parentNode = parentNodeGetter.call(this);\n            // Handle the case where a top level light DOM element is slotted into a synthetic\n            // shadow slot.\n            if (!isNull(parentNode) && isSyntheticSlotElement(parentNode)) {\n                return getNodeOwner(parentNode);\n            }\n            return parentNode;\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    parentElement: {\n        get() {\n            if (isNodeShadowed(this)) {\n                return parentElementGetterPatched.call(this);\n            }\n            const parentElement = parentElementGetter.call(this);\n            // Handle the case where a top level light DOM element is slotted into a synthetic\n            // shadow slot.\n            if (!isNull(parentElement) && isSyntheticSlotElement(parentElement)) {\n                return getNodeOwner(parentElement);\n            }\n            return parentElement;\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    childNodes: {\n        get() {\n            if (hasMountedChildren(this)) {\n                return childNodesGetterPatched.call(this);\n            }\n            return childNodesGetter.call(this);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    hasChildNodes: {\n        value() {\n            if (hasMountedChildren(this)) {\n                return hasChildNodesPatched.call(this);\n            }\n            return hasChildNodes.call(this);\n        },\n        enumerable: true,\n        writable: true,\n        configurable: true,\n    },\n    compareDocumentPosition: {\n        value(otherNode) {\n            // Note: we deviate from native shadow here, but are not fixing\n            // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n            if (isGlobalPatchingSkipped(this)) {\n                return compareDocumentPosition.call(this, otherNode);\n            }\n            return compareDocumentPositionPatched.call(this, otherNode);\n        },\n        enumerable: true,\n        writable: true,\n        configurable: true,\n    },\n    contains: {\n        value(otherNode) {\n            // 1. Node.prototype.contains() returns true if otherNode is an inclusive descendant\n            //    spec: https://dom.spec.whatwg.org/#dom-node-contains\n            // 2. This normalizes the behavior of this api across all browsers.\n            //    In IE11, a disconnected dom element without children invoking contains() on self, returns false\n            if (this === otherNode) {\n                return true;\n            }\n            // Note: we deviate from native shadow here, but are not fixing\n            // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n            if (otherNode == null) {\n                return false;\n            }\n            if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {\n                return containsPatched.call(this, otherNode);\n            }\n            return contains.call(this, otherNode);\n        },\n        enumerable: true,\n        writable: true,\n        configurable: true,\n    },\n    cloneNode: {\n        value(deep) {\n            // Note: we deviate from native shadow here, but are not fixing\n            // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n            if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {\n                return cloneNodePatched.call(this, deep);\n            }\n            return cloneNode.call(this, deep);\n        },\n        enumerable: true,\n        writable: true,\n        configurable: true,\n    },\n    getRootNode: {\n        value: getRootNodePatched,\n        enumerable: true,\n        configurable: true,\n        writable: true,\n    },\n    isConnected: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return isConnected.call(this);\n        },\n    },\n});\nlet internalChildNodeAccessorFlag = false;\n/**\n * These 2 methods are providing a machinery to understand who is accessing the\n * .childNodes member property of a node. If it is used from inside the synthetic shadow\n * or from an external invoker. This helps to produce the right output in one very peculiar\n * case, the IE11 debugging comment for shadowRoot representation on the devtool.\n */\nfunction isExternalChildNodeAccessorFlagOn() {\n    return !internalChildNodeAccessorFlag;\n}\nconst getInternalChildNodes = process.env.NODE_ENV !== 'production' && isFalse(hasNativeSymbolSupport)\n    ? function (node) {\n        internalChildNodeAccessorFlag = true;\n        let childNodes;\n        let error = null;\n        try {\n            childNodes = node.childNodes;\n        }\n        catch (e) {\n            // childNodes accessor should never throw, but just in case!\n            error = e;\n        }\n        finally {\n            internalChildNodeAccessorFlag = false;\n            if (!isNull(error)) {\n                // re-throwing after restoring the state machinery for setInternalChildNodeAccessorFlag\n                throw error; // eslint-disable-line no-unsafe-finally\n            }\n        }\n        return childNodes;\n    }\n    : function (node) {\n        return node.childNodes;\n    };\n// IE11 extra patches for wrong prototypes\nif (hasOwnProperty.call(HTMLElement.prototype, 'contains')) {\n    defineProperty(HTMLElement.prototype, 'contains', getOwnPropertyDescriptor(_Node.prototype, 'contains'));\n}\nif (hasOwnProperty.call(HTMLElement.prototype, 'parentElement')) {\n    defineProperty(HTMLElement.prototype, 'parentElement', getOwnPropertyDescriptor(_Node.prototype, 'parentElement'));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst EventListenerMap = new WeakMap();\nconst ComposedPathMap = new WeakMap();\nfunction isEventListenerOrEventListenerObject(fnOrObj) {\n    return (isFunction(fnOrObj) ||\n        (isObject(fnOrObj) &&\n            !isNull(fnOrObj) &&\n            isFunction(fnOrObj.handleEvent)));\n}\nfunction shouldInvokeListener(event, target, currentTarget) {\n    // Subsequent logic assumes that `currentTarget` must be contained in the composed path for the listener to be\n    // invoked, but this is not always the case. `composedPath()` will sometimes return an empty array, even when the\n    // listener should be invoked (e.g., a disconnected instance of EventTarget, an instance of XMLHttpRequest, etc).\n    if (target === currentTarget) {\n        return true;\n    }\n    let composedPath = ComposedPathMap.get(event);\n    if (isUndefined(composedPath)) {\n        composedPath = event.composedPath();\n        ComposedPathMap.set(event, composedPath);\n    }\n    return composedPath.includes(currentTarget);\n}\nfunction getEventListenerWrapper(fnOrObj) {\n    if (!isEventListenerOrEventListenerObject(fnOrObj)) {\n        return fnOrObj;\n    }\n    let wrapperFn = EventListenerMap.get(fnOrObj);\n    if (isUndefined(wrapperFn)) {\n        wrapperFn = function (event) {\n            // This function is invoked from an event listener and currentTarget is always defined.\n            const currentTarget = eventCurrentTargetGetter.call(event);\n            if (process.env.NODE_ENV !== 'production') {\n                assert.invariant(isFalse(isSyntheticShadowHost(currentTarget)), 'This routine should not be used to wrap event listeners for host elements and shadow roots.');\n            }\n            const actualTarget = getActualTarget(event);\n            if (!shouldInvokeListener(event, actualTarget, currentTarget)) {\n                return;\n            }\n            return isFunction(fnOrObj)\n                ? fnOrObj.call(this, event)\n                : fnOrObj.handleEvent && fnOrObj.handleEvent(event);\n        };\n        EventListenerMap.set(fnOrObj, wrapperFn);\n    }\n    return wrapperFn;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst eventToContextMap = new WeakMap();\nconst customElementToWrappedListeners = new WeakMap();\nfunction getEventMap(elm) {\n    let listenerInfo = customElementToWrappedListeners.get(elm);\n    if (isUndefined(listenerInfo)) {\n        listenerInfo = create(null);\n        customElementToWrappedListeners.set(elm, listenerInfo);\n    }\n    return listenerInfo;\n}\n/**\n * Events dispatched on shadow roots actually end up being dispatched on their hosts. This means that the event.target\n * property of events dispatched on shadow roots always resolve to their host. This function understands this\n * abstraction and properly returns a reference to the shadow root when appropriate.\n */\nfunction getActualTarget(event) {\n    var _a;\n    return (_a = eventToShadowRootMap.get(event)) !== null && _a !== void 0 ? _a : eventTargetGetter.call(event);\n}\nconst shadowRootEventListenerMap = new WeakMap();\nfunction getWrappedShadowRootListener(listener) {\n    if (!isFunction(listener)) {\n        throw new TypeError(); // avoiding problems with non-valid listeners\n    }\n    let shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);\n    if (isUndefined(shadowRootWrappedListener)) {\n        shadowRootWrappedListener = function (event) {\n            // currentTarget is always defined inside an event listener\n            let currentTarget = eventCurrentTargetGetter.call(event);\n            // If currentTarget is not an instance of a native shadow root then we're dealing with a\n            // host element whose synthetic shadow root must be accessed via getShadowRoot().\n            if (!isInstanceOfNativeShadowRoot(currentTarget)) {\n                currentTarget = getShadowRoot(currentTarget);\n            }\n            const actualTarget = getActualTarget(event);\n            if (shouldInvokeListener(event, actualTarget, currentTarget)) {\n                listener.call(currentTarget, event);\n            }\n        };\n        shadowRootWrappedListener.placement = 1 /* EventListenerContext.SHADOW_ROOT_LISTENER */;\n        shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);\n    }\n    return shadowRootWrappedListener;\n}\nconst customElementEventListenerMap = new WeakMap();\nfunction getWrappedCustomElementListener(listener) {\n    if (!isFunction(listener)) {\n        throw new TypeError(); // avoiding problems with non-valid listeners\n    }\n    let customElementWrappedListener = customElementEventListenerMap.get(listener);\n    if (isUndefined(customElementWrappedListener)) {\n        customElementWrappedListener = function (event) {\n            // currentTarget is always defined inside an event listener\n            const currentTarget = eventCurrentTargetGetter.call(event);\n            const actualTarget = getActualTarget(event);\n            if (shouldInvokeListener(event, actualTarget, currentTarget)) {\n                listener.call(currentTarget, event);\n            }\n        };\n        customElementWrappedListener.placement = 0 /* EventListenerContext.CUSTOM_ELEMENT_LISTENER */;\n        customElementEventListenerMap.set(listener, customElementWrappedListener);\n    }\n    return customElementWrappedListener;\n}\nfunction domListener(evt) {\n    let immediatePropagationStopped = false;\n    let propagationStopped = false;\n    const { type, stopImmediatePropagation, stopPropagation } = evt;\n    // currentTarget is always defined\n    const currentTarget = eventCurrentTargetGetter.call(evt);\n    const listenerMap = getEventMap(currentTarget);\n    const listeners = listenerMap[type]; // it must have listeners at this point\n    defineProperty(evt, 'stopImmediatePropagation', {\n        value() {\n            immediatePropagationStopped = true;\n            stopImmediatePropagation.call(evt);\n        },\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    });\n    defineProperty(evt, 'stopPropagation', {\n        value() {\n            propagationStopped = true;\n            stopPropagation.call(evt);\n        },\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    });\n    // in case a listener adds or removes other listeners during invocation\n    const bookkeeping = ArraySlice.call(listeners);\n    function invokeListenersByPlacement(placement) {\n        forEach.call(bookkeeping, (listener) => {\n            if (isFalse(immediatePropagationStopped) && listener.placement === placement) {\n                // making sure that the listener was not removed from the original listener queue\n                if (ArrayIndexOf.call(listeners, listener) !== -1) {\n                    // all handlers on the custom element should be called with undefined 'this'\n                    listener.call(undefined, evt);\n                }\n            }\n        });\n    }\n    eventToContextMap.set(evt, 1 /* EventListenerContext.SHADOW_ROOT_LISTENER */);\n    invokeListenersByPlacement(1 /* EventListenerContext.SHADOW_ROOT_LISTENER */);\n    if (isFalse(immediatePropagationStopped) && isFalse(propagationStopped)) {\n        // doing the second iteration only if the first one didn't interrupt the event propagation\n        eventToContextMap.set(evt, 0 /* EventListenerContext.CUSTOM_ELEMENT_LISTENER */);\n        invokeListenersByPlacement(0 /* EventListenerContext.CUSTOM_ELEMENT_LISTENER */);\n    }\n    eventToContextMap.set(evt, 2 /* EventListenerContext.UNKNOWN_LISTENER */);\n}\nfunction attachDOMListener(elm, type, wrappedListener) {\n    const listenerMap = getEventMap(elm);\n    let cmpEventHandlers = listenerMap[type];\n    if (isUndefined(cmpEventHandlers)) {\n        cmpEventHandlers = listenerMap[type] = [];\n    }\n    // Prevent identical listeners from subscribing to the same event type.\n    // TODO [#1824]: Options will also play a factor when we introduce support for them (#1824).\n    if (ArrayIndexOf.call(cmpEventHandlers, wrappedListener) !== -1) {\n        return;\n    }\n    // only add to DOM if there is no other listener on the same placement yet\n    if (cmpEventHandlers.length === 0) {\n        // super.addEventListener() - this will not work on\n        addEventListener.call(elm, type, domListener);\n    }\n    ArrayPush.call(cmpEventHandlers, wrappedListener);\n}\nfunction detachDOMListener(elm, type, wrappedListener) {\n    const listenerMap = getEventMap(elm);\n    let p;\n    let listeners;\n    if (!isUndefined((listeners = listenerMap[type])) &&\n        (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {\n        ArraySplice.call(listeners, p, 1);\n        // only remove from DOM if there is no other listener on the same placement\n        if (listeners.length === 0) {\n            removeEventListener.call(elm, type, domListener);\n        }\n    }\n}\nfunction addCustomElementEventListener(type, listener, _options) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isFunction(listener)) {\n            throw new TypeError(`Invalid second argument for Element.addEventListener() in ${toString(this)} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n        }\n    }\n    // TODO [#1824]: Lift this restriction on the option parameter\n    if (isFunction(listener)) {\n        const wrappedListener = getWrappedCustomElementListener(listener);\n        attachDOMListener(this, type, wrappedListener);\n    }\n}\nfunction removeCustomElementEventListener(type, listener, _options) {\n    // TODO [#1824]: Lift this restriction on the option parameter\n    if (isFunction(listener)) {\n        const wrappedListener = getWrappedCustomElementListener(listener);\n        detachDOMListener(this, type, wrappedListener);\n    }\n}\nfunction addShadowRootEventListener(sr, type, listener, _options) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (!isFunction(listener)) {\n            throw new TypeError(`Invalid second argument for ShadowRoot.addEventListener() in ${toString(sr)} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n        }\n    }\n    // TODO [#1824]: Lift this restriction on the option parameter\n    if (isFunction(listener)) {\n        const elm = getHost(sr);\n        const wrappedListener = getWrappedShadowRootListener(listener);\n        attachDOMListener(elm, type, wrappedListener);\n    }\n}\nfunction removeShadowRootEventListener(sr, type, listener, _options) {\n    // TODO [#1824]: Lift this restriction on the option parameter\n    if (isFunction(listener)) {\n        const elm = getHost(sr);\n        const wrappedListener = getWrappedShadowRootListener(listener);\n        detachDOMListener(elm, type, wrappedListener);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst InternalSlot = new WeakMap();\nconst { createDocumentFragment } = document;\nfunction hasInternalSlot(root) {\n    return InternalSlot.has(root);\n}\nfunction getInternalSlot(root) {\n    const record = InternalSlot.get(root);\n    if (isUndefined(record)) {\n        throw new TypeError();\n    }\n    return record;\n}\ndefineProperty(_Node.prototype, KEY__SHADOW_RESOLVER, {\n    set(fn) {\n        if (isUndefined(fn))\n            return;\n        this[KEY__SHADOW_RESOLVER_PRIVATE] = fn;\n        // TODO [#1164]: temporary propagation of the key\n        setNodeOwnerKey(this, fn.nodeKey);\n    },\n    get() {\n        return this[KEY__SHADOW_RESOLVER_PRIVATE];\n    },\n    configurable: true,\n    enumerable: true,\n});\ndefineProperty(_globalThis, KEY__IS_NATIVE_SHADOW_ROOT_DEFINED, {\n    value: isNativeShadowRootDefined,\n});\n// The isUndefined check is because two copies of synthetic shadow may be loaded on the same page, and this\n// would throw an error if we tried to redefine it. Plus the whole point is to expose the native method.\nif (isUndefined(_globalThis[KEY__NATIVE_GET_ELEMENT_BY_ID])) {\n    defineProperty(_globalThis, KEY__NATIVE_GET_ELEMENT_BY_ID, { value: getElementById });\n}\n// See note above.\nif (isUndefined(_globalThis[KEY__NATIVE_QUERY_SELECTOR_ALL])) {\n    defineProperty(_globalThis, KEY__NATIVE_QUERY_SELECTOR_ALL, { value: querySelectorAll });\n}\nfunction getShadowRootResolver(node) {\n    return node[KEY__SHADOW_RESOLVER];\n}\nfunction setShadowRootResolver(node, fn) {\n    node[KEY__SHADOW_RESOLVER] = fn;\n}\nfunction isDelegatingFocus(host) {\n    return getInternalSlot(host).delegatesFocus;\n}\nfunction getHost(root) {\n    return getInternalSlot(root).host;\n}\nfunction getShadowRoot(elm) {\n    return getInternalSlot(elm).shadowRoot;\n}\n// Intentionally adding `Node` here in addition to `Element` since this check is harmless for nodes\n// and we can avoid having to cast the type before calling this method in a few places.\nfunction isSyntheticShadowHost(node) {\n    const shadowRootRecord = InternalSlot.get(node);\n    return !isUndefined(shadowRootRecord) && node === shadowRootRecord.host;\n}\nfunction isSyntheticShadowRoot(node) {\n    const shadowRootRecord = InternalSlot.get(node);\n    return !isUndefined(shadowRootRecord) && node === shadowRootRecord.shadowRoot;\n}\nlet uid = 0;\nfunction attachShadow(elm, options) {\n    if (InternalSlot.has(elm)) {\n        throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);\n    }\n    const { mode, delegatesFocus } = options;\n    // creating a real fragment for shadowRoot instance\n    const doc = getOwnerDocument(elm);\n    const sr = createDocumentFragment.call(doc);\n    // creating shadow internal record\n    const record = {\n        mode,\n        delegatesFocus: !!delegatesFocus,\n        host: elm,\n        shadowRoot: sr,\n    };\n    InternalSlot.set(sr, record);\n    InternalSlot.set(elm, record);\n    const shadowResolver = () => sr;\n    const x = (shadowResolver.nodeKey = uid++);\n    setNodeKey(elm, x);\n    setShadowRootResolver(sr, shadowResolver);\n    // correcting the proto chain\n    setPrototypeOf(sr, SyntheticShadowRoot.prototype);\n    return sr;\n}\nconst SyntheticShadowRootDescriptors = {\n    constructor: {\n        writable: true,\n        configurable: true,\n        value: SyntheticShadowRoot,\n    },\n    toString: {\n        writable: true,\n        configurable: true,\n        value() {\n            return `[object ShadowRoot]`;\n        },\n    },\n    synthetic: {\n        writable: false,\n        enumerable: false,\n        configurable: false,\n        value: true,\n    },\n};\nconst ShadowRootDescriptors = {\n    activeElement: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const host = getHost(this);\n            const doc = getOwnerDocument(host);\n            const activeElement = DocumentPrototypeActiveElement.call(doc);\n            if (isNull(activeElement)) {\n                return activeElement;\n            }\n            if ((compareDocumentPosition.call(host, activeElement) &\n                DOCUMENT_POSITION_CONTAINED_BY) ===\n                0) {\n                return null;\n            }\n            // activeElement must be child of the host and owned by it\n            let node = activeElement;\n            while (!isNodeOwnedBy(host, node)) {\n                // parentElement is always an element because we are talking up the tree knowing\n                // that it is a child of the host.\n                node = parentElementGetter.call(node);\n            }\n            // If we have a slot element here that means that we were dealing\n            // with an element that was passed to one of our slots. In this\n            // case, activeElement returns null.\n            if (isSlotElement(node)) {\n                return null;\n            }\n            return node;\n        },\n    },\n    delegatesFocus: {\n        configurable: true,\n        get() {\n            return getInternalSlot(this).delegatesFocus;\n        },\n    },\n    elementFromPoint: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(left, top) {\n            const host = getHost(this);\n            const doc = getOwnerDocument(host);\n            return fauxElementFromPoint(this, doc, left, top);\n        },\n    },\n    elementsFromPoint: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(left, top) {\n            const host = getHost(this);\n            const doc = getOwnerDocument(host);\n            return fauxElementsFromPoint(this, doc, left, top);\n        },\n    },\n    getSelection: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            throw new Error('Disallowed method \"getSelection\" on ShadowRoot.');\n        },\n    },\n    host: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return getHost(this);\n        },\n    },\n    mode: {\n        configurable: true,\n        get() {\n            return getInternalSlot(this).mode;\n        },\n    },\n    styleSheets: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            throw new Error();\n        },\n    },\n};\nconst eventToShadowRootMap = new WeakMap();\nconst NodePatchDescriptors = {\n    insertBefore: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(newChild, refChild) {\n            insertBefore.call(getHost(this), newChild, refChild);\n            return newChild;\n        },\n    },\n    removeChild: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(oldChild) {\n            removeChild.call(getHost(this), oldChild);\n            return oldChild;\n        },\n    },\n    appendChild: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(newChild) {\n            appendChild.call(getHost(this), newChild);\n            return newChild;\n        },\n    },\n    replaceChild: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(newChild, oldChild) {\n            replaceChild.call(getHost(this), newChild, oldChild);\n            return oldChild;\n        },\n    },\n    addEventListener: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(type, listener, options) {\n            addShadowRootEventListener(this, type, listener);\n        },\n    },\n    dispatchEvent: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(evt) {\n            eventToShadowRootMap.set(evt, this);\n            // Typescript does not like it when you treat the `arguments` object as an array\n            // @ts-ignore type-mismatch\n            return dispatchEvent.apply(getHost(this), arguments);\n        },\n    },\n    removeEventListener: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(type, listener, options) {\n            removeShadowRootEventListener(this, type, listener);\n        },\n    },\n    baseURI: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return getHost(this).baseURI;\n        },\n    },\n    childNodes: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return createStaticNodeList(shadowRootChildNodes(this));\n        },\n    },\n    cloneNode: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            throw new Error('Disallowed method \"cloneNode\" on ShadowRoot.');\n        },\n    },\n    compareDocumentPosition: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(otherNode) {\n            const host = getHost(this);\n            if (this === otherNode) {\n                // \"this\" and \"otherNode\" are the same shadow root.\n                return 0;\n            }\n            else if (this.contains(otherNode)) {\n                // \"otherNode\" belongs to the shadow tree where \"this\" is the shadow root.\n                return 20; // Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING\n            }\n            else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {\n                // \"otherNode\" is in a different shadow tree contained by the shadow tree where \"this\" is the shadow root.\n                return 37; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\n            }\n            else {\n                // \"otherNode\" is in a different shadow tree that is not contained by the shadow tree where \"this\" is the shadow root.\n                return 35; // Node.DOCUMENT_POSITION_DISCONNECTED | Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\n            }\n        },\n    },\n    contains: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(otherNode) {\n            if (this === otherNode) {\n                return true;\n            }\n            const host = getHost(this);\n            // must be child of the host and owned by it.\n            return ((compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !==\n                0 && isNodeOwnedBy(host, otherNode));\n        },\n    },\n    firstChild: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const childNodes = getInternalChildNodes(this);\n            return childNodes[0] || null;\n        },\n    },\n    lastChild: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const childNodes = getInternalChildNodes(this);\n            return childNodes[childNodes.length - 1] || null;\n        },\n    },\n    hasChildNodes: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            const childNodes = getInternalChildNodes(this);\n            return childNodes.length > 0;\n        },\n    },\n    isConnected: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return isConnected.call(getHost(this));\n        },\n    },\n    nextSibling: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    previousSibling: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    nodeName: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return '#document-fragment';\n        },\n    },\n    nodeType: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return 11; // Node.DOCUMENT_FRAGMENT_NODE\n        },\n    },\n    nodeValue: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    ownerDocument: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return getHost(this).ownerDocument;\n        },\n    },\n    parentElement: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    parentNode: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    textContent: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const childNodes = getInternalChildNodes(this);\n            let textContent = '';\n            for (let i = 0, len = childNodes.length; i < len; i += 1) {\n                const currentNode = childNodes[i];\n                if (currentNode.nodeType !== COMMENT_NODE) {\n                    textContent += getTextContent(currentNode);\n                }\n            }\n            return textContent;\n        },\n        set(v) {\n            const host = getHost(this);\n            textContextSetter.call(host, v);\n        },\n    },\n    // Since the synthetic shadow root is a detached DocumentFragment, short-circuit the getRootNode behavior\n    getRootNode: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(options) {\n            return !isUndefined(options) && isTrue(options.composed)\n                ? getHost(this).getRootNode(options)\n                : this;\n        },\n    },\n};\nconst ElementPatchDescriptors = {\n    innerHTML: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const childNodes = getInternalChildNodes(this);\n            let innerHTML = '';\n            for (let i = 0, len = childNodes.length; i < len; i += 1) {\n                innerHTML += getOuterHTML(childNodes[i]);\n            }\n            return innerHTML;\n        },\n        set(v) {\n            const host = getHost(this);\n            innerHTMLSetter.call(host, v);\n        },\n    },\n};\nconst ParentNodePatchDescriptors = {\n    childElementCount: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return this.children.length;\n        },\n    },\n    children: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), (elm) => elm instanceof Element));\n        },\n    },\n    firstElementChild: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return this.children[0] || null;\n        },\n    },\n    lastElementChild: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const { children } = this;\n            return children.item(children.length - 1) || null;\n        },\n    },\n    getElementById: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            throw new Error('Disallowed method \"getElementById\" on ShadowRoot.');\n        },\n    },\n    querySelector: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(selectors) {\n            return shadowRootQuerySelector(this, selectors);\n        },\n    },\n    querySelectorAll: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(selectors) {\n            return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));\n        },\n    },\n};\nassign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);\nfunction SyntheticShadowRoot() {\n    throw new TypeError('Illegal constructor');\n}\nSyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);\n// `this.shadowRoot instanceof ShadowRoot` should evaluate to true even for synthetic shadow\ndefineProperty(SyntheticShadowRoot, Symbol.hasInstance, {\n    value: function (object) {\n        // Technically we should walk up the entire prototype chain, but with SyntheticShadowRoot\n        // it's reasonable to assume that no one is doing any deep subclasses here.\n        return (isObject(object) &&\n            !isNull(object) &&\n            (isInstanceOfNativeShadowRoot(object) ||\n                getPrototypeOf(object) === SyntheticShadowRoot.prototype));\n    },\n});\n/**\n * This method is only intended to be used in non-production mode in IE11\n * and its role is to produce a 1-1 mapping between a shadowRoot instance\n * and a comment node that is intended to use to trick the IE11 DevTools\n * to show the content of the shadowRoot in the DOM Explorer.\n */\nfunction getIE11FakeShadowRootPlaceholder(host) {\n    const shadowRoot = getShadowRoot(host);\n    // @ts-ignore this $$placeholder$$ is not a security issue because you must\n    // have access to the shadowRoot in order to extract the fake node, which give\n    // you access to the same childNodes of the shadowRoot, so, who cares.\n    let c = shadowRoot.$$placeholder$$;\n    if (!isUndefined(c)) {\n        return c;\n    }\n    const doc = getOwnerDocument(host);\n    // @ts-ignore $$placeholder$$ is fine, read the node above.\n    c = shadowRoot.$$placeholder$$ = createComment.call(doc, '');\n    defineProperties(c, {\n        childNodes: {\n            get() {\n                return shadowRoot.childNodes;\n            },\n            enumerable: true,\n            configurable: true,\n        },\n        tagName: {\n            get() {\n                return `#shadow-root (${shadowRoot.mode})`;\n            },\n            enumerable: true,\n            configurable: true,\n        },\n    });\n    return c;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction pathComposer(startNode, composed) {\n    const composedPath = [];\n    let startRoot;\n    if (startNode instanceof Window) {\n        startRoot = startNode;\n    }\n    else if (startNode instanceof _Node) {\n        startRoot = startNode.getRootNode();\n    }\n    else {\n        return composedPath;\n    }\n    let current = startNode;\n    while (!isNull(current)) {\n        composedPath.push(current);\n        if (current instanceof Element || current instanceof Text) {\n            const assignedSlot = current.assignedSlot;\n            if (!isNull(assignedSlot)) {\n                current = assignedSlot;\n            }\n            else {\n                current = current.parentNode;\n            }\n        }\n        else if ((isSyntheticShadowRoot(current) || isInstanceOfNativeShadowRoot(current)) &&\n            (composed || current !== startRoot)) {\n            current = current.host;\n        }\n        else if (current instanceof _Node) {\n            current = current.parentNode;\n        }\n        else {\n            // could be Window\n            current = null;\n        }\n    }\n    let doc;\n    if (startNode instanceof Window) {\n        doc = startNode.document;\n    }\n    else {\n        doc = getOwnerDocument(startNode);\n    }\n    // event composedPath includes window when startNode's ownerRoot is document\n    if (composedPath[composedPath.length - 1] === doc) {\n        composedPath.push(window);\n    }\n    return composedPath;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nfunction retarget(refNode, path) {\n    if (isNull(refNode)) {\n        return null;\n    }\n    // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n    // shadow-including inclusive ancestor, return ANCESTOR.\n    const refNodePath = pathComposer(refNode, true);\n    const p$ = path;\n    for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n        ancestor = p$[i];\n        root = ancestor instanceof Window ? ancestor : ancestor.getRootNode();\n        if (root !== lastRoot) {\n            rootIdx = refNodePath.indexOf(root);\n            lastRoot = root;\n        }\n        if (!isSyntheticShadowRoot(root) || (!isUndefined(rootIdx) && rootIdx > -1)) {\n            return ancestor;\n        }\n    }\n    return null;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction fauxElementFromPoint(context, doc, left, top) {\n    const element = elementFromPoint.call(doc, left, top);\n    if (isNull(element)) {\n        return element;\n    }\n    return retarget(context, pathComposer(element, true));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction elemFromPoint(left, top) {\n    return fauxElementFromPoint(this, this, left, top);\n}\nDocument.prototype.elementFromPoint = elemFromPoint;\nfunction elemsFromPoint(left, top) {\n    return fauxElementsFromPoint(this, this, left, top);\n}\nDocument.prototype.elementsFromPoint = elemsFromPoint;\n// Go until we reach to top of the LWC tree\ndefineProperty(Document.prototype, 'activeElement', {\n    get() {\n        let node = DocumentPrototypeActiveElement.call(this);\n        if (isNull(node)) {\n            return node;\n        }\n        while (!isUndefined(getNodeOwnerKey(node))) {\n            node = parentElementGetter.call(node);\n            if (isNull(node)) {\n                return null;\n            }\n        }\n        if (node.tagName === 'HTML') {\n            // IE 11. Active element should never be html element\n            node = this.body;\n        }\n        return node;\n    },\n    enumerable: true,\n    configurable: true,\n});\n// The following patched methods hide shadowed elements from global\n// traversing mechanisms. They are simplified for performance reasons to\n// filter by ownership and do not account for slotted elements. This\n// compromise is fine for our synthetic shadow dom because root elements\n// cannot have slotted elements.\n// Another compromise here is that all these traversing methods will return\n// static HTMLCollection or static NodeList. We decided that this compromise\n// is not a big problem considering the amount of code that is relying on\n// the liveliness of these results are rare.\ndefineProperty(Document.prototype, 'getElementById', {\n    value() {\n        const elm = getElementById.apply(this, ArraySlice.call(arguments));\n        if (isNull(elm)) {\n            return null;\n        }\n        // Note: we deviate from native shadow here, but are not fixing\n        // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n        return isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm) ? elm : null;\n    },\n    writable: true,\n    enumerable: true,\n    configurable: true,\n});\ndefineProperty(Document.prototype, 'querySelector', {\n    value() {\n        const elements = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));\n        const filtered = ArrayFind.call(elements, \n        // Note: we deviate from native shadow here, but are not fixing\n        // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n        (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));\n        return !isUndefined(filtered) ? filtered : null;\n    },\n    writable: true,\n    enumerable: true,\n    configurable: true,\n});\ndefineProperty(Document.prototype, 'querySelectorAll', {\n    value() {\n        const elements = arrayFromCollection(querySelectorAll.apply(this, ArraySlice.call(arguments)));\n        const filtered = ArrayFilter.call(elements, \n        // Note: we deviate from native shadow here, but are not fixing\n        // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n        (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));\n        return createStaticNodeList(filtered);\n    },\n    writable: true,\n    enumerable: true,\n    configurable: true,\n});\ndefineProperty(Document.prototype, 'getElementsByClassName', {\n    value() {\n        const elements = arrayFromCollection(getElementsByClassName.apply(this, ArraySlice.call(arguments)));\n        const filtered = ArrayFilter.call(elements, \n        // Note: we deviate from native shadow here, but are not fixing\n        // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n        (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));\n        return createStaticHTMLCollection(filtered);\n    },\n    writable: true,\n    enumerable: true,\n    configurable: true,\n});\ndefineProperty(Document.prototype, 'getElementsByTagName', {\n    value() {\n        const elements = arrayFromCollection(getElementsByTagName.apply(this, ArraySlice.call(arguments)));\n        const filtered = ArrayFilter.call(elements, \n        // Note: we deviate from native shadow here, but are not fixing\n        // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n        (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));\n        return createStaticHTMLCollection(filtered);\n    },\n    writable: true,\n    enumerable: true,\n    configurable: true,\n});\ndefineProperty(Document.prototype, 'getElementsByTagNameNS', {\n    value() {\n        const elements = arrayFromCollection(getElementsByTagNameNS.apply(this, ArraySlice.call(arguments)));\n        const filtered = ArrayFilter.call(elements, \n        // Note: we deviate from native shadow here, but are not fixing\n        // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n        (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));\n        return createStaticHTMLCollection(filtered);\n    },\n    writable: true,\n    enumerable: true,\n    configurable: true,\n});\ndefineProperty(\n// In Firefox v57 and lower, getElementsByName is defined on HTMLDocument.prototype\ngetOwnPropertyDescriptor(HTMLDocument.prototype, 'getElementsByName')\n    ? HTMLDocument.prototype\n    : Document.prototype, 'getElementsByName', {\n    value() {\n        const elements = arrayFromCollection(getElementsByName.apply(this, ArraySlice.call(arguments)));\n        const filtered = ArrayFilter.call(elements, \n        // Note: we deviate from native shadow here, but are not fixing\n        // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n        (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(elm));\n        return createStaticNodeList(filtered);\n    },\n    writable: true,\n    enumerable: true,\n    configurable: true,\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nObject.defineProperty(window, 'ShadowRoot', {\n    value: SyntheticShadowRoot,\n    configurable: true,\n    writable: true,\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');\nfunction detect$3() {\n    if (!composedDescriptor) {\n        // No need to apply this polyfill if this client completely lacks\n        // support for the composed property.\n        return false;\n    }\n    // Assigning a throwaway click event here to suppress a ts error when we\n    // pass clickEvent into the composed getter below. The error is:\n    // [ts] Variable 'clickEvent' is used before being assigned.\n    let clickEvent = new Event('click');\n    const button = document.createElement('button');\n    button.addEventListener('click', (event) => (clickEvent = event));\n    button.click();\n    return !composedDescriptor.get.call(clickEvent);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');\nfunction handleClick(event) {\n    Object.defineProperty(event, 'composed', {\n        configurable: true,\n        enumerable: true,\n        get() {\n            return true;\n        },\n    });\n}\nfunction apply$3() {\n    HTMLElement.prototype.click = function () {\n        addEventListener.call(this, 'click', handleClick);\n        try {\n            originalClickDescriptor.value.call(this);\n        }\n        finally {\n            removeEventListener.call(this, 'click', handleClick);\n        }\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (detect$3()) {\n    apply$3();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect$2() {\n    return new Event('test', { composed: true }).composed !== true;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction apply$2() {\n    // https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n    const composedEvents = assign(create(null), {\n        beforeinput: 1,\n        blur: 1,\n        click: 1,\n        compositionend: 1,\n        compositionstart: 1,\n        compositionupdate: 1,\n        copy: 1,\n        cut: 1,\n        dblclick: 1,\n        DOMActivate: 1,\n        DOMFocusIn: 1,\n        DOMFocusOut: 1,\n        drag: 1,\n        dragend: 1,\n        dragenter: 1,\n        dragleave: 1,\n        dragover: 1,\n        dragstart: 1,\n        drop: 1,\n        focus: 1,\n        focusin: 1,\n        focusout: 1,\n        gotpointercapture: 1,\n        input: 1,\n        keydown: 1,\n        keypress: 1,\n        keyup: 1,\n        lostpointercapture: 1,\n        mousedown: 1,\n        mouseenter: 1,\n        mouseleave: 1,\n        mousemove: 1,\n        mouseout: 1,\n        mouseover: 1,\n        mouseup: 1,\n        paste: 1,\n        pointercancel: 1,\n        pointerdown: 1,\n        pointerenter: 1,\n        pointerleave: 1,\n        pointermove: 1,\n        pointerout: 1,\n        pointerover: 1,\n        pointerup: 1,\n        touchcancel: 1,\n        touchend: 1,\n        touchmove: 1,\n        touchstart: 1,\n        wheel: 1,\n    });\n    const EventConstructor = Event;\n    // Patch Event constructor to add the composed property on events created via new Event.\n    function PatchedEvent(type, eventInitDict) {\n        const event = new EventConstructor(type, eventInitDict);\n        const isComposed = !!(eventInitDict && eventInitDict.composed);\n        Object.defineProperties(event, {\n            composed: {\n                get() {\n                    return isComposed;\n                },\n                configurable: true,\n                enumerable: true,\n            },\n        });\n        return event;\n    }\n    PatchedEvent.prototype = EventConstructor.prototype;\n    PatchedEvent.AT_TARGET = EventConstructor.AT_TARGET;\n    PatchedEvent.BUBBLING_PHASE = EventConstructor.BUBBLING_PHASE;\n    PatchedEvent.CAPTURING_PHASE = EventConstructor.CAPTURING_PHASE;\n    PatchedEvent.NONE = EventConstructor.NONE;\n    window.Event = PatchedEvent;\n    // Patch the Event prototype to add the composed property on user agent dispatched event.\n    Object.defineProperties(Event.prototype, {\n        composed: {\n            get() {\n                const { type } = this;\n                return composedEvents[type] === 1;\n            },\n            configurable: true,\n            enumerable: true,\n        },\n    });\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (detect$2()) {\n    apply$2();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CustomEventConstructor = CustomEvent;\nfunction PatchedCustomEvent(type, eventInitDict) {\n    const event = new CustomEventConstructor(type, eventInitDict);\n    const isComposed = !!(eventInitDict && eventInitDict.composed);\n    Object.defineProperties(event, {\n        composed: {\n            get() {\n                return isComposed;\n            },\n            configurable: true,\n            enumerable: true,\n        },\n    });\n    return event;\n}\nPatchedCustomEvent.prototype = CustomEventConstructor.prototype;\nwindow.CustomEvent = PatchedCustomEvent;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (typeof ClipboardEvent !== 'undefined') {\n    const isComposedType = assign(create(null), {\n        copy: 1,\n        cut: 1,\n        paste: 1,\n    });\n    // Patch the prototype to override the composed property on user-agent dispatched events\n    defineProperties(ClipboardEvent.prototype, {\n        composed: {\n            get() {\n                const { type } = this;\n                return isComposedType[type] === 1;\n            },\n            configurable: true,\n            enumerable: true,\n        },\n    });\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect$1() {\n    // Note: when using this in mobile apps, we might have a DOM that does not support iframes.\n    const hasIframe = typeof HTMLIFrameElement !== 'undefined';\n    // This polyfill should only apply in compat mode; see https://github.com/salesforce/lwc/issues/1513\n    const isCompat = typeof Proxy !== 'undefined' && isTrue(Proxy.isCompat);\n    return hasIframe && isCompat;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction apply$1() {\n    // the iframe property descriptor for `contentWindow` should always be available, otherwise this method should never be called\n    const desc = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow');\n    const { get: originalGetter } = desc;\n    desc.get = function () {\n        const original = originalGetter.call(this);\n        // If the original iframe element is not a keyed node, then do not wrap it\n        if (isNull(original) || isUndefined(getNodeOwnerKey(this))) {\n            return original;\n        }\n        // only if the element is an iframe inside a shadowRoot, we care about this problem\n        // because in that case, the code that is accessing the iframe, is very likely code\n        // compiled with proxy-compat transformation. It is true that other code without those\n        // transformations might also access an iframe from within a shadowRoot, but in that,\n        // case, which is more rare, we still return the wrapper, and it should work the same,\n        // this part is just an optimization.\n        return wrapIframeWindow(original);\n    };\n    defineProperty(HTMLIFrameElement.prototype, 'contentWindow', desc);\n}\nfunction wrapIframeWindow(win) {\n    return {\n        addEventListener() {\n            // Typescript does not like it when you treat the `arguments` object as an array\n            // @ts-ignore type-mismatch\n            return win.addEventListener.apply(win, arguments);\n        },\n        blur() {\n            // Typescript does not like it when you treat the `arguments` object as an array\n            // @ts-ignore type-mismatch\n            return win.blur.apply(win, arguments);\n        },\n        close() {\n            // Typescript does not like it when you treat the `arguments` object as an array\n            // @ts-ignore type-mismatch\n            return win.close.apply(win, arguments);\n        },\n        focus() {\n            // Typescript does not like it when you treat the `arguments` object as an array\n            // @ts-ignore type-mismatch\n            return win.focus.apply(win, arguments);\n        },\n        postMessage() {\n            // Typescript does not like it when you treat the `arguments` object as an array\n            // @ts-ignore type-mismatch\n            return win.postMessage.apply(win, arguments);\n        },\n        removeEventListener() {\n            // Typescript does not like it when you treat the `arguments` object as an array\n            // @ts-ignore type-mismatch\n            return win.removeEventListener.apply(win, arguments);\n        },\n        get closed() {\n            return win.closed;\n        },\n        get frames() {\n            return win.frames;\n        },\n        get length() {\n            return win.length;\n        },\n        get location() {\n            return win.location;\n        },\n        set location(value) {\n            win.location = value;\n        },\n        get opener() {\n            return win.opener;\n        },\n        get parent() {\n            return win.parent;\n        },\n        get self() {\n            return win.self;\n        },\n        get top() {\n            return win.top;\n        },\n        get window() {\n            return win.window;\n        },\n    }; // this is limited\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (detect$1()) {\n    apply$1();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst OriginalMutationObserver = MutationObserver;\nconst { disconnect: originalDisconnect, observe: originalObserve, takeRecords: originalTakeRecords, } = OriginalMutationObserver.prototype;\n// Internal fields to maintain relationships\nconst wrapperLookupField = '$$lwcObserverCallbackWrapper$$';\nconst observerLookupField = '$$lwcNodeObservers$$';\nconst observerToNodesMap = new WeakMap();\nfunction getNodeObservers(node) {\n    return node[observerLookupField];\n}\nfunction setNodeObservers(node, observers) {\n    node[observerLookupField] = observers;\n}\n/**\n * Retarget the mutation record's target value to its shadowRoot\n * @param {MutationRecord} originalRecord\n */\nfunction retargetMutationRecord(originalRecord) {\n    const { addedNodes, removedNodes, target, type } = originalRecord;\n    const retargetedRecord = create(MutationRecord.prototype);\n    defineProperties(retargetedRecord, {\n        addedNodes: {\n            get() {\n                return addedNodes;\n            },\n            enumerable: true,\n            configurable: true,\n        },\n        removedNodes: {\n            get() {\n                return removedNodes;\n            },\n            enumerable: true,\n            configurable: true,\n        },\n        type: {\n            get() {\n                return type;\n            },\n            enumerable: true,\n            configurable: true,\n        },\n        target: {\n            get() {\n                return target.shadowRoot;\n            },\n            enumerable: true,\n            configurable: true,\n        },\n    });\n    return retargetedRecord;\n}\n/**\n * Utility to identify if a target node is being observed by the given observer\n * Start at the current node, if the observer is registered to observe the current node, the mutation qualifies\n * @param {MutationObserver} observer\n * @param {Node} target\n */\nfunction isQualifiedObserver(observer, target) {\n    let parentNode = target;\n    while (!isNull(parentNode)) {\n        const parentNodeObservers = getNodeObservers(parentNode);\n        if (!isUndefined(parentNodeObservers) &&\n            (parentNodeObservers[0] === observer || // perf optimization to check for the first item is a match\n                ArrayIndexOf.call(parentNodeObservers, observer) !== -1)) {\n            return true;\n        }\n        parentNode = parentNode.parentNode;\n    }\n    return false;\n}\n/**\n * This function provides a shadow dom compliant filtered view of mutation records for a given observer.\n *\n * The key logic here is to determine if a given observer has been registered to observe any nodes\n * between the target node of a mutation record to the target's root node.\n * This function also retargets records when mutations occur directly under the shadow root\n * @param {MutationRecords[]} mutations\n * @param {MutationObserver} observer\n */\nfunction filterMutationRecords(mutations, observer) {\n    return ArrayReduce.call(mutations, (filteredSet, record) => {\n        const { target, addedNodes, removedNodes, type } = record;\n        // If target is an lwc host,\n        // Determine if the mutations affected the host or the shadowRoot\n        // Mutations affecting host: changes to slot content\n        // Mutations affecting shadowRoot: changes to template content\n        if (type === 'childList' && !isUndefined(getNodeKey(target))) {\n            // In case of added nodes, we can climb up the tree and determine eligibility\n            if (addedNodes.length > 0) {\n                // Optimization: Peek in and test one node to decide if the MutationRecord qualifies\n                // The remaining nodes in this MutationRecord will have the same ownerKey\n                const sampleNode = addedNodes[0];\n                if (isQualifiedObserver(observer, sampleNode)) {\n                    // If the target was being observed, then return record as-is\n                    // this will be the case for slot content\n                    const nodeObservers = getNodeObservers(target);\n                    if (nodeObservers &&\n                        (nodeObservers[0] === observer ||\n                            ArrayIndexOf.call(nodeObservers, observer) !== -1)) {\n                        ArrayPush.call(filteredSet, record);\n                    }\n                    else {\n                        // else, must be observing the shadowRoot\n                        ArrayPush.call(filteredSet, retargetMutationRecord(record));\n                    }\n                }\n            }\n            else {\n                // In the case of removed nodes, climbing the tree is not an option as the nodes are disconnected\n                // We can only check if either the host or shadow root was observed and qualify the record\n                const shadowRoot = target.shadowRoot;\n                const sampleNode = removedNodes[0];\n                if (getNodeNearestOwnerKey(target) === getNodeNearestOwnerKey(sampleNode) && // trickery: sampleNode is slot content\n                    isQualifiedObserver(observer, target) // use target as a close enough reference to climb up\n                ) {\n                    ArrayPush.call(filteredSet, record);\n                }\n                else if (shadowRoot) {\n                    const shadowRootObservers = getNodeObservers(shadowRoot);\n                    if (shadowRootObservers &&\n                        (shadowRootObservers[0] === observer ||\n                            ArrayIndexOf.call(shadowRootObservers, observer) !== -1)) {\n                        ArrayPush.call(filteredSet, retargetMutationRecord(record));\n                    }\n                }\n            }\n        }\n        else {\n            // Mutation happened under a root node(shadow root or document) and the decision is straighforward\n            // Ascend the tree starting from target and check if observer is qualified\n            if (isQualifiedObserver(observer, target)) {\n                ArrayPush.call(filteredSet, record);\n            }\n        }\n        return filteredSet;\n    }, []);\n}\nfunction getWrappedCallback(callback) {\n    let wrappedCallback = callback[wrapperLookupField];\n    if (isUndefined(wrappedCallback)) {\n        wrappedCallback = callback[wrapperLookupField] = (mutations, observer) => {\n            // Filter mutation records\n            const filteredRecords = filterMutationRecords(mutations, observer);\n            // If not records are eligible for the observer, do not invoke callback\n            if (filteredRecords.length === 0) {\n                return;\n            }\n            callback.call(observer, filteredRecords, observer);\n        };\n    }\n    return wrappedCallback;\n}\n/**\n * Patched MutationObserver constructor.\n * 1. Wrap the callback to filter out MutationRecords based on dom ownership\n * 2. Add a property field to track all observed targets of the observer instance\n * @param {MutationCallback} callback\n */\nfunction PatchedMutationObserver(callback) {\n    const wrappedCallback = getWrappedCallback(callback);\n    const observer = new OriginalMutationObserver(wrappedCallback);\n    return observer;\n}\nfunction patchedDisconnect() {\n    originalDisconnect.call(this);\n    // Clear the node to observer reference which is a strong references\n    const observedNodes = observerToNodesMap.get(this);\n    if (!isUndefined(observedNodes)) {\n        forEach.call(observedNodes, (observedNode) => {\n            const observers = observedNode[observerLookupField];\n            if (!isUndefined(observers)) {\n                const index = ArrayIndexOf.call(observers, this);\n                if (index !== -1) {\n                    ArraySplice.call(observers, index, 1);\n                }\n            }\n        });\n        observedNodes.length = 0;\n    }\n}\n/**\n * A single mutation observer can observe multiple nodes(target).\n * Maintain a list of all targets that the observer chooses to observe\n * @param {Node} target\n * @param {Object} options\n */\nfunction patchedObserve(target, options) {\n    let targetObservers = getNodeObservers(target);\n    // Maintain a list of all observers that want to observe a node\n    if (isUndefined(targetObservers)) {\n        targetObservers = [];\n        setNodeObservers(target, targetObservers);\n    }\n    // Same observer trying to observe the same node\n    if (ArrayIndexOf.call(targetObservers, this) === -1) {\n        ArrayPush.call(targetObservers, this);\n    } // else There is more bookkeeping to do here https://dom.spec.whatwg.org/#dom-mutationobserver-observe Step #7\n    // SyntheticShadowRoot instances are not actually a part of the DOM so observe the host instead.\n    if (isSyntheticShadowRoot(target)) {\n        target = target.host;\n    }\n    // maintain a list of all nodes observed by this observer\n    if (observerToNodesMap.has(this)) {\n        const observedNodes = observerToNodesMap.get(this);\n        if (ArrayIndexOf.call(observedNodes, target) === -1) {\n            ArrayPush.call(observedNodes, target);\n        }\n    }\n    else {\n        observerToNodesMap.set(this, [target]);\n    }\n    return originalObserve.call(this, target, options);\n}\n/**\n * Patch the takeRecords() api to filter MutationRecords based on the observed targets\n */\nfunction patchedTakeRecords() {\n    return filterMutationRecords(originalTakeRecords.call(this), this);\n}\nPatchedMutationObserver.prototype = OriginalMutationObserver.prototype;\nPatchedMutationObserver.prototype.disconnect = patchedDisconnect;\nPatchedMutationObserver.prototype.observe = patchedObserve;\nPatchedMutationObserver.prototype.takeRecords = patchedTakeRecords;\ndefineProperty(window, 'MutationObserver', {\n    value: PatchedMutationObserver,\n    configurable: true,\n    writable: true,\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction patchedAddEventListener$1(type, listener, optionsOrCapture) {\n    if (isSyntheticShadowHost(this)) {\n        // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n        return addCustomElementEventListener.apply(this, arguments);\n    }\n    if (arguments.length < 2) {\n        // Slow path, unlikely to be called frequently. We expect modern browsers to throw:\n        // https://googlechrome.github.io/samples/event-listeners-mandatory-arguments/\n        const args = ArraySlice.call(arguments);\n        if (args.length > 1) {\n            args[1] = getEventListenerWrapper(args[1]);\n        }\n        // Ignore types because we're passing through to native method\n        // @ts-ignore type-mismatch\n        return addEventListener.apply(this, args);\n    }\n    // Fast path. This function is optimized to avoid ArraySlice because addEventListener is called\n    // very frequently, and it provides a measurable perf boost to avoid so much array cloning.\n    const wrappedListener = getEventListenerWrapper(listener);\n    // The third argument is optional, so passing in `undefined` for `optionsOrCapture` gives capture=false\n    return addEventListener.call(this, type, wrappedListener, optionsOrCapture);\n}\nfunction patchedRemoveEventListener$1(_type, _listener, _optionsOrCapture) {\n    if (isSyntheticShadowHost(this)) {\n        // Typescript does not like it when you treat the `arguments` object as an array\n        // @ts-ignore type-mismatch\n        return removeCustomElementEventListener.apply(this, arguments);\n    }\n    const args = ArraySlice.call(arguments);\n    if (arguments.length > 1) {\n        args[1] = getEventListenerWrapper(args[1]);\n    }\n    // Ignore types because we're passing through to native method\n    // @ts-ignore type-mismatch\n    removeEventListener.apply(this, args);\n    // Account for listeners that were added before this polyfill was applied\n    // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n    removeEventListener.apply(this, arguments);\n}\ndefineProperties(eventTargetPrototype, {\n    addEventListener: {\n        value: patchedAddEventListener$1,\n        enumerable: true,\n        writable: true,\n        configurable: true,\n    },\n    removeEventListener: {\n        value: patchedRemoveEventListener$1,\n        enumerable: true,\n        writable: true,\n        configurable: true,\n    },\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect() {\n    return typeof EventTarget === 'undefined';\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction patchedAddEventListener(_type, _listener, _options) {\n    if (arguments.length > 1) {\n        const args = ArraySlice.call(arguments);\n        args[1] = getEventListenerWrapper(args[1]);\n        // Ignore types because we're passing through to native method\n        // @ts-ignore type-mismatch\n        return windowAddEventListener.apply(this, args);\n    }\n    // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n    return windowAddEventListener.apply(this, arguments);\n}\nfunction patchedRemoveEventListener(_type, _listener, _options) {\n    if (arguments.length > 1) {\n        const args = ArraySlice.call(arguments);\n        args[1] = getEventListenerWrapper(args[1]);\n        // Ignore types because we're passing through to native method\n        // @ts-ignore type-mismatch\n        windowRemoveEventListener.apply(this, args);\n    }\n    // Account for listeners that were added before this polyfill was applied\n    // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n    windowRemoveEventListener.apply(this, arguments);\n}\nfunction apply() {\n    defineProperties(Window.prototype, {\n        addEventListener: {\n            value: patchedAddEventListener,\n            enumerable: true,\n            writable: true,\n            configurable: true,\n        },\n        removeEventListener: {\n            value: patchedRemoveEventListener,\n            enumerable: true,\n            writable: true,\n            configurable: true,\n        },\n    });\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (detect()) {\n    apply();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction patchedCurrentTargetGetter() {\n    const currentTarget = eventCurrentTargetGetter.call(this);\n    if (isNull(currentTarget)) {\n        return null;\n    }\n    if (eventToContextMap.get(this) === 1 /* EventListenerContext.SHADOW_ROOT_LISTENER */) {\n        return getShadowRoot(currentTarget);\n    }\n    return currentTarget;\n}\nfunction patchedTargetGetter() {\n    const originalTarget = eventTargetGetter.call(this);\n    if (!(originalTarget instanceof _Node)) {\n        return originalTarget;\n    }\n    const doc = getOwnerDocument(originalTarget);\n    const composedPath = pathComposer(originalTarget, this.composed);\n    const originalCurrentTarget = eventCurrentTargetGetter.call(this);\n    // Handle cases where the currentTarget is null (for async events), and when an event has been\n    // added to Window\n    if (!(originalCurrentTarget instanceof _Node)) {\n        // TODO [#1511]: Special escape hatch to support legacy behavior. Should be fixed.\n        // If the event's target is being accessed async and originalTarget is not a keyed element, do not retarget\n        if (isNull(originalCurrentTarget) && isUndefined(getNodeOwnerKey(originalTarget))) {\n            return originalTarget;\n        }\n        return retarget(doc, composedPath);\n    }\n    else if (originalCurrentTarget === doc || originalCurrentTarget === doc.body) {\n        // TODO [#1530]: If currentTarget is document or document.body (Third party libraries that have global event listeners)\n        // and the originalTarget is not a keyed element, do not retarget\n        if (isUndefined(getNodeOwnerKey(originalTarget))) {\n            return originalTarget;\n        }\n        return retarget(doc, composedPath);\n    }\n    let actualCurrentTarget = originalCurrentTarget;\n    let actualPath = composedPath;\n    // Address the possibility that `currentTarget` is a shadow root\n    if (isSyntheticShadowHost(originalCurrentTarget)) {\n        const context = eventToContextMap.get(this);\n        if (context === 1 /* EventListenerContext.SHADOW_ROOT_LISTENER */) {\n            actualCurrentTarget = getShadowRoot(originalCurrentTarget);\n        }\n    }\n    // Address the possibility that `target` is a shadow root\n    if (isSyntheticShadowHost(originalTarget) && eventToShadowRootMap.has(this)) {\n        actualPath = pathComposer(getShadowRoot(originalTarget), this.composed);\n    }\n    return retarget(actualCurrentTarget, actualPath);\n}\nfunction patchedComposedPathValue() {\n    const originalTarget = eventTargetGetter.call(this);\n    // Account for events with targets that are not instances of Node (e.g., when a readystatechange\n    // handler is listening on an instance of XMLHttpRequest).\n    if (!(originalTarget instanceof _Node)) {\n        return [];\n    }\n    // If the original target is inside a native shadow root, then just call the native\n    // composePath() method. The event is already retargeted and this causes our composedPath()\n    // polyfill to compute the wrong value. This is only an issue when you have a native web\n    // component inside an LWC component (see test in same commit) but this scenario is unlikely\n    // because we don't yet support that. Workaround specifically for W-9846457. Mixed mode solution\n    // will likely be more involved.\n    const hasShadowRoot = Boolean(originalTarget.shadowRoot);\n    const hasSyntheticShadowRootAttached = hasInternalSlot(originalTarget);\n    if (hasShadowRoot && !hasSyntheticShadowRootAttached) {\n        return composedPath.call(this);\n    }\n    const originalCurrentTarget = eventCurrentTargetGetter.call(this);\n    // If the event has completed propagation, the composedPath should be an empty array.\n    if (isNull(originalCurrentTarget)) {\n        return [];\n    }\n    // Address the possibility that `target` is a shadow root\n    let actualTarget = originalTarget;\n    if (isSyntheticShadowHost(originalTarget) && eventToShadowRootMap.has(this)) {\n        actualTarget = getShadowRoot(originalTarget);\n    }\n    return pathComposer(actualTarget, this.composed);\n}\ndefineProperties(Event.prototype, {\n    target: {\n        get: patchedTargetGetter,\n        enumerable: true,\n        configurable: true,\n    },\n    currentTarget: {\n        get: patchedCurrentTargetGetter,\n        enumerable: true,\n        configurable: true,\n    },\n    composedPath: {\n        value: patchedComposedPathValue,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    },\n    // Non-standard but widely supported for backwards-compatibility\n    srcElement: {\n        get: patchedTargetGetter,\n        enumerable: true,\n        configurable: true,\n    },\n    // Non-standard but implemented in Chrome and continues to exist for backwards-compatibility\n    // https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/dom/events/event.idl;l=58?q=event.idl&ss=chromium\n    path: {\n        get: patchedComposedPathValue,\n        enumerable: true,\n        configurable: true,\n    },\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction retargetRelatedTarget(Ctor) {\n    const relatedTargetGetter = getOwnPropertyDescriptor(Ctor.prototype, 'relatedTarget')\n        .get;\n    defineProperty(Ctor.prototype, 'relatedTarget', {\n        get() {\n            const relatedTarget = relatedTargetGetter.call(this);\n            if (isNull(relatedTarget)) {\n                return null;\n            }\n            if (!(relatedTarget instanceof _Node) || !isNodeShadowed(relatedTarget)) {\n                return relatedTarget;\n            }\n            let pointOfReference = eventCurrentTargetGetter.call(this);\n            if (isNull(pointOfReference)) {\n                pointOfReference = getOwnerDocument(relatedTarget);\n            }\n            return retarget(pointOfReference, pathComposer(relatedTarget, true));\n        },\n        enumerable: true,\n        configurable: true,\n    });\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nretargetRelatedTarget(FocusEvent);\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nretargetRelatedTarget(MouseEvent);\n\n/*\n * Copyright (c) 2021, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst assignedSlotGetter = hasOwnProperty.call(Text.prototype, 'assignedSlot')\n    ? getOwnPropertyDescriptor(Text.prototype, 'assignedSlot').get\n    : () => null;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// We can use a single observer without having to worry about leaking because\n// \"Registered observers in a node’s registered observer list have a weak\n// reference to the node.\"\n// https://dom.spec.whatwg.org/#garbage-collection\nlet observer;\nconst observerConfig = { childList: true };\nconst SlotChangeKey = new WeakMap();\nfunction initSlotObserver() {\n    return new MO((mutations) => {\n        const slots = [];\n        forEach.call(mutations, (mutation) => {\n            if (process.env.NODE_ENV !== 'production') {\n                assert.invariant(mutation.type === 'childList', `Invalid mutation type: ${mutation.type}. This mutation handler for slots should only handle \"childList\" mutations.`);\n            }\n            const { target: slot } = mutation;\n            if (ArrayIndexOf.call(slots, slot) === -1) {\n                ArrayPush.call(slots, slot);\n                dispatchEvent.call(slot, new CustomEvent('slotchange'));\n            }\n        });\n    });\n}\nfunction getFilteredSlotFlattenNodes(slot) {\n    const childNodes = arrayFromCollection(childNodesGetter.call(slot));\n    // Typescript is inferring the wrong function type for this particular\n    // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972\n    // @ts-ignore type-mismatch\n    return ArrayReduce.call(childNodes, (seed, child) => {\n        if (child instanceof Element && isSlotElement(child)) {\n            ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));\n        }\n        else {\n            ArrayPush.call(seed, child);\n        }\n        return seed;\n    }, []);\n}\nfunction assignedSlotGetterPatched() {\n    const parentNode = parentNodeGetter.call(this);\n    // use original assignedSlot if parent has a native shdow root\n    if (parentNode instanceof Element) {\n        const sr = shadowRootGetter.call(parentNode);\n        if (isInstanceOfNativeShadowRoot(sr)) {\n            if (this instanceof Text) {\n                return assignedSlotGetter.call(this);\n            }\n            return assignedSlotGetter$1.call(this);\n        }\n    }\n    /**\n     * The node is assigned to a slot if:\n     *  - it has a parent and its parent is a slot element\n     *  - and if the slot owner key is different than the node owner key.\n     *\n     * When the slot and the slotted node are 2 different shadow trees, the owner keys will be\n     * different. When the slot is in a shadow tree and the slotted content is a light DOM node,\n     * the light DOM node doesn't have an owner key and therefor the slot owner key will be\n     * different than the node owner key (always `undefined`).\n     */\n    if (!isNull(parentNode) &&\n        isSlotElement(parentNode) &&\n        getNodeOwnerKey(parentNode) !== getNodeOwnerKey(this)) {\n        return parentNode;\n    }\n    return null;\n}\ndefineProperties(HTMLSlotElement.prototype, {\n    addEventListener: {\n        value(type, listener, options) {\n            // super.addEventListener - but that doesn't work with typescript\n            HTMLElement.prototype.addEventListener.call(this, type, listener, options);\n            if (type === 'slotchange' && !SlotChangeKey.get(this)) {\n                SlotChangeKey.set(this, true);\n                if (!observer) {\n                    observer = initSlotObserver();\n                }\n                MutationObserverObserve.call(observer, this, observerConfig);\n            }\n        },\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    },\n    assignedElements: {\n        value(options) {\n            if (isNodeShadowed(this)) {\n                const flatten = !isUndefined(options) && isTrue(options.flatten);\n                const nodes = flatten\n                    ? getFilteredSlotFlattenNodes(this)\n                    : getFilteredSlotAssignedNodes(this);\n                return ArrayFilter.call(nodes, (node) => node instanceof Element);\n            }\n            else {\n                return assignedElements.apply(this, ArraySlice.call(arguments));\n            }\n        },\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    },\n    assignedNodes: {\n        value(options) {\n            if (isNodeShadowed(this)) {\n                const flatten = !isUndefined(options) && isTrue(options.flatten);\n                return flatten\n                    ? getFilteredSlotFlattenNodes(this)\n                    : getFilteredSlotAssignedNodes(this);\n            }\n            else {\n                return assignedNodes.apply(this, ArraySlice.call(arguments));\n            }\n        },\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    },\n    name: {\n        get() {\n            const name = getAttribute.call(this, 'name');\n            return isNull(name) ? '' : name;\n        },\n        set(value) {\n            setAttribute.call(this, 'name', value);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    childNodes: {\n        get() {\n            if (isNodeShadowed(this)) {\n                const owner = getNodeOwner(this);\n                const childNodes = isNull(owner)\n                    ? []\n                    : getAllMatches(owner, getFilteredChildNodes(this));\n                return createStaticNodeList(childNodes);\n            }\n            return childNodesGetter.call(this);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Non-deep-traversing patches: this descriptor map includes all descriptors that\n// do not five access to nodes beyond the immediate children.\ndefineProperties(Text.prototype, {\n    assignedSlot: {\n        get: assignedSlotGetterPatched,\n        enumerable: true,\n        configurable: true,\n    },\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This methods filters out elements that are not in the same shadow root of context.\n * It does not enforce shadow dom semantics if $context is not managed by LWC\n */\nfunction getNonPatchedFilteredArrayOfNodes(context, unfilteredNodes) {\n    let filtered;\n    const ownerKey = getNodeOwnerKey(context);\n    // a node inside a shadow.\n    if (!isUndefined(ownerKey)) {\n        if (isSyntheticShadowHost(context)) {\n            // element with shadowRoot attached\n            const owner = getNodeOwner(context);\n            if (isNull(owner)) {\n                filtered = [];\n            }\n            else if (getNodeKey(context)) {\n                // it is a custom element, and we should then filter by slotted elements\n                filtered = getAllSlottedMatches(context, unfilteredNodes);\n            }\n            else {\n                // regular element, we should then filter by ownership\n                filtered = getAllMatches(owner, unfilteredNodes);\n            }\n        }\n        else {\n            // context is handled by lwc, using getNodeNearestOwnerKey to include manually inserted elements in the same shadow.\n            filtered = ArrayFilter.call(unfilteredNodes, (elm) => getNodeNearestOwnerKey(elm) === ownerKey);\n        }\n    }\n    else if (context instanceof HTMLBodyElement) {\n        // `context` is document.body which is already patched.\n        filtered = ArrayFilter.call(unfilteredNodes, \n        // Note: we deviate from native shadow here, but are not fixing\n        // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n        (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));\n    }\n    else {\n        // `context` is outside the lwc boundary, return unfiltered list.\n        filtered = ArraySlice.call(unfilteredNodes);\n    }\n    return filtered;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction innerHTMLGetterPatched() {\n    const childNodes = getInternalChildNodes(this);\n    let innerHTML = '';\n    for (let i = 0, len = childNodes.length; i < len; i += 1) {\n        innerHTML += getOuterHTML(childNodes[i]);\n    }\n    return innerHTML;\n}\nfunction outerHTMLGetterPatched() {\n    return getOuterHTML(this);\n}\nfunction attachShadowPatched(options) {\n    // To retain native behavior of the API, provide synthetic shadowRoot only when specified\n    if (options[KEY__SYNTHETIC_MODE]) {\n        return attachShadow(this, options);\n    }\n    return attachShadow$1.call(this, options);\n}\nfunction shadowRootGetterPatched() {\n    if (isSyntheticShadowHost(this)) {\n        const shadow = getShadowRoot(this);\n        if (shadow.mode === 'open') {\n            return shadow;\n        }\n    }\n    return shadowRootGetter.call(this);\n}\nfunction childrenGetterPatched() {\n    const owner = getNodeOwner(this);\n    const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));\n    return createStaticHTMLCollection(ArrayFilter.call(childNodes, (node) => node instanceof Element));\n}\nfunction childElementCountGetterPatched() {\n    return this.children.length;\n}\nfunction firstElementChildGetterPatched() {\n    return this.children[0] || null;\n}\nfunction lastElementChildGetterPatched() {\n    const { children } = this;\n    return children.item(children.length - 1) || null;\n}\n// Non-deep-traversing patches: this descriptor map includes all descriptors that\n// do not five access to nodes beyond the immediate children.\ndefineProperties(Element.prototype, {\n    innerHTML: {\n        get() {\n            // Note: we deviate from native shadow here, but are not fixing\n            // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n            if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {\n                return innerHTMLGetterPatched.call(this);\n            }\n            return innerHTMLGetter.call(this);\n        },\n        set(v) {\n            innerHTMLSetter.call(this, v);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    outerHTML: {\n        get() {\n            // Note: we deviate from native shadow here, but are not fixing\n            // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n            if (isNodeShadowed(this) || isSyntheticShadowHost(this)) {\n                return outerHTMLGetterPatched.call(this);\n            }\n            return outerHTMLGetter.call(this);\n        },\n        set(v) {\n            outerHTMLSetter.call(this, v);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    attachShadow: {\n        value: attachShadowPatched,\n        enumerable: true,\n        writable: true,\n        configurable: true,\n    },\n    shadowRoot: {\n        get: shadowRootGetterPatched,\n        enumerable: true,\n        configurable: true,\n    },\n    // patched in HTMLElement if exists (IE11 is the one off here)\n    children: {\n        get() {\n            if (hasMountedChildren(this)) {\n                return childrenGetterPatched.call(this);\n            }\n            return childrenGetter.call(this);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    childElementCount: {\n        get() {\n            if (hasMountedChildren(this)) {\n                return childElementCountGetterPatched.call(this);\n            }\n            return childElementCountGetter.call(this);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    firstElementChild: {\n        get() {\n            if (hasMountedChildren(this)) {\n                return firstElementChildGetterPatched.call(this);\n            }\n            return firstElementChildGetter.call(this);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    lastElementChild: {\n        get() {\n            if (hasMountedChildren(this)) {\n                return lastElementChildGetterPatched.call(this);\n            }\n            return lastElementChildGetter.call(this);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    assignedSlot: {\n        get: assignedSlotGetterPatched,\n        enumerable: true,\n        configurable: true,\n    },\n});\n// IE11 extra patches for wrong prototypes\nif (hasOwnProperty.call(HTMLElement.prototype, 'innerHTML')) {\n    defineProperty(HTMLElement.prototype, 'innerHTML', getOwnPropertyDescriptor(Element.prototype, 'innerHTML'));\n}\nif (hasOwnProperty.call(HTMLElement.prototype, 'outerHTML')) {\n    defineProperty(HTMLElement.prototype, 'outerHTML', getOwnPropertyDescriptor(Element.prototype, 'outerHTML'));\n}\nif (hasOwnProperty.call(HTMLElement.prototype, 'children')) {\n    defineProperty(HTMLElement.prototype, 'children', getOwnPropertyDescriptor(Element.prototype, 'children'));\n}\n// Deep-traversing patches from this point on:\nfunction querySelectorPatched() {\n    const nodeList = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));\n    if (isSyntheticShadowHost(this)) {\n        // element with shadowRoot attached\n        const owner = getNodeOwner(this);\n        if (!isUndefined(getNodeKey(this))) {\n            // it is a custom element, and we should then filter by slotted elements\n            return getFirstSlottedMatch(this, nodeList);\n        }\n        else if (isNull(owner)) {\n            return null;\n        }\n        else {\n            // regular element, we should then filter by ownership\n            return getFirstMatch(owner, nodeList);\n        }\n    }\n    else if (isNodeShadowed(this)) {\n        // element inside a shadowRoot\n        const ownerKey = getNodeOwnerKey(this);\n        if (!isUndefined(ownerKey)) {\n            // `this` is handled by lwc, using getNodeNearestOwnerKey to include manually inserted elements in the same shadow.\n            const elm = ArrayFind.call(nodeList, (elm) => getNodeNearestOwnerKey(elm) === ownerKey);\n            return isUndefined(elm) ? null : elm;\n        }\n        else {\n            // Note: we deviate from native shadow here, but are not fixing\n            // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n            // `this` is a manually inserted element inside a shadowRoot, return the first element.\n            return nodeList.length === 0 ? null : nodeList[0];\n        }\n    }\n    else {\n        if (!(this instanceof HTMLBodyElement)) {\n            const elm = nodeList[0];\n            return isUndefined(elm) ? null : elm;\n        }\n        // element belonging to the document\n        const elm = ArrayFind.call(nodeList, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(this));\n        return isUndefined(elm) ? null : elm;\n    }\n}\nfunction getFilteredArrayOfNodes(context, unfilteredNodes) {\n    let filtered;\n    if (isSyntheticShadowHost(context)) {\n        // element with shadowRoot attached\n        const owner = getNodeOwner(context);\n        if (!isUndefined(getNodeKey(context))) {\n            // it is a custom element, and we should then filter by slotted elements\n            filtered = getAllSlottedMatches(context, unfilteredNodes);\n        }\n        else if (isNull(owner)) {\n            filtered = [];\n        }\n        else {\n            // regular element, we should then filter by ownership\n            filtered = getAllMatches(owner, unfilteredNodes);\n        }\n    }\n    else if (isNodeShadowed(context)) {\n        // element inside a shadowRoot\n        const ownerKey = getNodeOwnerKey(context);\n        if (!isUndefined(ownerKey)) {\n            // context is handled by lwc, using getNodeNearestOwnerKey to include manually inserted elements in the same shadow.\n            filtered = ArrayFilter.call(unfilteredNodes, (elm) => getNodeNearestOwnerKey(elm) === ownerKey);\n        }\n        else {\n            // Note: we deviate from native shadow here, but are not fixing\n            // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n            // context is manually inserted without lwc:dom-manual, return everything\n            filtered = ArraySlice.call(unfilteredNodes);\n        }\n    }\n    else {\n        if (context instanceof HTMLBodyElement) {\n            // `context` is document.body or element belonging to the document with the patch enabled\n            filtered = ArrayFilter.call(unfilteredNodes, (elm) => isUndefined(getNodeOwnerKey(elm)) || isGlobalPatchingSkipped(context));\n        }\n        else {\n            // `context` is outside the lwc boundary and patch is not enabled.\n            filtered = ArraySlice.call(unfilteredNodes);\n        }\n    }\n    return filtered;\n}\n// The following patched methods hide shadowed elements from global\n// traversing mechanisms. They are simplified for performance reasons to\n// filter by ownership and do not account for slotted elements. This\n// compromise is fine for our synthetic shadow dom because root elements\n// cannot have slotted elements.\n// Another compromise here is that all these traversing methods will return\n// static HTMLCollection or static NodeList. We decided that this compromise\n// is not a big problem considering the amount of code that is relying on\n// the liveliness of these results are rare.\ndefineProperties(Element.prototype, {\n    querySelector: {\n        value: querySelectorPatched,\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    },\n    querySelectorAll: {\n        value() {\n            const nodeList = arrayFromCollection(querySelectorAll$1.apply(this, ArraySlice.call(arguments)));\n            // Note: we deviate from native shadow here, but are not fixing\n            // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n            const filteredResults = getFilteredArrayOfNodes(this, nodeList);\n            return createStaticNodeList(filteredResults);\n        },\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    },\n});\n// The following APIs are used directly by Jest internally so we avoid patching them during testing.\nif (process.env.NODE_ENV !== 'test') {\n    defineProperties(Element.prototype, {\n        getElementsByClassName: {\n            value() {\n                const elements = arrayFromCollection(getElementsByClassName$1.apply(this, ArraySlice.call(arguments)));\n                // Note: we deviate from native shadow here, but are not fixing\n                // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n                return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));\n            },\n            writable: true,\n            enumerable: true,\n            configurable: true,\n        },\n        getElementsByTagName: {\n            value() {\n                const elements = arrayFromCollection(getElementsByTagName$1.apply(this, ArraySlice.call(arguments)));\n                // Note: we deviate from native shadow here, but are not fixing\n                // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n                return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));\n            },\n            writable: true,\n            enumerable: true,\n            configurable: true,\n        },\n        getElementsByTagNameNS: {\n            value() {\n                const elements = arrayFromCollection(getElementsByTagNameNS$1.apply(this, ArraySlice.call(arguments)));\n                // Note: we deviate from native shadow here, but are not fixing\n                // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n                return createStaticHTMLCollection(getNonPatchedFilteredArrayOfNodes(this, elements));\n            },\n            writable: true,\n            enumerable: true,\n            configurable: true,\n        },\n    });\n}\n// IE11 extra patches for wrong prototypes\nif (hasOwnProperty.call(HTMLElement.prototype, 'getElementsByClassName')) {\n    defineProperty(HTMLElement.prototype, 'getElementsByClassName', getOwnPropertyDescriptor(Element.prototype, 'getElementsByClassName'));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst FocusableSelector = `\n    [contenteditable],\n    [tabindex],\n    a[href],\n    area[href],\n    audio[controls],\n    button,\n    iframe,\n    input,\n    select,\n    textarea,\n    video[controls]\n`;\nconst formElementTagNames = new Set(['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA']);\nfunction filterSequentiallyFocusableElements(elements) {\n    return elements.filter((element) => {\n        if (hasAttribute.call(element, 'tabindex')) {\n            // Even though LWC only supports tabindex values of 0 or -1,\n            // passing through elements with tabindex=\"0\" is a tighter criteria\n            // than filtering out elements based on tabindex=\"-1\".\n            return getAttribute.call(element, 'tabindex') === '0';\n        }\n        if (formElementTagNames.has(tagNameGetter.call(element))) {\n            return !hasAttribute.call(element, 'disabled');\n        }\n        return true;\n    });\n}\nconst DidAddMouseEventListeners = new WeakMap();\n// Due to browser differences, it is impossible to know what is focusable until\n// we actually try to focus it. We need to refactor our focus delegation logic\n// to verify whether or not the target was actually focused instead of trying\n// to predict focusability like we do here.\nfunction isVisible(element) {\n    const { width, height } = getBoundingClientRect.call(element);\n    const noZeroSize = width > 0 || height > 0;\n    // The area element can be 0x0 and focusable. Hardcoding this is not ideal\n    // but it will minimize changes in the current behavior.\n    const isAreaElement = element.tagName === 'AREA';\n    return (noZeroSize || isAreaElement) && getComputedStyle(element).visibility !== 'hidden';\n}\n// This function based on https://allyjs.io/data-tables/focusable.html\n// It won't catch everything, but should be good enough\n// There are a lot of edge cases here that we can't realistically handle\n// Determines if a particular element is tabbable, as opposed to simply focusable\nfunction isTabbable(element) {\n    if (isSyntheticShadowHost(element) && isDelegatingFocus(element)) {\n        return false;\n    }\n    return matches.call(element, FocusableSelector) && isVisible(element);\n}\nfunction hostElementFocus() {\n    const _rootNode = this.getRootNode();\n    if (_rootNode === this) {\n        // We invoke the focus() method even if the host is disconnected in order to eliminate\n        // observable differences for component authors between synthetic and native.\n        const focusable = querySelector.call(this, FocusableSelector);\n        if (!isNull(focusable)) {\n            // @ts-ignore type-mismatch\n            focusable.focus.apply(focusable, arguments);\n        }\n        return;\n    }\n    // If the root node is not the host element then it's either the document or a shadow root.\n    const rootNode = _rootNode;\n    if (rootNode.activeElement === this) {\n        // The focused element should not change if the focus method is invoked\n        // on the shadow-including ancestor of the currently focused element.\n        return;\n    }\n    const focusables = arrayFromCollection(querySelectorAll$1.call(this, FocusableSelector));\n    let didFocus = false;\n    while (!didFocus && focusables.length !== 0) {\n        const focusable = focusables.shift();\n        // @ts-ignore type-mismatch\n        focusable.focus.apply(focusable, arguments);\n        // Get the root node of the current focusable in case it was slotted.\n        const currentRootNode = focusable.getRootNode();\n        didFocus = currentRootNode.activeElement === focusable;\n    }\n}\nfunction getTabbableSegments(host) {\n    const doc = getOwnerDocument(host);\n    const all = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll.call(doc, FocusableSelector)));\n    const inner = filterSequentiallyFocusableElements(arrayFromCollection(querySelectorAll$1.call(host, FocusableSelector)));\n    if (process.env.NODE_ENV !== 'production') {\n        assert.invariant(getAttribute.call(host, 'tabindex') === '-1' || isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);\n    }\n    const firstChild = inner[0];\n    const lastChild = inner[inner.length - 1];\n    const hostIndex = ArrayIndexOf.call(all, host);\n    // Host element can show up in our \"previous\" section if its tabindex is 0\n    // We want to filter that out here\n    const firstChildIndex = hostIndex > -1 ? hostIndex : ArrayIndexOf.call(all, firstChild);\n    // Account for an empty inner list\n    const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : ArrayIndexOf.call(all, lastChild) + 1;\n    const prev = ArraySlice.call(all, 0, firstChildIndex);\n    const next = ArraySlice.call(all, lastChildIndex);\n    return {\n        prev,\n        inner,\n        next,\n    };\n}\nfunction getActiveElement(host) {\n    const doc = getOwnerDocument(host);\n    const activeElement = DocumentPrototypeActiveElement.call(doc);\n    if (isNull(activeElement)) {\n        return activeElement;\n    }\n    // activeElement must be child of the host and owned by it\n    return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !==\n        0\n        ? activeElement\n        : null;\n}\nfunction relatedTargetPosition(host, relatedTarget) {\n    // assert: target must be child of host\n    const pos = compareDocumentPosition.call(host, relatedTarget);\n    if (pos & DOCUMENT_POSITION_CONTAINED_BY) {\n        // focus remains inside the host\n        return 0;\n    }\n    else if (pos & DOCUMENT_POSITION_PRECEDING) {\n        // focus is coming from above\n        return 1;\n    }\n    else if (pos & DOCUMENT_POSITION_FOLLOWING) {\n        // focus is coming from below\n        return 2;\n    }\n    // we don't know what's going on.\n    return -1;\n}\nfunction muteEvent(event) {\n    event.preventDefault();\n    event.stopPropagation();\n}\nfunction muteFocusEventsDuringExecution(win, func) {\n    windowAddEventListener.call(win, 'focusin', muteEvent, true);\n    windowAddEventListener.call(win, 'focusout', muteEvent, true);\n    func();\n    windowRemoveEventListener.call(win, 'focusin', muteEvent, true);\n    windowRemoveEventListener.call(win, 'focusout', muteEvent, true);\n}\nfunction focusOnNextOrBlur(segment, target, relatedTarget) {\n    const win = getOwnerWindow(relatedTarget);\n    const next = getNextTabbable(segment, relatedTarget);\n    if (isNull(next)) {\n        // nothing to focus on, blur to invalidate the operation\n        muteFocusEventsDuringExecution(win, () => {\n            target.blur();\n        });\n    }\n    else {\n        muteFocusEventsDuringExecution(win, () => {\n            next.focus();\n        });\n    }\n}\nlet letBrowserHandleFocus = false;\nfunction disableKeyboardFocusNavigationRoutines() {\n    letBrowserHandleFocus = true;\n}\nfunction enableKeyboardFocusNavigationRoutines() {\n    letBrowserHandleFocus = false;\n}\nfunction isKeyboardFocusNavigationRoutineEnabled() {\n    return !letBrowserHandleFocus;\n}\nfunction skipHostHandler(event) {\n    if (letBrowserHandleFocus) {\n        return;\n    }\n    const host = eventCurrentTargetGetter.call(event);\n    const target = eventTargetGetter.call(event);\n    // If the host delegating focus with tabindex=0 is not the target, we know\n    // that the event was dispatched on a descendant node of the host. This\n    // means the focus is coming from below and we don't need to do anything.\n    if (host !== target) {\n        // Focus is coming from above\n        return;\n    }\n    const relatedTarget = focusEventRelatedTargetGetter.call(event);\n    if (isNull(relatedTarget)) {\n        // If relatedTarget is null, the user is most likely tabbing into the document from the\n        // browser chrome. We could probably deduce whether focus is coming in from the top or the\n        // bottom by comparing the position of the target to all tabbable elements. This is an edge\n        // case and only comes up if the custom element is the first or last tabbable element in the\n        // document.\n        return;\n    }\n    const segments = getTabbableSegments(host);\n    const position = relatedTargetPosition(host, relatedTarget);\n    if (position === 1) {\n        // Focus is coming from above\n        const findTabbableElms = isTabbableFrom.bind(null, host.getRootNode());\n        const first = ArrayFind.call(segments.inner, findTabbableElms);\n        if (!isUndefined(first)) {\n            const win = getOwnerWindow(first);\n            muteFocusEventsDuringExecution(win, () => {\n                first.focus();\n            });\n        }\n        else {\n            focusOnNextOrBlur(segments.next, target, relatedTarget);\n        }\n    }\n    else if (host === target) {\n        // Host is receiving focus from below, either from its shadow or from a sibling\n        focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);\n    }\n}\nfunction skipShadowHandler(event) {\n    if (letBrowserHandleFocus) {\n        return;\n    }\n    const relatedTarget = focusEventRelatedTargetGetter.call(event);\n    if (isNull(relatedTarget)) {\n        // If relatedTarget is null, the user is most likely tabbing into the document from the\n        // browser chrome. We could probably deduce whether focus is coming in from the top or the\n        // bottom by comparing the position of the target to all tabbable elements. This is an edge\n        // case and only comes up if the custom element is the first or last tabbable element in the\n        // document.\n        return;\n    }\n    const host = eventCurrentTargetGetter.call(event);\n    const segments = getTabbableSegments(host);\n    if (ArrayIndexOf.call(segments.inner, relatedTarget) !== -1) {\n        // If relatedTarget is contained by the host's subtree we can assume that the user is\n        // tabbing between elements inside of the shadow. Do nothing.\n        return;\n    }\n    const target = eventTargetGetter.call(event);\n    // Determine where the focus is coming from (Tab or Shift+Tab)\n    const position = relatedTargetPosition(host, relatedTarget);\n    if (position === 1) {\n        // Focus is coming from above\n        focusOnNextOrBlur(segments.next, target, relatedTarget);\n    }\n    if (position === 2) {\n        // Focus is coming from below\n        focusOnNextOrBlur(ArrayReverse.call(segments.prev), target, relatedTarget);\n    }\n}\n// Use this function to determine whether you can start from one root and end up\n// at another element via tabbing.\nfunction isTabbableFrom(fromRoot, toElm) {\n    if (!isTabbable(toElm)) {\n        return false;\n    }\n    const ownerDocument = getOwnerDocument(toElm);\n    let root = toElm.getRootNode();\n    while (root !== ownerDocument && root !== fromRoot) {\n        const sr = root;\n        const host = sr.host;\n        if (getAttribute.call(host, 'tabindex') === '-1') {\n            return false;\n        }\n        root = host && host.getRootNode();\n    }\n    return true;\n}\nfunction getNextTabbable(tabbables, relatedTarget) {\n    const len = tabbables.length;\n    if (len > 0) {\n        for (let i = 0; i < len; i += 1) {\n            const next = tabbables[i];\n            if (isTabbableFrom(relatedTarget.getRootNode(), next)) {\n                return next;\n            }\n        }\n    }\n    return null;\n}\n// Skips the host element\nfunction handleFocus(elm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.invariant(isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${toString(elm)}. ${toString(elm)} should have delegates focus true, but is not delegating focus`);\n    }\n    bindDocumentMousedownMouseupHandlers(elm);\n    // Unbind any focusin listeners we may have going on\n    ignoreFocusIn(elm);\n    addEventListener.call(elm, 'focusin', skipHostHandler, true);\n}\nfunction ignoreFocus(elm) {\n    removeEventListener.call(elm, 'focusin', skipHostHandler, true);\n}\nfunction bindDocumentMousedownMouseupHandlers(elm) {\n    const ownerDocument = getOwnerDocument(elm);\n    if (!DidAddMouseEventListeners.get(ownerDocument)) {\n        DidAddMouseEventListeners.set(ownerDocument, true);\n        addEventListener.call(ownerDocument, 'mousedown', disableKeyboardFocusNavigationRoutines, true);\n        addEventListener.call(ownerDocument, 'mouseup', () => {\n            // We schedule this as an async task in the mouseup handler (as\n            // opposed to the mousedown handler) because we want to guarantee\n            // that it will never run before the focusin handler:\n            //\n            // Click form element   | Click form element label\n            // ==================================================\n            // mousedown            | mousedown\n            // FOCUSIN              | mousedown-setTimeout\n            // mousedown-setTimeout | mouseup\n            // mouseup              | FOCUSIN\n            // mouseup-setTimeout   | mouseup-setTimeout\n            setTimeout(enableKeyboardFocusNavigationRoutines);\n        }, true);\n        // [W-7824445] If the element is draggable, the mousedown event is dispatched before the\n        // element is starting to be dragged, which disable the keyboard focus navigation routine.\n        // But by specification, the mouseup event is never dispatched once the element is dropped.\n        //\n        // For all draggable element, we need to add an event listener to re-enable the keyboard\n        // navigation routine after dragging starts.\n        addEventListener.call(ownerDocument, 'dragstart', enableKeyboardFocusNavigationRoutines, true);\n    }\n}\n// Skips the shadow tree\nfunction handleFocusIn(elm) {\n    if (process.env.NODE_ENV !== 'production') {\n        assert.invariant(tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${toString(elm)}. ${toString(elm)} should have tabIndex -1, but has tabIndex ${tabIndexGetter.call(elm)}`);\n    }\n    bindDocumentMousedownMouseupHandlers(elm);\n    // Unbind any focus listeners we may have going on\n    ignoreFocus(elm);\n    // This focusin listener is to catch focusin events from keyboard interactions\n    // A better solution would perhaps be to listen for keydown events, but\n    // the keydown event happens on whatever element already has focus (or no element\n    // at all in the case of the location bar. So, instead we have to assume that focusin\n    // without a mousedown means keyboard navigation\n    addEventListener.call(elm, 'focusin', skipShadowHandler, true);\n}\nfunction ignoreFocusIn(elm) {\n    removeEventListener.call(elm, 'focusin', skipShadowHandler, true);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { blur, focus } = HTMLElement.prototype;\n/**\n * This method only applies to elements with a shadow attached to them\n */\nfunction tabIndexGetterPatched() {\n    if (isDelegatingFocus(this) && isFalse(hasAttribute.call(this, 'tabindex'))) {\n        // this covers the case where the default tabindex should be 0 because the\n        // custom element is delegating its focus\n        return 0;\n    }\n    return tabIndexGetter.call(this);\n}\n/**\n * This method only applies to elements with a shadow attached to them\n */\nfunction tabIndexSetterPatched(value) {\n    // This tabIndex setter might be confusing unless it is understood that HTML\n    // elements have default tabIndex property values. Natively focusable elements have\n    // a default tabIndex value of 0 and all other elements have a default tabIndex\n    // value of -1. For example, the tabIndex property value is -1 for both <x-foo> and\n    // <x-foo tabindex=\"-1\">, but our delegatesFocus polyfill should only kick in for\n    // the latter case when the value of the tabindex attribute is -1.\n    const delegatesFocus = isDelegatingFocus(this);\n    // Record the state of things before invoking component setter.\n    const prevValue = tabIndexGetter.call(this);\n    const prevHasAttr = hasAttribute.call(this, 'tabindex');\n    tabIndexSetter.call(this, value);\n    // Record the state of things after invoking component setter.\n    const currValue = tabIndexGetter.call(this);\n    const currHasAttr = hasAttribute.call(this, 'tabindex');\n    const didValueChange = prevValue !== currValue;\n    // If the tabindex attribute is initially rendered, we can assume that this setter has\n    // previously executed and a listener has been added. We must remove that listener if\n    // the tabIndex property value has changed or if the component no longer renders a\n    // tabindex attribute.\n    if (prevHasAttr && (didValueChange || isFalse(currHasAttr))) {\n        if (prevValue === -1) {\n            ignoreFocusIn(this);\n        }\n        if (prevValue === 0 && delegatesFocus) {\n            ignoreFocus(this);\n        }\n    }\n    // If a tabindex attribute was not rendered after invoking its setter, it means the\n    // component is taking control. Do nothing.\n    if (isFalse(currHasAttr)) {\n        return;\n    }\n    // If the tabindex attribute is initially rendered, we can assume that this setter has\n    // previously executed and a listener has been added. If the tabindex attribute is still\n    // rendered after invoking the setter AND the tabIndex property value has not changed,\n    // we don't need to do any work.\n    if (prevHasAttr && currHasAttr && isFalse(didValueChange)) {\n        return;\n    }\n    // At this point we know that a tabindex attribute was rendered after invoking the\n    // setter and that either:\n    // 1) This is the first time this setter is being invoked.\n    // 2) This is not the first time this setter is being invoked and the value is changing.\n    // We need to add the appropriate listeners in either case.\n    if (currValue === -1) {\n        // Add the magic to skip the shadow tree\n        handleFocusIn(this);\n    }\n    if (currValue === 0 && delegatesFocus) {\n        // Add the magic to skip the host element\n        handleFocus(this);\n    }\n}\n/**\n * This method only applies to elements with a shadow attached to them\n */\nfunction blurPatched() {\n    if (isDelegatingFocus(this)) {\n        const currentActiveElement = getActiveElement(this);\n        if (!isNull(currentActiveElement)) {\n            // if there is an active element, blur it (intentionally using the dot notation in case the user defines the blur routine)\n            currentActiveElement.blur();\n            return;\n        }\n    }\n    return blur.call(this);\n}\nfunction focusPatched() {\n    // Save enabled state\n    const originallyEnabled = isKeyboardFocusNavigationRoutineEnabled();\n    // Change state by disabling if originally enabled\n    if (originallyEnabled) {\n        disableKeyboardFocusNavigationRoutines();\n    }\n    if (isSyntheticShadowHost(this) && isDelegatingFocus(this)) {\n        hostElementFocus.call(this);\n        return;\n    }\n    // Typescript does not like it when you treat the `arguments` object as an array\n    // @ts-ignore type-mismatch\n    focus.apply(this, arguments);\n    // Restore state by enabling if originally enabled\n    if (originallyEnabled) {\n        enableKeyboardFocusNavigationRoutines();\n    }\n}\n// Non-deep-traversing patches: this descriptor map includes all descriptors that\n// do not five access to nodes beyond the immediate children.\ndefineProperties(HTMLElement.prototype, {\n    tabIndex: {\n        get() {\n            if (isSyntheticShadowHost(this)) {\n                return tabIndexGetterPatched.call(this);\n            }\n            return tabIndexGetter.call(this);\n        },\n        set(v) {\n            if (isSyntheticShadowHost(this)) {\n                return tabIndexSetterPatched.call(this, v);\n            }\n            return tabIndexSetter.call(this, v);\n        },\n        enumerable: true,\n        configurable: true,\n    },\n    blur: {\n        value() {\n            if (isSyntheticShadowHost(this)) {\n                return blurPatched.call(this);\n            }\n            blur.call(this);\n        },\n        enumerable: true,\n        writable: true,\n        configurable: true,\n    },\n    focus: {\n        value() {\n            // Typescript does not like it when you treat the `arguments` object as an array\n            // @ts-ignore type-mismatch\n            focusPatched.apply(this, arguments);\n        },\n        enumerable: true,\n        writable: true,\n        configurable: true,\n    },\n});\n// Note: In JSDOM innerText is not implemented: https://github.com/jsdom/jsdom/issues/1245\nif (innerTextGetter !== null && innerTextSetter !== null) {\n    defineProperty(HTMLElement.prototype, 'innerText', {\n        get() {\n            // Note: we deviate from native shadow here, but are not fixing\n            // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n            return innerTextGetter.call(this);\n        },\n        set(v) {\n            innerTextSetter.call(this, v);\n        },\n        enumerable: true,\n        configurable: true,\n    });\n}\n// Note: Firefox does not have outerText, https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText\nif (outerTextGetter !== null && outerTextSetter !== null) {\n    // From https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/outerText :\n    // HTMLElement.outerText is a non-standard property. As a getter, it returns the same value as Node.innerText.\n    // As a setter, it removes the current node and replaces it with the given text.\n    defineProperty(HTMLElement.prototype, 'outerText', {\n        get() {\n            // Note: we deviate from native shadow here, but are not fixing\n            // due to backwards compat: https://github.com/salesforce/lwc/pull/3103\n            return outerTextGetter.call(this);\n        },\n        set(v) {\n            // Invoking the `outerText` setter on a host element should trigger its disconnection, but until we merge node reactions, it will not work.\n            // We could reimplement the outerText setter in JavaScript ([blink implementation](https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/html/html_element.cc;l=841-879;drc=6e8b402a6231405b753919029c9027404325ea00;bpv=0;bpt=1))\n            // but the benefits don't worth the efforts.\n            outerTextSetter.call(this, v);\n        },\n        enumerable: true,\n        configurable: true,\n    });\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getShadowToken(node) {\n    return node[KEY__SHADOW_TOKEN];\n}\nfunction setShadowToken(node, shadowToken) {\n    node[KEY__SHADOW_TOKEN] = shadowToken;\n}\n/**\n * Patching Element.prototype.$shadowToken$ to mark elements a portal:\n *\n *  - we use a property to allow engines to set a custom attribute that should be\n *    placed into the element to sandbox the css rules defined for the template.\n *\n *  - this custom attribute must be unique.\n *\n **/\ndefineProperty(Element.prototype, KEY__SHADOW_TOKEN, {\n    set(shadowToken) {\n        const oldShadowToken = this[KEY__SHADOW_TOKEN_PRIVATE];\n        if (!isUndefined(oldShadowToken) && oldShadowToken !== shadowToken) {\n            removeAttribute.call(this, oldShadowToken);\n        }\n        if (!isUndefined(shadowToken)) {\n            setAttribute.call(this, shadowToken, '');\n        }\n        this[KEY__SHADOW_TOKEN_PRIVATE] = shadowToken;\n    },\n    get() {\n        return this[KEY__SHADOW_TOKEN_PRIVATE];\n    },\n    configurable: true,\n});\nfunction recursivelySetShadowResolver(node, fn) {\n    node[KEY__SHADOW_RESOLVER] = fn;\n    const childNodes = childNodesGetter.call(node);\n    for (let i = 0, n = childNodes.length; i < n; i++) {\n        recursivelySetShadowResolver(childNodes[i], fn);\n    }\n}\ndefineProperty(Element.prototype, KEY__SHADOW_STATIC, {\n    set(v) {\n        // Marking an element as static will propagate the shadow resolver to the children.\n        if (v) {\n            const fn = this[KEY__SHADOW_RESOLVER];\n            recursivelySetShadowResolver(this, fn);\n        }\n        this[KEY__SHADOW_STATIC_PRIVATE] = v;\n    },\n    get() {\n        return this[KEY__SHADOW_STATIC_PRIVATE];\n    },\n    configurable: true,\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst DomManualPrivateKey = '$$DomManualKey$$';\n// Resolver function used when a node is removed from within a portal\nconst DocumentResolverFn = function () { };\n// We can use a single observer without having to worry about leaking because\n// \"Registered observers in a node’s registered observer list have a weak\n// reference to the node.\"\n// https://dom.spec.whatwg.org/#garbage-collection\nlet portalObserver;\nconst portalObserverConfig = {\n    childList: true,\n};\nfunction adoptChildNode(node, fn, shadowToken) {\n    const previousNodeShadowResolver = getShadowRootResolver(node);\n    if (previousNodeShadowResolver === fn) {\n        return; // nothing to do here, it is already correctly patched\n    }\n    setShadowRootResolver(node, fn);\n    if (node instanceof Element) {\n        setShadowToken(node, shadowToken);\n        if (isSyntheticShadowHost(node)) {\n            // Root LWC elements can't get content slotted into them, therefore we don't observe their children.\n            return;\n        }\n        if (isUndefined(previousNodeShadowResolver)) {\n            // we only care about Element without shadowResolver (no MO.observe has been called)\n            MutationObserverObserve.call(portalObserver, node, portalObserverConfig);\n        }\n        // recursively patching all children as well\n        const childNodes = childNodesGetter.call(node);\n        for (let i = 0, len = childNodes.length; i < len; i += 1) {\n            adoptChildNode(childNodes[i], fn, shadowToken);\n        }\n    }\n}\nfunction initPortalObserver() {\n    return new MO((mutations) => {\n        forEach.call(mutations, (mutation) => {\n            /**\n             * This routine will process all nodes added or removed from elm (which is marked as a portal)\n             * When adding a node to the portal element, we should add the ownership.\n             * When removing a node from the portal element, this ownership should be removed.\n             *\n             * There is some special cases in which MutationObserver may call with stacked mutations (the same node\n             * will be in addedNodes and removedNodes) or with false positives (a node that is removed and re-appended\n             * in the same tick) for those cases, we cover by checking that the node is contained\n             * (or not in the case of removal) by the element.\n             */\n            const { target: elm, addedNodes, removedNodes } = mutation;\n            // the target of the mutation should always have a ShadowRootResolver attached to it\n            const fn = getShadowRootResolver(elm);\n            const shadowToken = getShadowToken(elm);\n            // Process removals first to handle the case where an element is removed and reinserted\n            for (let i = 0, len = removedNodes.length; i < len; i += 1) {\n                const node = removedNodes[i];\n                if (!(compareDocumentPosition.call(elm, node) & _Node.DOCUMENT_POSITION_CONTAINED_BY)) {\n                    adoptChildNode(node, DocumentResolverFn, undefined);\n                }\n            }\n            for (let i = 0, len = addedNodes.length; i < len; i += 1) {\n                const node = addedNodes[i];\n                if (compareDocumentPosition.call(elm, node) & _Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                    adoptChildNode(node, fn, shadowToken);\n                }\n            }\n        });\n    });\n}\nfunction markElementAsPortal(elm) {\n    if (isUndefined(portalObserver)) {\n        portalObserver = initPortalObserver();\n    }\n    if (isUndefined(getShadowRootResolver(elm))) {\n        // only an element from a within a shadowRoot should be used here\n        throw new Error(`Invalid Element`);\n    }\n    // install mutation observer for portals\n    MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);\n    // TODO [#1253]: optimization to synchronously adopt new child nodes added\n    // to this elm, we can do that by patching the most common operations\n    // on the node itself\n}\n/**\n * Patching Element.prototype.$domManual$ to mark elements as portal:\n *\n *  - we use a property to allow engines to signal that a particular element in\n *    a shadow supports manual insertion of child nodes.\n *\n *  - this signal comes as a boolean value, and we use it to install the MO instance\n *    onto the element, to propagate the $ownerKey$ and $shadowToken$ to all new\n *    child nodes.\n *\n *  - at the moment, there is no way to undo this operation, once the element is\n *    marked as $domManual$, setting it to false does nothing.\n *\n **/\n// TODO [#1306]: rename this to $observerConnection$\ndefineProperty(Element.prototype, '$domManual$', {\n    set(v) {\n        this[DomManualPrivateKey] = v;\n        if (isTrue(v)) {\n            markElementAsPortal(this);\n        }\n    },\n    get() {\n        return this[DomManualPrivateKey];\n    },\n    configurable: true,\n});\n/** version: 2.37.3 */\n","function stylesheet(token, useActualHostSelector, useNativeDirPseudoclass) {\n  var shadowSelector = token ? (\"[\" + token + \"]\") : \"\";\n  var hostSelector = token ? (\"[\" + token + \"-host]\") : \"\";\n  var suffixToken = token ? (\"-\" + token) : \"\";\n  return \".inp-page-header-border-bottom\" + shadowSelector + \" {border-bottom: #dddbda 1px solid;}.inp-page-footer-border\" + shadowSelector + \" {border-top: #dddbda 1px solid;border-bottom: #dddbda 1px solid;}.inp-box\" + shadowSelector + \" {border-radius: 5px;border: 1px solid #ffffff;padding: 10px;}.inp-box_blue\" + shadowSelector + \" {border-radius: 5px;border: 1px dashed #ffffff;padding: 10px;}.inp-theme_blue\" + shadowSelector + \" {background-color: #2873b9;color: #ffffff;}.inp-page-body-background\" + shadowSelector + \" {background-image: url('./dist/resources/assets/images/blueprint_background.jpg');background-repeat: repeat;}\";\n  /*LWC compiler v2.37.3*/\n}\nexport default [stylesheet];","import { freezeTemplate } from \"lwc\";\n\nimport _implicitStylesheets from \"./app.css\";\n\nimport _implicitScopedStylesheets from \"./app.scoped.css?scoped=true\";\n\nimport {parseFragment, registerTemplate} from \"lwc\";\nconst $fragment1 = parseFragment`<div class=\"slds-col slds-size_1-of-1 slds-grid slds-theme_default inp-page-header-border-bottom${0}\"${2}><div class=\"slds-col slds-medium-size_3-of-12 slds-large-size_3-of-12${0}\"${2}></div><div class=\"slds-col slds-size_1-of-1 slds-medium-size_6-of-12 slds-large-size_6-of-12${0}\"${2}><div class=\"slds-text-heading_large slds-p-left--medium slds-p-top--medium${0}\"${2}>Pavel Navrátil</div><div class=\"slds-text-body_small slds-p-left--medium slds-p-bottom--medium${0}\"${2}>Senior Full Stack Salesforce Developer</div></div><div class=\"slds-col slds-medium-size_3-of-12 slds-large-size_3-of-12${0}\"${2}></div></div>`;\nconst $fragment2 = parseFragment`<div class=\"slds-col slds-size_1-of-1 slds-grid slds-p-top--large slds-p-bottom--large inp-page-body-background${0}\"${2}><div class=\"slds-col slds-medium-size_3-of-12 slds-large-size_3-of-12${0}\"${2}></div><div class=\"slds-col slds-size_1-of-1 slds-medium-size_6-of-12 slds-large-size_6-of-12 slds-grid slds-wrap${0}\"${2}><div class=\"slds-col slds-size_1-of-1${0}\"${2}><div class=\"inp-box_blue inp-theme_blue slds-m-bottom--large${0}\"${2}>Page is under construction.</div></div><div class=\"slds-col slds-size_1-of-1${0}\"${2}><div class=\"inp-box slds-theme_default slds-m-bottom--large${0}\"${2}>I&#x27;m an accomplished explorer, a full stack web developer with a passion for Salesforce. Layered by outdoor, travel, adventure, and bike.</div></div></div><div class=\"slds-col slds-medium-size_3-of-12 slds-large-size_3-of-12${0}\"${2}></div></div>`;\nconst $fragment3 = parseFragment`<div class=\"slds-col slds-medium-size_3-of-12 slds-large-size_3-of-12${0}\"${2}></div>`;\nconst $fragment4 = parseFragment`<div class=\"slds-col slds-medium-size_3-of-12 slds-large-size_3-of-12${0}\"${2}></div>`;\nconst stc0 = {\n  classMap: {\n    \"slds-grid\": true,\n    \"slds-wrap\": true\n  },\n  key: 0\n};\nconst stc1 = {\n  classMap: {\n    \"slds-col\": true,\n    \"slds-size_1-of-1\": true,\n    \"slds-grid\": true,\n    \"slds-theme_default\": true,\n    \"inp-page-footer-border\": true\n  },\n  key: 5\n};\nconst stc2 = {\n  classMap: {\n    \"slds-col\": true,\n    \"slds-size_1-of-1\": true,\n    \"slds-medium-size_6-of-12\": true,\n    \"slds-large-size_6-of-12\": true\n  },\n  key: 8\n};\nconst stc3 = {\n  classMap: {\n    \"slds-p-left--medium\": true,\n    \"slds-p-top--xx-small\": true,\n    \"slds-p-bottom--xx-small\": true\n  },\n  key: 9\n};\nfunction tmpl($api, $cmp, $slotset, $ctx) {\n  const {st: api_static_fragment, d: api_dynamic_text, t: api_text, h: api_element} = $api;\n  return [api_element(\"div\", stc0, [api_static_fragment($fragment1(), 2), api_static_fragment($fragment2(), 4), api_element(\"div\", stc1, [api_static_fragment($fragment3(), 7), api_element(\"div\", stc2, [api_element(\"div\", stc3, [api_text(\"©\" + api_dynamic_text($cmp.currentYear) + \" Pavel Navrátil.\")])]), api_static_fragment($fragment4(), 11)])])];\n  /*LWC compiler v2.37.3*/\n}\nexport default registerTemplate(tmpl);\ntmpl.stylesheets = [];\n\n\nif (_implicitStylesheets) {\n  tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);\n}\nif (_implicitScopedStylesheets) {\n  tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitScopedStylesheets);\n}\ntmpl.stylesheetToken = \"my-app_app\";\nfreezeTemplate(tmpl);\n","import _tmpl from \"./app.html\";\nimport { registerComponent as _registerComponent, LightningElement } from \"lwc\";\nclass App extends LightningElement {\n  get currentYear() {\n    return new Date().getFullYear();\n  }\n  /*LWC compiler v2.37.3*/\n}\nexport default _registerComponent(App, {\n  tmpl: _tmpl\n});","\"use strict\";\nexports.__esModule = true;\n/*\n * Copyright (c) 2022, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nexports[\"default\"] = undefined;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import '@lwc/synthetic-shadow';\nimport { createElement } from 'lwc';\nimport MyApp from 'my/app';\n\nconst app = createElement('my-app', { is: MyApp });\ndocument.body.appendChild(app);\n"],"names":[],"sourceRoot":""}